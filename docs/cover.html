
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/amirasaad/fintech/docs/docs.go (0.0%)</option>
				
				<option value="file1">github.com/amirasaad/fintech/infra/cache/memory_cache.go (0.0%)</option>
				
				<option value="file2">github.com/amirasaad/fintech/infra/config/exchange_rates.go (0.0%)</option>
				
				<option value="file3">github.com/amirasaad/fintech/infra/currency_converter.go (0.0%)</option>
				
				<option value="file4">github.com/amirasaad/fintech/infra/database.go (17.6%)</option>
				
				<option value="file5">github.com/amirasaad/fintech/infra/exchange_rates.go (83.3%)</option>
				
				<option value="file6">github.com/amirasaad/fintech/infra/factory.go (0.0%)</option>
				
				<option value="file7">github.com/amirasaad/fintech/infra/providers/exchangerate_api.go (0.0%)</option>
				
				<option value="file8">github.com/amirasaad/fintech/infra/repository.go (23.2%)</option>
				
				<option value="file9">github.com/amirasaad/fintech/infra/uow.go (80.8%)</option>
				
				<option value="file10">github.com/amirasaad/fintech/pkg/domain/account.go (86.2%)</option>
				
				<option value="file11">github.com/amirasaad/fintech/pkg/domain/currency_converter.go (0.0%)</option>
				
				<option value="file12">github.com/amirasaad/fintech/pkg/domain/money.go (0.0%)</option>
				
				<option value="file13">github.com/amirasaad/fintech/pkg/domain/user.go (14.3%)</option>
				
				<option value="file14">github.com/amirasaad/fintech/pkg/middleware/auth.go (100.0%)</option>
				
				<option value="file15">github.com/amirasaad/fintech/pkg/service/account.go (70.4%)</option>
				
				<option value="file16">github.com/amirasaad/fintech/pkg/service/auth.go (25.7%)</option>
				
				<option value="file17">github.com/amirasaad/fintech/pkg/service/user.go (88.4%)</option>
				
				<option value="file18">github.com/amirasaad/fintech/webapi/account.go (80.9%)</option>
				
				<option value="file19">github.com/amirasaad/fintech/webapi/app.go (75.0%)</option>
				
				<option value="file20">github.com/amirasaad/fintech/webapi/auth.go (100.0%)</option>
				
				<option value="file21">github.com/amirasaad/fintech/webapi/test_utils.go (86.6%)</option>
				
				<option value="file22">github.com/amirasaad/fintech/webapi/user.go (73.1%)</option>
				
				<option value="file23">github.com/amirasaad/fintech/webapi/utils.go (70.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "email": "fiber@swagger.io"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/account": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Create a new account for the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Create a new account",
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/webapi.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/account/{id}/balance": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Retrieve the balance of a specific account",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Get account balance",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/webapi.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/account/{id}/deposit": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Deposit a specified amount into the user's account",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Deposit funds into an account",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Deposit request with amount",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/webapi.DepositRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/webapi.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/account/{id}/transactions": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Retrieve the list of transactions for a specific account",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Get account transactions",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/webapi.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/account/{id}/withdraw": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Withdraw a specified amount from the user's account",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Withdraw funds from an account",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Withdrawal request with amount",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/webapi.WithdrawRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/webapi.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/login": {
            "post": {
                "description": "Authenticate user with identity (username or email) and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "Login credentials",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/webapi.LoginInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/webapi.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/user": {
            "post": {
                "description": "Create a new user account with username, email, and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Create a new user",
                "parameters": [
                    {
                        "description": "User creation data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/webapi.NewUser"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/webapi.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/user/{id}": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get a user by their unique identifier",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get user by ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/webapi.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/webapi.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/webapi.Response"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Update user information by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Update user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "User update data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/webapi.UpdateUserInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/webapi.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Delete a user account by ID with password confirmation",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Delete user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Password confirmation",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/webapi.PasswordInput"
                        }
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content",
                        "schema": {
                            "$ref": "#/definitions/webapi.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/webapi.ProblemDetails"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "webapi.DepositRequest": {
            "type": "object",
            "properties": {
                "amount": {
                    "type": "number"
                },
                "currency": {
                    "type": "string"
                }
            }
        },
        "webapi.LoginInput": {
            "type": "object",
            "properties": {
                "identity": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "webapi.NewUser": {
            "type": "object",
            "required": [
                "email",
                "password",
                "username"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "maxLength": 50
                },
                "password": {
                    "type": "string",
                    "minLength": 6
                },
                "username": {
                    "type": "string",
                    "maxLength": 50
                }
            }
        },
        "webapi.PasswordInput": {
            "type": "object",
            "properties": {
                "password": {
                    "type": "string"
                }
            }
        },
        "webapi.ProblemDetails": {
            "type": "object",
            "properties": {
                "detail": {
                    "description": "Human-readable explanation",
                    "type": "string"
                },
                "errors": {
                    "description": "Optional: additional error details"
                },
                "instance": {
                    "description": "URI reference that identifies the specific occurrence",
                    "type": "string"
                },
                "status": {
                    "description": "HTTP status code",
                    "type": "integer"
                },
                "title": {
                    "description": "Short, human-readable summary",
                    "type": "string"
                },
                "type": {
                    "description": "A URI reference that identifies the problem type",
                    "type": "string"
                }
            }
        },
        "webapi.Response": {
            "type": "object",
            "properties": {
                "data": {
                    "description": "Response data"
                },
                "message": {
                    "description": "Human-readable explanation",
                    "type": "string"
                },
                "status": {
                    "description": "HTTP status code",
                    "type": "integer"
                }
            }
        },
        "webapi.UpdateUserInput": {
            "type": "object",
            "properties": {
                "names": {
                    "type": "string"
                }
            }
        },
        "webapi.WithdrawRequest": {
            "type": "object",
            "properties": {
                "amount": {
                    "type": "number"
                },
                "currency": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0.0",
        Host:             "fintech-beryl-beta.vercel.app",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "Fintech API",
        Description:      "Fintech API documentation",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cache

import (
        "sync"
        "time"

        "github.com/amirasaad/fintech/pkg/domain"
)

// MemoryCache implements ExchangeRateCache using in-memory storage
type MemoryCache struct {
        cache map[string]*cacheEntry
        mu    sync.RWMutex
}

type cacheEntry struct {
        rate      *domain.ExchangeRate
        expiresAt time.Time
}

// NewMemoryCache creates a new in-memory cache
func NewMemoryCache() *MemoryCache <span class="cov0" title="0">{
        cache := &amp;MemoryCache{
                cache: make(map[string]*cacheEntry),
        }

        // Start cleanup goroutine
        go cache.cleanup()

        return cache
}</span>

// Get retrieves a rate from cache
func (c *MemoryCache) Get(key string) (*domain.ExchangeRate, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        entry, exists := c.cache[key]
        if !exists </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if time.Now().After(entry.expiresAt) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return entry.rate, nil</span>
}

// Set stores a rate in cache with TTL
func (c *MemoryCache) Set(key string, rate *domain.ExchangeRate, ttl time.Duration) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.cache[key] = &amp;cacheEntry{
                rate:      rate,
                expiresAt: time.Now().Add(ttl),
        }

        return nil
}</span>

// Delete removes a rate from cache
func (c *MemoryCache) Delete(key string) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.cache, key)
        return nil
}</span>

// cleanup removes expired entries from cache
func (c *MemoryCache) cleanup() <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                c.mu.Lock()
                now := time.Now()
                for key, entry := range c.cache </span><span class="cov0" title="0">{
                        if now.After(entry.expiresAt) </span><span class="cov0" title="0">{
                                delete(c.cache, key)
                        }</span>
                }
                <span class="cov0" title="0">c.mu.Unlock()</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "os"
        "strconv"
        "time"
)

// ExchangeRateConfig holds configuration for exchange rate services
type ExchangeRateConfig struct {
        // Provider settings
        ExchangeRateAPIKey string
        ExchangeRateAPIURL string

        // Cache settings
        CacheTTL time.Duration

        // HTTP settings
        HTTPTimeout time.Duration
        MaxRetries  int

        // Rate limiting
        RequestsPerMinute int
        BurstSize         int

        // Fallback settings
        EnableFallback bool
        FallbackTTL    time.Duration
}

// LoadExchangeRateConfig loads configuration from environment variables
func LoadExchangeRateConfig() *ExchangeRateConfig <span class="cov0" title="0">{
        config := &amp;ExchangeRateConfig{
                // Provider settings
                ExchangeRateAPIKey: getEnv("EXCHANGE_RATE_API_KEY", ""),
                ExchangeRateAPIURL: getEnv("EXCHANGE_RATE_API_URL", "https://api.exchangerate-api.com/v4/latest"),

                // Cache settings
                CacheTTL: getEnvAsDuration("EXCHANGE_RATE_CACHE_TTL", 15*time.Minute),

                // HTTP settings
                HTTPTimeout: getEnvAsDuration("EXCHANGE_RATE_HTTP_TIMEOUT", 10*time.Second),
                MaxRetries:  getEnvAsInt("EXCHANGE_RATE_MAX_RETRIES", 3),

                // Rate limiting
                RequestsPerMinute: getEnvAsInt("EXCHANGE_RATE_REQUESTS_PER_MINUTE", 60),
                BurstSize:         getEnvAsInt("EXCHANGE_RATE_BURST_SIZE", 10),

                // Fallback settings
                EnableFallback: getEnvAsBool("EXCHANGE_RATE_ENABLE_FALLBACK", true),
                FallbackTTL:    getEnvAsDuration("EXCHANGE_RATE_FALLBACK_TTL", 1*time.Hour),
        }

        return config
}</span>

// Helper functions for environment variable parsing
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package infra

import (
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain"
)

// RealCurrencyConverter implements the CurrencyConverter interface using real exchange rates.
type RealCurrencyConverter struct {
        exchangeRateService *ExchangeRateService
        logger              *slog.Logger
        fallback            domain.CurrencyConverter
}

// NewRealCurrencyConverter creates a new real currency converter with fallback support.
func NewRealCurrencyConverter(exchangeRateService *ExchangeRateService, fallback domain.CurrencyConverter, logger *slog.Logger) *RealCurrencyConverter <span class="cov0" title="0">{
        return &amp;RealCurrencyConverter{
                exchangeRateService: exchangeRateService,
                logger:              logger,
                fallback:            fallback,
        }
}</span>

// Convert converts an amount from one currency to another using real exchange rates.
func (c *RealCurrencyConverter) Convert(amount float64, from, to string) (*domain.ConversionInfo, error) <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return &amp;domain.ConversionInfo{
                        OriginalAmount:    amount,
                        OriginalCurrency:  from,
                        ConvertedAmount:   amount,
                        ConvertedCurrency: to,
                        ConversionRate:    1.0,
                }, nil
        }</span>

        // Try to get real exchange rate
        <span class="cov0" title="0">rate, err := c.exchangeRateService.GetRate(from, to)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to get real exchange rate, falling back", "from", from, "to", to, "error", err)

                // Use fallback converter
                if c.fallback != nil </span><span class="cov0" title="0">{
                        return c.fallback.Convert(amount, from, to)
                }</span>

                <span class="cov0" title="0">return nil, domain.ErrExchangeRateUnavailable</span>
        }

        <span class="cov0" title="0">convertedAmount := amount * rate.Rate

        c.logger.Info("Currency conversion completed",
                "from", from, "to", to, "amount", amount,
                "converted", convertedAmount, "rate", rate.Rate, "source", rate.Source)

        return &amp;domain.ConversionInfo{
                OriginalAmount:    amount,
                OriginalCurrency:  from,
                ConvertedAmount:   convertedAmount,
                ConvertedCurrency: to,
                ConversionRate:    rate.Rate,
        }, nil</span>
}

// GetRate returns the current exchange rate between two currencies.
func (c *RealCurrencyConverter) GetRate(from, to string) (float64, error) <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return 1.0, nil
        }</span>

        <span class="cov0" title="0">rate, err := c.exchangeRateService.GetRate(from, to)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to get real exchange rate, falling back", "from", from, "to", to, "error", err)

                // Use fallback converter
                if c.fallback != nil </span><span class="cov0" title="0">{
                        return c.fallback.GetRate(from, to)
                }</span>

                <span class="cov0" title="0">return 0, domain.ErrExchangeRateUnavailable</span>
        }

        <span class="cov0" title="0">return rate.Rate, nil</span>
}

// IsSupported checks if a currency pair is supported by checking if we can get a rate.
func (c *RealCurrencyConverter) IsSupported(from, to string) bool <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return true
        }</span>

        // Try to get a rate to check if supported
        <span class="cov0" title="0">_, err := c.exchangeRateService.GetRate(from, to)
        if err == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check fallback
        <span class="cov0" title="0">if c.fallback != nil </span><span class="cov0" title="0">{
                return c.fallback.IsSupported(from, to)
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package infra

import (
        "errors"
        "os"
        "time"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

func NewDBConnection() (*gorm.DB, error) <span class="cov8" title="1">{
        databaseUrl := os.Getenv("DATABASE_URL")
        if databaseUrl == "" </span><span class="cov8" title="1">{
                return nil, errors.New("DATABASE_URL is not set")
        }</span>

        <span class="cov0" title="0">var logMode logger.LogLevel
        if os.Getenv("APP_ENV") == "development" </span><span class="cov0" title="0">{
                logMode = logger.Info
        }</span> else<span class="cov0" title="0"> {
                logMode = logger.Silent
        }</span>

        <span class="cov0" title="0">connection, err := gorm.Open(postgres.Open(databaseUrl), &amp;gorm.Config{
                Logger:                 logger.Default.LogMode(logMode),
                SkipDefaultTransaction: true})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sqlDB, err := connection.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(25)
        sqlDB.SetMaxIdleConns(25)
        sqlDB.SetConnMaxLifetime(1 * time.Hour)

        return connection, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package infra

import (
        "fmt"
        "log/slog"
        "math"
        "sync"
        "time"

        "github.com/amirasaad/fintech/pkg/domain"
)

// ExchangeRateService provides real-time exchange rates with caching and fallback providers.
type ExchangeRateService struct {
        providers []domain.ExchangeRateProvider
        cache     ExchangeRateCache
        logger    *slog.Logger
        mu        sync.RWMutex
}

// ExchangeRateCache defines the interface for caching exchange rates.
type ExchangeRateCache interface {
        Get(key string) (*domain.ExchangeRate, error)
        Set(key string, rate *domain.ExchangeRate, ttl time.Duration) error
        Delete(key string) error
}

// NewExchangeRateService creates a new exchange rate service with the given providers and cache.
func NewExchangeRateService(providers []domain.ExchangeRateProvider, cache ExchangeRateCache, logger *slog.Logger) *ExchangeRateService <span class="cov8" title="1">{
        return &amp;ExchangeRateService{
                providers: providers,
                cache:     cache,
                logger:    logger,
        }
}</span>

// GetRate retrieves an exchange rate, trying cache first, then providers in order.
func (s *ExchangeRateService) GetRate(from, to string) (*domain.ExchangeRate, error) <span class="cov8" title="1">{
        if from == to </span><span class="cov8" title="1">{
                return &amp;domain.ExchangeRate{
                        FromCurrency: from,
                        ToCurrency:   to,
                        Rate:         1.0,
                        LastUpdated:  time.Now(),
                        Source:       "internal",
                        ExpiresAt:    time.Now().Add(24 * time.Hour),
                }, nil
        }</span>

        // Try cache first
        <span class="cov8" title="1">cacheKey := fmt.Sprintf("%s:%s", from, to)
        if cached, err := s.cache.Get(cacheKey); err == nil &amp;&amp; cached != nil </span><span class="cov8" title="1">{
                if time.Now().Before(cached.ExpiresAt) </span><span class="cov8" title="1">{
                        s.logger.Debug("Exchange rate retrieved from cache", "from", from, "to", to, "rate", cached.Rate)
                        return cached, nil
                }</span>
                // Rate expired, remove from cache
                <span class="cov0" title="0">_ = s.cache.Delete(cacheKey)</span>
        }

        // Try providers in order
        <span class="cov8" title="1">for _, provider := range s.providers </span><span class="cov8" title="1">{
                if !provider.IsHealthy() </span><span class="cov8" title="1">{
                        s.logger.Warn("Provider not healthy, skipping", "provider", provider.Name())
                        continue</span>
                }

                <span class="cov8" title="1">rate, err := provider.GetRate(from, to)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Warn("Failed to get rate from provider", "provider", provider.Name(), "error", err)
                        continue</span>
                }

                // Validate rate
                <span class="cov8" title="1">if rate.Rate &lt;= 0 || math.IsNaN(rate.Rate) || math.IsInf(rate.Rate, 0) </span><span class="cov8" title="1">{
                        s.logger.Warn("Invalid rate received from provider", "provider", provider.Name(), "rate", rate.Rate)
                        continue</span>
                }

                // Cache the rate
                <span class="cov8" title="1">ttl := time.Until(rate.ExpiresAt)
                if ttl &gt; 0 </span><span class="cov8" title="1">{
                        _ = s.cache.Set(cacheKey, rate, ttl)
                }</span>

                <span class="cov8" title="1">s.logger.Info("Exchange rate retrieved from provider", "provider", provider.Name(), "from", from, "to", to, "rate", rate.Rate)
                return rate, nil</span>
        }

        <span class="cov8" title="1">return nil, domain.ErrExchangeRateUnavailable</span>
}

// GetRates retrieves multiple exchange rates efficiently.
func (s *ExchangeRateService) GetRates(from string, to []string) (map[string]*domain.ExchangeRate, error) <span class="cov8" title="1">{
        results := make(map[string]*domain.ExchangeRate)
        var missing []string

        // Try cache first for each currency
        for _, currency := range to </span><span class="cov8" title="1">{
                cacheKey := fmt.Sprintf("%s:%s", from, currency)
                if cached, err := s.cache.Get(cacheKey); err == nil &amp;&amp; cached != nil </span><span class="cov0" title="0">{
                        if time.Now().Before(cached.ExpiresAt) </span><span class="cov0" title="0">{
                                results[currency] = cached
                                continue</span>
                        }
                        <span class="cov0" title="0">_ = s.cache.Delete(cacheKey)</span>
                }
                <span class="cov8" title="1">missing = append(missing, currency)</span>
        }

        // If we have missing rates, try providers
        <span class="cov8" title="1">if len(missing) &gt; 0 </span><span class="cov8" title="1">{
                for _, provider := range s.providers </span><span class="cov8" title="1">{
                        if !provider.IsHealthy() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">rates, err := provider.GetRates(from, missing)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to get rates from provider", "provider", provider.Name(), "error", err)
                                continue</span>
                        }

                        // Cache and add valid rates
                        <span class="cov8" title="1">for currency, rate := range rates </span><span class="cov8" title="1">{
                                if rate.Rate &gt; 0 &amp;&amp; !math.IsNaN(rate.Rate) &amp;&amp; !math.IsInf(rate.Rate, 0) </span><span class="cov8" title="1">{
                                        results[currency] = rate
                                        cacheKey := fmt.Sprintf("%s:%s", from, currency)
                                        ttl := time.Until(rate.ExpiresAt)
                                        if ttl &gt; 0 </span><span class="cov8" title="1">{
                                                _ = s.cache.Set(cacheKey, rate, ttl)
                                        }</span>
                                }
                        }

                        // Update missing list
                        <span class="cov8" title="1">missing = missing[:0]
                        for _, currency := range to </span><span class="cov8" title="1">{
                                if _, exists := results[currency]; !exists </span><span class="cov0" title="0">{
                                        missing = append(missing, currency)
                                }</span>
                        }

                        <span class="cov8" title="1">if len(missing) == 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, domain.ErrExchangeRateUnavailable
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package infra

import (
        "log/slog"

        "github.com/amirasaad/fintech/infra/cache"
        "github.com/amirasaad/fintech/infra/config"
        "github.com/amirasaad/fintech/infra/providers"
        "github.com/amirasaad/fintech/pkg/domain"
)

// NewExchangeRateSystem creates a complete exchange rate system with providers, cache, and converter
func NewExchangeRateSystem(logger *slog.Logger) (domain.CurrencyConverter, error) <span class="cov0" title="0">{
        // Load configuration
        cfg := config.LoadExchangeRateConfig()

        // Create cache
        rateCache := cache.NewMemoryCache()

        // Create providers
        var exchangeRateProviders []domain.ExchangeRateProvider

        // Add ExchangeRate API provider if API key is configured
        if cfg.ExchangeRateAPIKey != "" </span><span class="cov0" title="0">{
                exchangeRateProvider := providers.NewExchangeRateAPIProvider(cfg.ExchangeRateAPIKey, logger)
                exchangeRateProviders = append(exchangeRateProviders, exchangeRateProvider)
                logger.Info("ExchangeRate API provider configured", "apiKey", maskAPIKey(cfg.ExchangeRateAPIKey))
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("No ExchangeRate API key configured, using fallback only")
        }</span>

        // Create exchange rate service
        <span class="cov0" title="0">exchangeRateService := NewExchangeRateService(exchangeRateProviders, rateCache, logger)

        // Create fallback converter
        var fallback domain.CurrencyConverter
        if cfg.EnableFallback </span><span class="cov0" title="0">{
                fallback = domain.NewStubCurrencyConverter()
                logger.Info("Fallback currency converter enabled")
        }</span>

        // Create real currency converter
        <span class="cov0" title="0">converter := NewRealCurrencyConverter(exchangeRateService, fallback, logger)

        logger.Info("Exchange rate system initialized",
                "providers", len(exchangeRateProviders),
                "fallbackEnabled", cfg.EnableFallback,
                "cacheTTL", cfg.CacheTTL)

        return converter, nil</span>
}

// maskAPIKey returns a masked version of the API key for logging
func maskAPIKey(apiKey string) string <span class="cov0" title="0">{
        if len(apiKey) &lt;= 8 </span><span class="cov0" title="0">{
                return "***"
        }</span>
        <span class="cov0" title="0">return apiKey[:4] + "..." + apiKey[len(apiKey)-4:]</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package providers

import (
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "time"

        "github.com/amirasaad/fintech/pkg/domain"
)

// ExchangeRateAPIProvider implements the ExchangeRateProvider interface for exchangerate-api.com
type ExchangeRateAPIProvider struct {
        apiKey     string
        baseURL    string
        httpClient *http.Client
        logger     *slog.Logger
}

// ExchangeRateAPIResponse represents the response from the ExchangeRate API
type ExchangeRateAPIResponse struct {
        Success   bool               `json:"success"`
        Timestamp int64              `json:"timestamp"`
        Base      string             `json:"base"`
        Date      string             `json:"date"`
        Rates     map[string]float64 `json:"rates"`
}

// NewExchangeRateAPIProvider creates a new ExchangeRate API provider
func NewExchangeRateAPIProvider(apiKey string, logger *slog.Logger) *ExchangeRateAPIProvider <span class="cov0" title="0">{
        return &amp;ExchangeRateAPIProvider{
                apiKey:  apiKey,
                baseURL: "https://api.exchangerate-api.com/v4/latest",
                httpClient: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
                logger: logger,
        }
}</span>

// GetRate fetches the current exchange rate for a currency pair
func (p *ExchangeRateAPIProvider) GetRate(from, to string) (*domain.ExchangeRate, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/%s", p.baseURL, from)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">if p.apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+p.apiKey)
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResp ExchangeRateAPIResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;apiResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if !apiResp.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned success=false")
        }</span>

        <span class="cov0" title="0">rate, exists := apiResp.Rates[to]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("currency %s not found in response", to)
        }</span>

        // Parse the date from the API response
        <span class="cov0" title="0">date, err := time.Parse("2006-01-02", apiResp.Date)
        if err != nil </span><span class="cov0" title="0">{
                date = time.Now()
        }</span>

        <span class="cov0" title="0">return &amp;domain.ExchangeRate{
                FromCurrency: from,
                ToCurrency:   to,
                Rate:         rate,
                LastUpdated:  time.Unix(apiResp.Timestamp, 0),
                Source:       "exchangerate-api",
                ExpiresAt:    date.Add(24 * time.Hour), // Rates typically valid for 24 hours
        }, nil</span>
}

// GetRates fetches multiple exchange rates in a single request
func (p *ExchangeRateAPIProvider) GetRates(from string, to []string) (map[string]*domain.ExchangeRate, error) <span class="cov0" title="0">{
        // For this provider, we need to make a single request and extract the rates we need
        // We'll make a direct request to get all rates for the base currency

        // Since this provider returns all rates in one call, we need to make a full request
        url := fmt.Sprintf("%s/%s", p.baseURL, from)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">if p.apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+p.apiKey)
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResp ExchangeRateAPIResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;apiResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if !apiResp.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned success=false")
        }</span>

        // Parse the date from the API response
        <span class="cov0" title="0">date, err := time.Parse("2006-01-02", apiResp.Date)
        if err != nil </span><span class="cov0" title="0">{
                date = time.Now()
        }</span>

        <span class="cov0" title="0">results := make(map[string]*domain.ExchangeRate)
        for _, currency := range to </span><span class="cov0" title="0">{
                if rate, exists := apiResp.Rates[currency]; exists </span><span class="cov0" title="0">{
                        results[currency] = &amp;domain.ExchangeRate{
                                FromCurrency: from,
                                ToCurrency:   currency,
                                Rate:         rate,
                                LastUpdated:  time.Unix(apiResp.Timestamp, 0),
                                Source:       "exchangerate-api",
                                ExpiresAt:    date.Add(24 * time.Hour),
                        }
                }</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// Name returns the provider's name
func (p *ExchangeRateAPIProvider) Name() string <span class="cov0" title="0">{
        return "exchangerate-api"
}</span>

// IsHealthy checks if the provider is currently available
func (p *ExchangeRateAPIProvider) IsHealthy() bool <span class="cov0" title="0">{
        // Make a simple health check request
        url := fmt.Sprintf("%s/USD", p.baseURL)
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if p.apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+p.apiKey)
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        return resp.StatusCode == http.StatusOK</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package infra

import (
        "time"

        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type accountRepository struct {
        db *gorm.DB
}

func NewAccountRepository(db *gorm.DB) repository.AccountRepository <span class="cov8" title="1">{
        return &amp;accountRepository{db: db}
}</span>

func (r *accountRepository) Get(id uuid.UUID) (*domain.Account, error) <span class="cov8" title="1">{
        var a domain.Account
        result := r.db.First(&amp;a, id)
        if result.Error != nil </span><span class="cov8" title="1">{
                return nil, result.Error
        }</span>
        <span class="cov8" title="1">return domain.NewAccountFromData(a.ID, a.UserID, a.Balance, a.Currency, a.CreatedAt, a.UpdatedAt), nil</span>
}

func (r *accountRepository) Create(a *domain.Account) error <span class="cov0" title="0">{
        result := r.db.Create(a)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *accountRepository) Update(a *domain.Account) error <span class="cov0" title="0">{
        // Use infra.Account for DB operations
        dbModel := Account{
                Model: gorm.Model{
                        CreatedAt: a.CreatedAt,
                        DeletedAt: gorm.DeletedAt{},
                        UpdatedAt: time.Now().UTC(),
                },
                ID:       a.ID,
                UserID:   a.UserID,
                Balance:  a.Balance,
                Currency: a.Currency,
        }
        result := r.db.Save(&amp;dbModel)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *accountRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.Delete(&amp;Account{}, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type transactionRepository struct {
        db *gorm.DB
}

func NewTransactionRepository(db *gorm.DB) repository.TransactionRepository <span class="cov8" title="1">{
        return &amp;transactionRepository{db: db}
}</span>

func (r *transactionRepository) Create(transaction *domain.Transaction) error <span class="cov8" title="1">{
        // Convert domain transaction to GORM model
        dbTransaction := Transaction{
                Model: gorm.Model{
                        CreatedAt: transaction.CreatedAt,
                        UpdatedAt: transaction.CreatedAt,
                },
                ID:               transaction.ID,
                AccountID:        transaction.AccountID,
                UserID:           transaction.UserID,
                Amount:           transaction.Amount,
                Currency:         transaction.Currency,
                Balance:          transaction.Balance,
                OriginalAmount:   transaction.OriginalAmount,
                OriginalCurrency: transaction.OriginalCurrency,
                ConversionRate:   transaction.ConversionRate,
        }

        result := r.db.Create(&amp;dbTransaction)
        if result.Error != nil </span><span class="cov8" title="1">{
                return result.Error
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *transactionRepository) Get(id uuid.UUID) (*domain.Transaction, error) <span class="cov0" title="0">{
        var t Transaction
        result := r.db.First(&amp;t, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return domain.NewTransactionFromData(t.ID, t.UserID, t.AccountID, t.Amount, t.Balance, t.Currency, t.CreatedAt, t.OriginalAmount, t.OriginalCurrency, t.ConversionRate), nil</span>
}

func (r *transactionRepository) List(userID, accountID uuid.UUID) ([]*domain.Transaction, error) <span class="cov0" title="0">{
        var dbTransactions []*Transaction
        result := r.db.Where("account_id = ? and user_id = ?", accountID, userID).Order("created_at desc").Limit(100).Find(&amp;dbTransactions)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">tx := make([]*domain.Transaction, 0, len(dbTransactions))
        for _, t := range dbTransactions </span><span class="cov0" title="0">{
                tx = append(tx, domain.NewTransactionFromData(t.ID, t.UserID, t.AccountID, t.Amount, t.Balance, t.Currency, t.CreatedAt, t.OriginalAmount, t.OriginalCurrency, t.ConversionRate))
        }</span>
        <span class="cov0" title="0">return tx, nil</span>
}

type userRepository struct {
        db *gorm.DB
}

// Valid implements repository.UserRepository.
func (u *userRepository) Valid(id uuid.UUID, password string) bool <span class="cov0" title="0">{
        var user domain.User
        result := u.db.Where("id = ? AND password = ?", id, password).First(&amp;user)
        return result.Error == nil
}</span>

// Create implements repository.UserRepository.
func (u *userRepository) Create(user *domain.User) error <span class="cov8" title="1">{
        result := u.db.Create(user)
        if result.Error != nil </span><span class="cov8" title="1">{
                return result.Error
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Delete implements repository.UserRepository.
func (u *userRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        result := u.db.Delete(&amp;domain.User{}, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Get implements repository.UserRepository.
func (u *userRepository) Get(id uuid.UUID) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        result := u.db.First(&amp;user, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetByEmail implements repository.UserRepository.
func (u *userRepository) GetByEmail(email string) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        result := u.db.Where("email = ?", email).First(&amp;user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetByUsername implements repository.UserRepository.
func (u *userRepository) GetByUsername(username string) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        result := u.db.Where("username = ?", username).First(&amp;user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// Update implements repository.UserRepository.
func (u *userRepository) Update(user *domain.User) error <span class="cov0" title="0">{
        result := u.db.Save(user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func NewUserRepository(db *gorm.DB) repository.UserRepository <span class="cov0" title="0">{
        return &amp;userRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package infra

import (
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/repository"
        "gorm.io/gorm"
)

type UoW struct {
        session *gorm.DB
        started bool
}

func NewGormUoW(dbConn *gorm.DB) (*UoW, error) <span class="cov8" title="1">{

        return &amp;UoW{
                session: dbConn,
                started: false,
        }, nil
}</span>
func (u *UoW) Begin() error <span class="cov8" title="1">{
        slog.Info("UoW Begin()")
        if u.session == nil </span><span class="cov0" title="0">{
                slog.Error("Session is nil, cannot start transaction")
                return fmt.Errorf("session is nil")
        }</span>
        <span class="cov8" title="1">if u.started </span><span class="cov8" title="1">{
                slog.Info("Transaction already started")
                return nil // Transaction already started
        }</span>
        <span class="cov8" title="1">slog.Info("Starting new transaction")
        tx := u.session.Begin()
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()
        <span class="cov8" title="1">if tx.Error != nil </span><span class="cov8" title="1">{
                slog.Error("Failed to start transaction", slog.Any("error", tx.Error))
                return tx.Error
        }</span>
        <span class="cov8" title="1">slog.Info("Transaction started successfully")
        u.session = tx
        u.started = true
        return nil</span>
}
func (u *UoW) Commit() error <span class="cov8" title="1">{
        slog.Info("UoW Commit()")
        if !u.started </span><span class="cov8" title="1">{
                slog.Info("Transaction not started, nothing to commit")
                return nil // No transaction to commit
        }</span>
        <span class="cov8" title="1">err := u.session.Commit().Error
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Failed to commit transaction", slog.Any("error", err))
        }</span> else<span class="cov8" title="1"> {
                u.started = true
                slog.Info("Transaction committed successfully")
        }</span>
        <span class="cov8" title="1">return err</span>
}
func (u *UoW) Rollback() error <span class="cov8" title="1">{
        slog.Info("UoW Rollback()")
        if !u.started </span><span class="cov8" title="1">{
                slog.Info("Transaction not started, nothing to rollback")
                return nil // No transaction to rollback
        }</span>
        <span class="cov8" title="1">err := u.session.Rollback().Error
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to rollback transaction", slog.Any("error", err))
        }</span> else<span class="cov8" title="1"> {
                u.started = false
                slog.Info("Transaction rolled back successfully")
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (u *UoW) AccountRepository() repository.AccountRepository <span class="cov8" title="1">{
        if !u.started </span><span class="cov8" title="1">{
                db, _ := NewDBConnection()
                return NewAccountRepository(db)
        }</span>
        <span class="cov0" title="0">return NewAccountRepository(u.session)</span>
}
func (u *UoW) TransactionRepository() repository.TransactionRepository <span class="cov8" title="1">{
        if !u.started </span><span class="cov8" title="1">{
                db, _ := NewDBConnection()
                return NewTransactionRepository(db)
        }</span>
        <span class="cov0" title="0">return NewTransactionRepository(u.session)</span>
}

func (u *UoW) UserRepository() repository.UserRepository <span class="cov0" title="0">{
        if !u.started </span><span class="cov0" title="0">{
                db, _ := NewDBConnection()
                return NewUserRepository(db)
        }</span>
        <span class="cov0" title="0">return NewUserRepository(u.session)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package domain

import (
        "errors"
        "fmt"
        "math"
        "math/big"
        "sync"
        "time"

        "github.com/google/uuid"
)

var (
        ErrDepositAmountExceedsMaxSafeInt  = errors.New("deposit amount exceeds maximum safe integer value")
        ErrTransactionAmountMustBePositive = errors.New("transaction amount must be positive")
        ErrWithdrawalAmountMustBePositive  = errors.New("withdrawal amount must be positive")
        ErrInsufficientFunds               = errors.New("insufficient funds for withdrawal")
        ErrAccountNotFound                 = errors.New("account not found")
        ErrUserUnauthorized                = errors.New("user unauthorized")
        ErrInvalidCurrencyCode             = errors.New("invalid currency code")
)

// CurrencyMeta holds metadata for a currency, such as decimals and symbol.
type CurrencyMeta struct {
        Decimals int
        Symbol   string
}

const (
        DefaultCurrency = "USD"
        DefaultDecimals = 2
)

// CurrencyInfo maps ISO 4217 currency codes to their metadata.
var CurrencyInfo = map[string]CurrencyMeta{
        "USD": {Decimals: DefaultDecimals, Symbol: "$"},
        "EUR": {Decimals: DefaultDecimals, Symbol: ""},
        "JPY": {Decimals: 0, Symbol: ""},
        "KWD": {Decimals: 3, Symbol: "."},
        "EGP": {Decimals: DefaultDecimals, Symbol: ""},
        // Add more as needed
}

// ConversionInfo holds details about a currency conversion performed during a transaction.
type ConversionInfo struct {
        OriginalAmount    float64
        OriginalCurrency  string
        ConvertedAmount   float64
        ConvertedCurrency string
        ConversionRate    float64
}

// Account represents a user's financial account, supporting multi-currency.
type Account struct {
        ID        uuid.UUID
        UserID    uuid.UUID
        Balance   int64 // Account balance snapshot
        UpdatedAt time.Time
        CreatedAt time.Time
        Currency  string // ISO 4217 currency code
        mu        sync.Mutex
}

// Transaction represents a financial transaction, supporting multi-currency.
type Transaction struct {
        ID        uuid.UUID
        UserID    uuid.UUID
        AccountID uuid.UUID
        Amount    int64
        Balance   int64 // Account balance snapshot
        CreatedAt time.Time
        Currency  string // ISO 4217 currency code

        // Conversion fields (nullable when no conversion occurs)
        OriginalAmount   *float64 // Amount in original currency
        OriginalCurrency *string  // Original currency code
        ConversionRate   *float64 // Rate used for conversion
}

// iso4217 is a minimal set of supported ISO 4217 currency codes.
var iso4217 = map[string]struct{}{
        "USD": {},
        "EUR": {},
        "GBP": {},
        // Add more as needed
}

// IsValidCurrencyCode returns true if the code is a supported ISO 4217 currency code.
func IsValidCurrencyCode(code string) bool <span class="cov8" title="1">{
        _, ok := iso4217[code]
        return ok
}</span>

// NewAccount creates a new account with default currency USD.
func NewAccount(userID uuid.UUID) *Account <span class="cov8" title="1">{
        return NewAccountWithCurrency(userID, "USD")
}</span>

// NewAccountWithCurrency creates a new account with the specified currency.
// If the currency is invalid or empty, defaults to USD.
func NewAccountWithCurrency(userID uuid.UUID, currency string) *Account <span class="cov8" title="1">{
        if !IsValidCurrencyCode(currency) </span><span class="cov0" title="0">{
                currency = DefaultCurrency
        }</span>
        <span class="cov8" title="1">return &amp;Account{
                ID:        uuid.New(),
                UserID:    userID,
                CreatedAt: time.Now(),
                Balance:   0,
                Currency:  currency,
                mu:        sync.Mutex{},
        }</span>
}

func NewAccountFromData(
        id, userID uuid.UUID,
        balance int64,
        currency string,
        created, updated time.Time,
) *Account <span class="cov0" title="0">{
        return &amp;Account{
                ID:        id,
                UserID:    userID,
                Balance:   balance,
                Currency:  currency,
                CreatedAt: created,
                UpdatedAt: updated,
                mu:        sync.Mutex{},
        }
}</span>

func NewTransactionFromData(
        id, userID, accountID uuid.UUID,
        amount, balance int64,
        currency string,
        created time.Time,
        originalAmount *float64,
        originalCurrency *string,
        conversionRate *float64,
) *Transaction <span class="cov8" title="1">{
        return &amp;Transaction{
                ID:               id,
                UserID:           userID,
                AccountID:        accountID,
                Amount:           amount,
                Balance:          balance,
                Currency:         currency,
                CreatedAt:        created,
                OriginalAmount:   originalAmount,
                OriginalCurrency: originalCurrency,
                ConversionRate:   conversionRate,
        }
}</span>

// NewTransactionWithCurrency creates a new transaction with the specified currency.
// If the currency is invalid or empty, defaults to USD.
func NewTransactionWithCurrency(id, userID, accountID uuid.UUID, amount, balance int64, currency string) *Transaction <span class="cov8" title="1">{
        if !IsValidCurrencyCode(currency) </span><span class="cov0" title="0">{
                currency = DefaultCurrency
        }</span>
        <span class="cov8" title="1">return &amp;Transaction{
                ID:               id,
                UserID:           userID,
                AccountID:        accountID,
                Amount:           amount,
                Balance:          balance,
                CreatedAt:        time.Now(),
                Currency:         currency,
                OriginalAmount:   nil,
                OriginalCurrency: nil,
                ConversionRate:   nil,
        }</span>
}

// Deposit adds funds to the account if the currency matches and returns a transaction record.
// Returns an error if the currency does not match or the deposit amount is invalid.
func (a *Account) Deposit(userID uuid.UUID, money Money) (*Transaction, error) <span class="cov8" title="1">{
        if a.UserID != userID </span><span class="cov8" title="1">{
                return nil, ErrUserUnauthorized
        }</span>
        <span class="cov8" title="1">a.mu.Lock()
        defer a.mu.Unlock()

        if money.Amount &lt;= 0 </span><span class="cov8" title="1">{
                return nil, ErrTransactionAmountMustBePositive
        }</span>

        <span class="cov8" title="1">amountStr := fmt.Sprintf("%.2f", money.Amount)
        amountRat, ok := new(big.Rat).SetString(amountStr)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid amount format")
        }</span>

        <span class="cov8" title="1">meta, ok := CurrencyInfo[money.Currency]
        if !ok </span><span class="cov0" title="0">{
                meta.Decimals = 2 // default
        }</span>
        <span class="cov8" title="1">multiplier := math.Pow10(meta.Decimals)
        centsRat := new(big.Rat).Mul(amountRat, big.NewRat(int64(multiplier), 1))

        if !centsRat.IsInt() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("amount has more than %d decimal places", meta.Decimals)
        }</span>

        <span class="cov8" title="1">cents := centsRat.Num()

        if cents.Sign() &lt;= 0 </span><span class="cov0" title="0">{
                return nil, ErrTransactionAmountMustBePositive
        }</span>

        <span class="cov8" title="1">max := big.NewInt(math.MaxInt64)
        balanceBig := big.NewInt(a.Balance)
        newBalance := new(big.Int).Add(balanceBig, cents)

        if newBalance.Cmp(max) &gt; 0 </span><span class="cov8" title="1">{
                return nil, ErrDepositAmountExceedsMaxSafeInt
        }</span>

        <span class="cov8" title="1">parsedAmount := cents.Int64()
        a.Balance += parsedAmount

        transaction := Transaction{
                ID:        uuid.New(),
                UserID:    userID,
                AccountID: a.ID,
                Amount:    parsedAmount,
                Balance:   a.Balance,
                CreatedAt: time.Now().UTC(),
                Currency:  money.Currency,
        }

        return &amp;transaction, nil</span>
}

// Withdraw removes funds from the account if the currency matches and returns a transaction record.
// Returns an error if the currency does not match or if there are insufficient funds.
func (a *Account) Withdraw(userID uuid.UUID, money Money) (*Transaction, error) <span class="cov8" title="1">{
        if a.UserID != userID </span><span class="cov8" title="1">{
                return nil, ErrUserUnauthorized
        }</span>
        <span class="cov8" title="1">a.mu.Lock()
        defer a.mu.Unlock()

        if money.Amount &lt;= 0 </span><span class="cov8" title="1">{
                return nil, ErrWithdrawalAmountMustBePositive
        }</span>

        <span class="cov8" title="1">meta, ok := CurrencyInfo[money.Currency]
        if !ok </span><span class="cov0" title="0">{
                meta.Decimals = DefaultDecimals
        }</span>
        <span class="cov8" title="1">multiplier := math.Pow10(meta.Decimals)
        cents := int64(math.Round(money.Amount * multiplier))

        if cents &gt; a.Balance </span><span class="cov8" title="1">{
                return nil, ErrInsufficientFunds
        }</span>
        <span class="cov8" title="1">a.Balance -= cents

        transaction := Transaction{
                ID:        uuid.New(),
                UserID:    userID,
                AccountID: a.ID,
                Amount:    -cents,
                Balance:   a.Balance,
                CreatedAt: time.Now().UTC(),
                Currency:  money.Currency,
        }

        return &amp;transaction, nil</span>
}

// GetBalance returns the current balance of the account in dollars.
// It converts the balance from cents to dollars for display purposes.
func (a *Account) GetBalance(userID uuid.UUID) (balance float64, err error) <span class="cov8" title="1">{
        if a.UserID != userID </span><span class="cov8" title="1">{
                err = ErrUserUnauthorized
                return
        }</span>
        <span class="cov8" title="1">meta, ok := CurrencyInfo[a.Currency]
        if !ok </span><span class="cov0" title="0">{
                meta.Decimals = DefaultDecimals
        }</span>
        <span class="cov8" title="1">divisor := math.Pow10(meta.Decimals)
        balance = float64(a.Balance) / divisor
        return</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package domain

import (
        "errors"
        "time"
)

var (
        ErrExchangeRateUnavailable = errors.New("exchange rate service unavailable")
        ErrUnsupportedCurrencyPair = errors.New("unsupported currency pair")
        ErrExchangeRateExpired     = errors.New("exchange rate has expired")
        ErrExchangeRateInvalid     = errors.New("invalid exchange rate received")
)

// CurrencyConverter defines the interface for converting amounts between currencies.
type CurrencyConverter interface {
        // Convert converts an amount from one currency to another.
        // Returns the converted amount and the rate used, or an error if conversion is not possible.
        Convert(amount float64, from, to string) (*ConversionInfo, error)

        // GetRate returns the current exchange rate between two currencies.
        // This is useful for displaying rates without performing a conversion.
        GetRate(from, to string) (float64, error)

        // IsSupported checks if a currency pair is supported by the converter.
        IsSupported(from, to string) bool
}

// ExchangeRate represents a single exchange rate with metadata.
type ExchangeRate struct {
        FromCurrency string
        ToCurrency   string
        Rate         float64
        LastUpdated  time.Time
        Source       string
        ExpiresAt    time.Time
}

// ExchangeRateProvider defines the interface for external exchange rate providers.
type ExchangeRateProvider interface {
        // GetRate fetches the current exchange rate for a currency pair.
        GetRate(from, to string) (*ExchangeRate, error)

        // GetRates fetches multiple exchange rates in a single request.
        GetRates(from string, to []string) (map[string]*ExchangeRate, error)

        // Name returns the provider's name for logging and identification.
        Name() string

        // IsHealthy checks if the provider is currently available.
        IsHealthy() bool
}

// StubCurrencyConverter is a simple implementation that returns the same amount (1:1 conversion).
type StubCurrencyConverter struct {
        rates map[string]map[string]float64
}

// NewStubCurrencyConverter creates a new StubCurrencyConverter with an empty rates map.
func NewStubCurrencyConverter() *StubCurrencyConverter <span class="cov0" title="0">{
        return &amp;StubCurrencyConverter{rates: map[string]map[string]float64{
                "USD": {
                        "EUR": 0.84,
                        "GBP": 0.76,
                        "JPY": 0.0027,
                },
                "EUR": {
                        "USD": 1.19,
                        "GBP": 0.90,
                        "JPY": 0.0024,
                },
                "GBP": {
                        "USD": 1.32,
                        "EUR": 1.11,
                        "JPY": 0.0024,
                },
                "JPY": {
                        "USD": 0.0027,
                        "EUR": 0.0024,
                        "GBP": 0.0024,
                },
        }}
}</span>

func (s *StubCurrencyConverter) Convert(amount float64, from, to string) (*ConversionInfo, error) <span class="cov0" title="0">{
        rate, exists := s.rates[from][to]
        if !exists </span><span class="cov0" title="0">{
                return nil, ErrUnsupportedCurrencyPair
        }</span>
        <span class="cov0" title="0">return &amp;ConversionInfo{
                OriginalAmount:    amount,
                OriginalCurrency:  from,
                ConvertedAmount:   amount * rate,
                ConvertedCurrency: to,
                ConversionRate:    rate,
        }, nil</span>
}

func (s *StubCurrencyConverter) GetRate(from, to string) (float64, error) <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return 1.0, nil
        }</span>
        <span class="cov0" title="0">rate, exists := s.rates[from][to]
        if !exists </span><span class="cov0" title="0">{
                return 0, ErrUnsupportedCurrencyPair
        }</span>
        <span class="cov0" title="0">return rate, nil</span>
}

func (s *StubCurrencyConverter) IsSupported(from, to string) bool <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">_, exists := s.rates[from][to]
        return exists</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package domain

// Money represents a monetary amount with a currency.
type Money struct {
        Amount   float64
        Currency string
}

// NewMoney creates a new Money value object, validating the currency and amount.
func NewMoney(
        amount float64,
        currency string,
) (
        money Money,
        err error,
) <span class="cov0" title="0">{
        if currency == "" </span><span class="cov0" title="0">{
                currency = DefaultCurrency
        }</span>
        <span class="cov0" title="0">if !IsValidCurrencyCode(currency) </span><span class="cov0" title="0">{
                err = ErrInvalidCurrencyCode
                return
        }</span>
        <span class="cov0" title="0">money = Money{Amount: amount, Currency: currency}
        return</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package domain

import (
        "errors"
        "time"

        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

var ErrUserNotFound = errors.New("user not found")

type User struct {
        ID        uuid.UUID `json:"id"`
        Username  string    `json:"username"`
        Email     string    `json:"email"`
        Password  string    `json:"password"`
        CreatedAt time.Time `json:"created"`
        UpdatedAt time.Time `json:"updated"`
}

func hashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>
func NewUser(
        username, email, password string,
) (*User, error) <span class="cov0" title="0">{
        hashedPassword, err := hashPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;User{
                ID:        uuid.New(),
                Username:  username,
                Email:     email,
                Password:  hashedPassword,
                CreatedAt: time.Now().UTC(),
                UpdatedAt: time.Now().UTC(),
        }, nil</span>
}

func NewUserFromData(
        id uuid.UUID,
        username, email, password string,
        created, updated time.Time,
) *User <span class="cov8" title="1">{
        return &amp;User{
                ID:        id,
                Username:  username,
                Email:     email,
                Password:  password,
                CreatedAt: created,
                UpdatedAt: updated,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "os"

        jwtware "github.com/gofiber/contrib/jwt"
        "github.com/gofiber/fiber/v2"
)

// Protected protect routes
func Protected() fiber.Handler <span class="cov8" title="1">{
        return jwtware.New(jwtware.Config{
                SigningKey:   jwtware.SigningKey{Key: []byte(os.Getenv("JWT_SECRET_KEY"))},
                ErrorHandler: jwtError,
        })
}</span>

func jwtError(c *fiber.Ctx, err error) error <span class="cov8" title="1">{
        if err.Error() == "Missing or malformed JWT" </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusBadRequest).
                        JSON(fiber.Map{"status": "error", "message": "Missing or malformed JWT", "data": nil})
        }</span>
        <span class="cov8" title="1">return c.Status(fiber.StatusUnauthorized).
                JSON(fiber.Map{"status": "error", "message": "Invalid or expired JWT", "data": nil})</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package service provides business logic for interacting with domain entities such as accounts and transactions.
// It defines the AccountService struct and its methods for creating accounts, depositing and withdrawing funds,
// retrieving account details, listing transactions, and checking account balances.
package service

import (
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/repository"

        "github.com/google/uuid"
)

// AccountService provides methods to interact with accounts and transactions using a unit of work pattern.
type AccountService struct {
        uowFactory func() (repository.UnitOfWork, error)
        converter  domain.CurrencyConverter
}

// NewAccountService creates a new AccountService with the given UnitOfWork factory and CurrencyConverter.
func NewAccountService(uowFactory func() (repository.UnitOfWork, error), converter domain.CurrencyConverter) *AccountService <span class="cov8" title="1">{
        return &amp;AccountService{
                uowFactory: uowFactory,
                converter:  converter,
        }
}</span>

// CreateAccount creates a new account and persists it using the repository.
// Returns the created account or an error if the operation fails.
func (s *AccountService) CreateAccount(
        userID uuid.UUID,
) (a *domain.Account, err error) <span class="cov8" title="1">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov8" title="1">{
                a = nil
                return
        }</span>
        <span class="cov8" title="1">err = uow.Begin()
        if err != nil </span><span class="cov0" title="0">{
                a = nil
                return
        }</span>

        <span class="cov8" title="1">a = domain.NewAccount(userID)
        err = uow.AccountRepository().Create(a)
        if err != nil </span><span class="cov8" title="1">{
                _ = uow.Rollback()
                a = nil
                return
        }</span>

        <span class="cov8" title="1">err = uow.Commit()
        if err != nil </span><span class="cov8" title="1">{
                _ = uow.Rollback()
                a = nil
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func (s *AccountService) CreateAccountWithCurrency(
        userID uuid.UUID,
        currency string) (account *domain.Account, err error) <span class="cov0" title="0">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov0" title="0">{
                account = nil
                return
        }</span>
        <span class="cov0" title="0">err = uow.Begin()
        if err != nil </span><span class="cov0" title="0">{
                account = nil
                return
        }</span>

        <span class="cov0" title="0">account = domain.NewAccountWithCurrency(userID, currency)
        err = uow.AccountRepository().Create(account)
        if err != nil </span><span class="cov0" title="0">{
                _ = uow.Rollback()
                account = nil
                return
        }</span>

        <span class="cov0" title="0">err = uow.Commit()
        if err != nil </span><span class="cov0" title="0">{
                _ = uow.Rollback()
                account = nil
                return
        }</span>
        <span class="cov0" title="0">return</span>
}

// Deposit adds funds to the specified account and creates a transaction record.
// Returns the transaction or an error if the operation fails.
func (s *AccountService) Deposit(
        userID, accountID uuid.UUID,
        amount float64,
        currency string,
) (tx *domain.Transaction, convInfo *domain.ConversionInfo, err error) <span class="cov8" title="1">{
        money, err := domain.NewMoney(amount, currency)
        if err != nil </span><span class="cov0" title="0">{
                tx = nil
                return
        }</span>
        <span class="cov8" title="1">uow, err := s.uowFactory()
        if err != nil </span><span class="cov8" title="1">{
                tx = nil
                return
        }</span>
        <span class="cov8" title="1">err = uow.Begin()
        if err != nil </span><span class="cov0" title="0">{
                tx = nil
                return
        }</span>

        <span class="cov8" title="1">a, err := uow.AccountRepository().Get(accountID)
        if err != nil </span><span class="cov8" title="1">{
                _ = uow.Rollback()
                tx = nil
                err = domain.ErrAccountNotFound
                return
        }</span>

        <span class="cov8" title="1">if money.Currency != a.Currency </span><span class="cov8" title="1">{
                convInfo, err = s.converter.Convert(money.Amount, money.Currency, a.Currency)
                if err != nil </span><span class="cov0" title="0">{
                        _ = uow.Rollback()
                        tx = nil
                        return
                }</span>
                <span class="cov8" title="1">money, err = domain.NewMoney(convInfo.ConvertedAmount, a.Currency)
                if err != nil </span><span class="cov0" title="0">{
                        _ = uow.Rollback()
                        tx = nil
                        return
                }</span>
        }

        <span class="cov8" title="1">tx, err = a.Deposit(userID, money)
        if err != nil </span><span class="cov8" title="1">{
                _ = uow.Rollback()
                tx = nil
                return
        }</span>

        // Store conversion info in transaction if conversion occurred
        <span class="cov8" title="1">if convInfo != nil </span><span class="cov8" title="1">{
                tx.OriginalAmount = &amp;convInfo.OriginalAmount
                tx.OriginalCurrency = &amp;convInfo.OriginalCurrency
                tx.ConversionRate = &amp;convInfo.ConversionRate
        }</span>

        <span class="cov8" title="1">err = uow.AccountRepository().Update(a)
        if err != nil </span><span class="cov8" title="1">{
                _ = uow.Rollback()
                tx = nil
                return
        }</span>

        <span class="cov8" title="1">err = uow.TransactionRepository().Create(tx)
        if err != nil </span><span class="cov0" title="0">{
                _ = uow.Rollback()
                tx = nil
                return
        }</span>

        <span class="cov8" title="1">err = uow.Commit()
        if err != nil </span><span class="cov0" title="0">{
                _ = uow.Rollback()
                tx = nil
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

// Withdraw removes funds from the specified account and creates a transaction record.
// Returns the transaction, conversion info (if any), and error if the operation fails.
func (s *AccountService) Withdraw(
        userID, accountID uuid.UUID,
        amount float64,
        currency string,
) (
        tx *domain.Transaction,
        convInfo *domain.ConversionInfo,
        err error,
) <span class="cov8" title="1">{
        money, err := domain.NewMoney(amount, currency)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">uow, err := s.uowFactory()
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">err = uow.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">a, err := uow.AccountRepository().Get(accountID)
        if err != nil </span><span class="cov0" title="0">{
                _ = uow.Rollback()
                return nil, nil, domain.ErrAccountNotFound
        }</span>

        <span class="cov8" title="1">if money.Currency != a.Currency </span><span class="cov8" title="1">{
                convInfo, err = s.converter.Convert(money.Amount, money.Currency, a.Currency)
                if err != nil </span><span class="cov0" title="0">{
                        _ = uow.Rollback()
                        return
                }</span>

                <span class="cov8" title="1">money, err = domain.NewMoney(convInfo.ConvertedAmount, a.Currency)
                if err != nil </span><span class="cov0" title="0">{
                        _ = uow.Rollback()
                        return nil, nil, err
                }</span>
        }

        <span class="cov8" title="1">tx, err = a.Withdraw(userID, money)
        if err != nil </span><span class="cov8" title="1">{
                _ = uow.Rollback()
                return nil, nil, err
        }</span>

        // Store conversion info in transaction if conversion occurred
        <span class="cov8" title="1">if convInfo != nil </span><span class="cov8" title="1">{
                tx.OriginalAmount = &amp;convInfo.OriginalAmount
                tx.OriginalCurrency = &amp;convInfo.OriginalCurrency
                tx.ConversionRate = &amp;convInfo.ConversionRate
        }</span>

        <span class="cov8" title="1">err = uow.AccountRepository().Update(a)
        if err != nil </span><span class="cov8" title="1">{
                _ = uow.Rollback()
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">err = uow.TransactionRepository().Create(tx)
        if err != nil </span><span class="cov0" title="0">{
                _ = uow.Rollback()
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">err = uow.Commit()
        if err != nil </span><span class="cov0" title="0">{
                _ = uow.Rollback()
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return tx, convInfo, nil</span>
}

// GetAccount retrieves an account by its ID.
// Returns the account or an error if not found.
func (s *AccountService) GetAccount(
        userID, accountID uuid.UUID,
) (a *domain.Account, err error) <span class="cov8" title="1">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov8" title="1">{
                a = nil
                return
        }</span>
        <span class="cov8" title="1">a, err = uow.AccountRepository().Get(accountID)
        if err != nil </span><span class="cov8" title="1">{
                a = nil
                err = domain.ErrAccountNotFound
                return
        }</span>
        <span class="cov8" title="1">if a.UserID != userID </span><span class="cov8" title="1">{
                a = nil
                err = domain.ErrUserUnauthorized
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetTransactions retrieves all transactions for a given account ID.
// Returns a slice of transactions or an error if the operation fails.
func (s *AccountService) GetTransactions(
        userID, accountID uuid.UUID,
) (txs []*domain.Transaction, err error) <span class="cov8" title="1">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov8" title="1">{
                txs = nil
                return
        }</span>
        <span class="cov8" title="1">txs, err = uow.TransactionRepository().List(userID, accountID)
        if err != nil </span><span class="cov8" title="1">{
                txs = nil
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

// GetBalance retrieves the current balance of the specified account.
// Returns the balance as a float64 or an error if the operation fails.
func (s *AccountService) GetBalance(
        userID, accountID uuid.UUID,
) (balance float64, err error) <span class="cov8" title="1">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a, err := uow.AccountRepository().Get(accountID)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">balance, err = a.GetBalance(userID)
        return</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package service

import (
        "context"
        "errors"
        "net/mail"
        "os"
        "time"

        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

type contextKey string

const userContextKey contextKey = "user"

type AuthStrategy interface {
        Login(identity, password string) (*domain.User, string, error)
        GetCurrentUserID(ctx context.Context) (uuid.UUID, error)
}

type AuthService struct {
        uowFactory func() (repository.UnitOfWork, error)
        strategy   AuthStrategy
}

func NewAuthService(
        uowFactory func() (repository.UnitOfWork, error),
        strategy AuthStrategy,
) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{uowFactory: uowFactory, strategy: strategy}
}</span>

func NewBasicAuthService(uowFactory func() (repository.UnitOfWork, error)) *AuthService <span class="cov0" title="0">{
        return NewAuthService(uowFactory, &amp;BasicAuthStrategy{uowFactory: uowFactory})
}</span>

func (s *AuthService) CheckPasswordHash(
        password, hash string,
) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>

func (s *AuthService) ValidEmail(email string) bool <span class="cov8" title="1">{
        _, err := mail.ParseAddress(email)
        return err == nil
}</span>

func (s *AuthService) GetCurrentUserId(
        token *jwt.Token,
) (userID uuid.UUID, err error) <span class="cov8" title="1">{
        userID, err = s.strategy.GetCurrentUserID(context.WithValue(context.TODO(), userContextKey, token))
        return
}</span>

func (s *AuthService) Login(
        identity, password string,
) (user *domain.User, token string, err error) <span class="cov8" title="1">{
        user, token, err = s.strategy.Login(identity, password)
        return
}</span>

// JWTAuthStrategy implements AuthStrategy for JWT-based authentication
type JWTAuthStrategy struct {
        uowFactory func() (repository.UnitOfWork, error)
}

func NewJWTAuthStrategy(
        uowFactory func() (repository.UnitOfWork, error),
) *JWTAuthStrategy <span class="cov0" title="0">{
        return &amp;JWTAuthStrategy{uowFactory: uowFactory}
}</span>

func (s *JWTAuthStrategy) Login(
        identity, password string,
) (
        user *domain.User,
        tokenString string,
        err error,
) <span class="cov0" title="0">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if isEmail(identity) </span><span class="cov0" title="0">{
                user, err = uow.UserRepository().GetByEmail(identity)
        }</span> else<span class="cov0" title="0"> {
                user, err = uow.UserRepository().GetByUsername(identity)
        }</span>
        <span class="cov0" title="0">const dummyHash = "$2a$10$7zFqzDbD3RrlkMTczbXG9OWZ0FLOXjIxXzSZ.QZxkVXjXcx7QZQiC"
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                checkPasswordHash(password, dummyHash)
                return
        }</span>
        <span class="cov0" title="0">if !checkPasswordHash(password, user.Password) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">secret := os.Getenv("JWT_SECRET_KEY")
        if secret == "" </span><span class="cov0" title="0">{
                err = errors.New("JWT secret key is not set")
                return
        }</span>
        <span class="cov0" title="0">token := jwt.New(jwt.SigningMethodHS256)
        claims := token.Claims.(jwt.MapClaims)
        claims["username"] = user.Username
        claims["email"] = user.Email
        claims["user_id"] = user.ID.String()
        claims["exp"] = time.Now().Add(time.Hour * 72).Unix()
        tokenString, err = token.SignedString([]byte(secret))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}

func (s *JWTAuthStrategy) GetCurrentUserID(
        ctx context.Context,
) (userID uuid.UUID, err error) <span class="cov8" title="1">{
        token := ctx.Value(userContextKey).(*jwt.Token)
        claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov8" title="1">{
                err = domain.ErrUserUnauthorized
                return
        }</span>
        <span class="cov8" title="1">userIDRaw, ok := claims["user_id"].(string)
        if !ok </span><span class="cov8" title="1">{
                err = domain.ErrUserUnauthorized
                return
        }</span>
        <span class="cov0" title="0">userID, err = uuid.Parse(userIDRaw)
        return</span>
}

// BasicAuthStrategy implements AuthStrategy for CLI (no JWT, just password check)
type BasicAuthStrategy struct {
        uowFactory func() (repository.UnitOfWork, error)
}

func (s *BasicAuthStrategy) Login(
        identity, password string,
) (
        user *domain.User,
        tokenString string,
        err error,
) <span class="cov0" title="0">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if isEmail(identity) </span><span class="cov0" title="0">{
                user, err = uow.UserRepository().GetByEmail(identity)
        }</span> else<span class="cov0" title="0"> {
                user, err = uow.UserRepository().GetByUsername(identity)
        }</span>
        <span class="cov0" title="0">const dummyHash = "$2a$10$7zFqzDbD3RrlkMTczbXG9OWZ0FLOXjIxXzSZ.QZxkVXjXcx7QZQiC"
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                checkPasswordHash(password, dummyHash)
                return
        }</span>
        <span class="cov0" title="0">if !checkPasswordHash(password, user.Password) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}

func (s *BasicAuthStrategy) GetCurrentUserID(ctx context.Context) (uuid.UUID, error) <span class="cov0" title="0">{
        return uuid.Nil, nil
}</span>

// Helper functions
func isEmail(
        email string,
) bool <span class="cov0" title="0">{
        _, err := mail.ParseAddress(email)
        return err == nil
}</span>

func checkPasswordHash(
        password, hash string,
) (isValid bool) <span class="cov0" title="0">{
        isValid = bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) == nil
        return
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package service

import (
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/repository"

        "github.com/google/uuid"
)

type UserService struct {
        uowFactory func() (repository.UnitOfWork, error)
}

func NewUserService(
        uowFactory func() (repository.UnitOfWork, error),
) *UserService <span class="cov8" title="1">{
        return &amp;UserService{
                uowFactory: uowFactory,
        }
}</span>

func (s *UserService) CreateUser(
        username, email, password string,
) (u *domain.User, err error) <span class="cov8" title="1">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov8" title="1">{
                u = nil
                return
        }</span>
        <span class="cov8" title="1">err = uow.Begin()
        if err != nil </span><span class="cov0" title="0">{
                u = nil
                return
        }</span>

        <span class="cov8" title="1">u, err = domain.NewUser(username, email, password)
        if err != nil </span><span class="cov0" title="0">{
                u = nil
                return
        }</span>
        <span class="cov8" title="1">err = uow.UserRepository().Create(u)
        if err != nil </span><span class="cov8" title="1">{
                _ = uow.Rollback()
                u = nil
                return
        }</span>

        <span class="cov8" title="1">err = uow.Commit()
        if err != nil </span><span class="cov8" title="1">{
                _ = uow.Rollback()
                u = nil
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func (s *UserService) GetUser(id uuid.UUID) (u *domain.User, err error) <span class="cov8" title="1">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov8" title="1">{
                u = nil
                return
        }</span>

        <span class="cov8" title="1">u, err = uow.UserRepository().Get(id)
        if err != nil </span><span class="cov8" title="1">{
                u = nil
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

func (s *UserService) GetUserByEmail(email string) (u *domain.User, err error) <span class="cov8" title="1">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov8" title="1">{
                u = nil
                return
        }</span>

        <span class="cov8" title="1">u, err = uow.UserRepository().GetByEmail(email)
        if err != nil </span><span class="cov8" title="1">{
                u = nil
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func (s *UserService) GetUserByUsername(username string) (u *domain.User, err error) <span class="cov8" title="1">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov8" title="1">{
                u = nil
                return
        }</span>

        <span class="cov8" title="1">u, err = uow.UserRepository().GetByUsername(username)
        if err != nil </span><span class="cov8" title="1">{
                u = nil
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func (s *UserService) UpdateUser(u *domain.User) (err error) <span class="cov8" title="1">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">err = uow.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">err = uow.UserRepository().Update(u)
        if err != nil </span><span class="cov8" title="1">{
                _ = uow.Rollback()
                return
        }</span>

        <span class="cov8" title="1">err = uow.Commit()
        if err != nil </span><span class="cov0" title="0">{
                _ = uow.Rollback()
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func (s *UserService) DeleteUser(id uuid.UUID) (err error) <span class="cov8" title="1">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">err = uow.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">err = uow.UserRepository().Delete(id)
        if err != nil </span><span class="cov8" title="1">{
                _ = uow.Rollback()
                return
        }</span>

        <span class="cov8" title="1">err = uow.Commit()
        if err != nil </span><span class="cov0" title="0">{
                _ = uow.Rollback()
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func (s *UserService) ValidUser(
        id uuid.UUID,
        password string,
) (isValid bool, err error) <span class="cov8" title="1">{
        uow, err := s.uowFactory()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">isValid = uow.UserRepository().Valid(id, password)
        return</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// AccountRoutes registers HTTP routes for account-related operations using the Fiber web framework.
// It sets up endpoints for creating accounts, depositing and withdrawing funds, retrieving account balances,
// and listing account transactions. All routes are protected by authentication middleware and require a valid user context.
//
//        @param app The Fiber application instance to register routes on.
//        @param accountSvc A pointer to the AccountService.
//        @param authSvc A pointer to the AuthService.
//
// Routes:
//   - POST   /account                   : Create a new account for the authenticated user.
//   - POST   /account/:id/deposit       : Deposit funds into the specified account.
//   - POST   /account/:id/withdraw      : Withdraw funds from the specified account.
//   - GET    /account/:id/balance       : Retrieve the balance of the specified account.
//   - GET    /account/:id/transactions  : List transactions for the specified account.

package webapi

import (
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/middleware"
        "github.com/amirasaad/fintech/pkg/service"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

type CreateAccountRequest struct {
        Currency string `json:"currency"`
}

type DepositRequest struct {
        Amount   float64 `json:"amount" xml:"amount" form:"amount"`
        Currency string  `json:"currency"`
}

type WithdrawRequest struct {
        Amount   float64 `json:"amount" xml:"amount" form:"amount"`
        Currency string  `json:"currency"`
}

// ConversionResponse wraps a transaction and conversion details if a currency conversion occurred.
type ConversionResponse struct {
        Transaction       *domain.Transaction `json:"transaction"`
        OriginalAmount    float64             `json:"original_amount,omitempty"`
        OriginalCurrency  string              `json:"original_currency,omitempty"`
        ConvertedAmount   float64             `json:"converted_amount,omitempty"`
        ConvertedCurrency string              `json:"converted_currency,omitempty"`
        ConversionRate    float64             `json:"conversion_rate,omitempty"`
}

// TransactionDTO is the API response representation of a transaction.
type TransactionDTO struct {
        ID        string  `json:"id"`
        UserID    string  `json:"user_id"`
        AccountID string  `json:"account_id"`
        Amount    float64 `json:"amount"`
        Balance   float64 `json:"balance"`
        CreatedAt string  `json:"created_at"`
        Currency  string  `json:"currency"`

        // Conversion fields (only present if conversion occurred)
        OriginalAmount   *float64 `json:"original_amount,omitempty"`
        OriginalCurrency *string  `json:"original_currency,omitempty"`
        ConversionRate   *float64 `json:"conversion_rate,omitempty"`
}

// ConversionResponseDTO wraps a transaction and conversion details for API responses.
type ConversionResponseDTO struct {
        Transaction       *TransactionDTO `json:"transaction"`
        OriginalAmount    float64         `json:"original_amount,omitempty"`
        OriginalCurrency  string          `json:"original_currency,omitempty"`
        ConvertedAmount   float64         `json:"converted_amount,omitempty"`
        ConvertedCurrency string          `json:"converted_currency,omitempty"`
        ConversionRate    float64         `json:"conversion_rate,omitempty"`
}

// ToTransactionDTO maps a domain.Transaction to a TransactionDTO.
func ToTransactionDTO(tx *domain.Transaction) *TransactionDTO <span class="cov8" title="1">{
        if tx == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">dto := &amp;TransactionDTO{
                ID:        tx.ID.String(),
                UserID:    tx.UserID.String(),
                AccountID: tx.AccountID.String(),
                Amount:    float64(tx.Amount) / 100.0, // assuming cents
                Balance:   float64(tx.Balance) / 100.0,
                CreatedAt: tx.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                Currency:  tx.Currency,
        }

        // Include conversion fields if they exist
        if tx.OriginalAmount != nil </span><span class="cov8" title="1">{
                dto.OriginalAmount = tx.OriginalAmount
        }</span>
        <span class="cov8" title="1">if tx.OriginalCurrency != nil </span><span class="cov8" title="1">{
                dto.OriginalCurrency = tx.OriginalCurrency
        }</span>
        <span class="cov8" title="1">if tx.ConversionRate != nil </span><span class="cov8" title="1">{
                dto.ConversionRate = tx.ConversionRate
        }</span>

        <span class="cov8" title="1">return dto</span>
}

// ToConversionResponseDTO maps a transaction and conversion info to a ConversionResponseDTO.
func ToConversionResponseDTO(tx *domain.Transaction, convInfo *domain.ConversionInfo) *ConversionResponseDTO <span class="cov8" title="1">{
        // If conversion info is provided (from service layer), use it
        if convInfo != nil </span><span class="cov8" title="1">{
                return &amp;ConversionResponseDTO{
                        Transaction:       ToTransactionDTO(tx),
                        OriginalAmount:    convInfo.OriginalAmount,
                        OriginalCurrency:  convInfo.OriginalCurrency,
                        ConvertedAmount:   convInfo.ConvertedAmount,
                        ConvertedCurrency: convInfo.ConvertedCurrency,
                        ConversionRate:    convInfo.ConversionRate,
                }
        }</span>

        // If no conversion info provided but transaction has stored conversion data, use that
        <span class="cov0" title="0">if tx.OriginalAmount != nil &amp;&amp; tx.OriginalCurrency != nil &amp;&amp; tx.ConversionRate != nil </span><span class="cov0" title="0">{
                return &amp;ConversionResponseDTO{
                        Transaction:       ToTransactionDTO(tx),
                        OriginalAmount:    *tx.OriginalAmount,
                        OriginalCurrency:  *tx.OriginalCurrency,
                        ConvertedAmount:   float64(tx.Amount) / 100.0, // Convert from cents
                        ConvertedCurrency: tx.Currency,
                        ConversionRate:    *tx.ConversionRate,
                }
        }</span>

        // No conversion occurred
        <span class="cov0" title="0">return nil</span>
}

func AccountRoutes(app *fiber.App, accountSvc *service.AccountService, authSvc *service.AuthService) <span class="cov8" title="1">{
        app.Post("/account", middleware.Protected(), CreateAccount(accountSvc, authSvc))
        app.Post("/account/:id/deposit", middleware.Protected(), Deposit(accountSvc, authSvc))
        app.Post("/account/:id/withdraw", middleware.Protected(), Withdraw(accountSvc, authSvc))
        app.Get("/account/:id/balance", middleware.Protected(), GetBalance(accountSvc, authSvc))
        app.Get("/account/:id/transactions", middleware.Protected(), GetTransactions(accountSvc, authSvc))
}</span>

// CreateAccount returns a Fiber handler for creating a new account for the current user.
// It extracts the user ID from the request context, initializes the account service using the provided
// UnitOfWork factory, and attempts to create a new account. On success, it returns the created account as JSON.
// On failure, it logs the error and returns an appropriate error response.
// @Summary Create a new account
// @Description Create a new account for the authenticated user
// @Tags accounts
// @Accept json
// @Produce json
// @Success 201 {object} Response
// @Failure 400 {object} ProblemDetails
// @Failure 401 {object} ProblemDetails
// @Failure 429 {object} ProblemDetails
// @Failure 500 {object} ProblemDetails
// @Router /account [post]
// @Security Bearer
func CreateAccount(
        accountSvc *service.AccountService,
        authSvc *service.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                log.Infof("Creating new account")
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusUnauthorized, "unauthorized", "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        status := ErrorToStatusCode(err)
                        return ErrorResponseJSON(c, status, "invalid user ID", err.Error())
                }</span>
                <span class="cov8" title="1">var req CreateAccountRequest
                _ = c.BodyParser(&amp;req)
                currency := req.Currency
                if currency == "" </span><span class="cov8" title="1">{
                        currency = "USD"
                }</span>
                <span class="cov8" title="1">a, err := accountSvc.CreateAccountWithCurrency(userID, currency)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("Failed to create account: %v", err)
                        status := ErrorToStatusCode(err)
                        return ErrorResponseJSON(c, status, "Failed to create account", err.Error())
                }</span>
                <span class="cov8" title="1">log.Infof("Account created: %+v", a)
                return c.Status(fiber.StatusCreated).JSON(Response{Status: fiber.StatusCreated, Message: "Account created", Data: a})</span>
        }
}

// Deposit returns a Fiber handler for depositing an amount into a user's account.
// It expects a UnitOfWork factory function as a dependency for transactional operations.
// The handler parses the current user ID from the request context, validates the account ID from the URL,
// and parses the deposit amount from the request body. If successful, it performs the deposit operation
// using the AccountService and returns the transaction as JSON. On error, it logs the issue and returns
// an appropriate JSON error response.
// @Summary Deposit funds into an account
// @Description Deposit a specified amount into the user's account
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Param request body DepositRequest true "Deposit request with amount"
// @Success 200 {object} Response
// @Failure 400 {object} ProblemDetails
// @Failure 401 {object} ProblemDetails
// @Failure 429 {object} ProblemDetails
// @Failure 500 {object} ProblemDetails
// @Router /account/{id}/deposit [post]
// @Security Bearer
func Deposit(
        accountSvc *service.AccountService,
        authSvc *service.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusUnauthorized, "unauthorized", "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        status := ErrorToStatusCode(err)
                        return ErrorResponseJSON(c, status, "invalid user ID", err.Error())
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("Invalid account ID for deposit: %v", err)
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Invalid account ID", err.Error())
                }</span>
                <span class="cov8" title="1">var request DepositRequest

                err = c.BodyParser(&amp;request)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("Failed to parse deposit request: %v", err)
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Failed to parse deposit request", err.Error())
                }</span>

                // Call service and get conversion info
                <span class="cov8" title="1">tx, convInfo, err := accountSvc.Deposit(userID, id, request.Amount, request.Currency)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("Failed to deposit: %v", err)
                        status := ErrorToStatusCode(err)
                        return ErrorResponseJSON(c, status, "Failed to deposit", err.Error())
                }</span>

                <span class="cov8" title="1">if convInfo != nil </span><span class="cov8" title="1">{
                        resp := ToConversionResponseDTO(tx, convInfo)
                        return c.JSON(Response{Status: fiber.StatusOK, Message: "Deposit successful (converted)", Data: resp})
                }</span>
                <span class="cov8" title="1">return c.JSON(Response{Status: fiber.StatusOK, Message: "Deposit successful", Data: ToTransactionDTO(tx)})</span>
        }
}

// Withdraw returns a Fiber handler for processing account withdrawal requests.
// It expects a UnitOfWork factory function as a dependency for transactional operations.
//
// The handler performs the following steps:
//  1. Retrieves the current user ID from the request context.
//  2. Parses the account ID from the route parameters.
//  3. Parses the withdrawal amount from the request body.
//  4. Calls the AccountService.Withdraw method to process the withdrawal.
//  5. Returns the transaction details as a JSON response on success.
//
// Error responses are returned in JSON format with appropriate status codes
// if any step fails (e.g., invalid user ID, invalid account ID, parsing errors, or withdrawal errors).
// @Summary Withdraw funds from an account
// @Description Withdraw a specified amount from the user's account
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Param request body WithdrawRequest true "Withdrawal request with amount"
// @Success 200 {object} Response
// @Failure 400 {object} ProblemDetails
// @Failure 401 {object} ProblemDetails
// @Failure 429 {object} ProblemDetails
// @Failure 500 {object} ProblemDetails
// @Router /account/{id}/withdraw [post]
// @Security Bearer
func Withdraw(
        accountSvc *service.AccountService,
        authSvc *service.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusUnauthorized, "unauthorized", "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        status := ErrorToStatusCode(err)
                        return ErrorResponseJSON(c, status, "invalid user ID", err.Error())
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("Invalid account ID for withdrawal: %v", err)
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Invalid account ID", err.Error())
                }</span>
                <span class="cov8" title="1">var request WithdrawRequest
                err = c.BodyParser(&amp;request)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("Failed to parse withdrawal request: %v", err)
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Failed to parse withdrawal request", err.Error())
                }</span>
                <span class="cov8" title="1">if request.Currency == "" </span><span class="cov8" title="1">{
                        request.Currency = "USD"
                }</span>

                // Call service and get conversion info
                <span class="cov8" title="1">tx, convInfo, err := accountSvc.Withdraw(userID, id, request.Amount, request.Currency)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("Failed to withdraw: %v", err)
                        status := ErrorToStatusCode(err)
                        return ErrorResponseJSON(c, status, "Failed to withdraw", err.Error())
                }</span>

                <span class="cov8" title="1">if convInfo != nil </span><span class="cov0" title="0">{
                        resp := ToConversionResponseDTO(tx, convInfo)
                        return c.JSON(Response{Status: fiber.StatusOK, Message: "Withdrawal successful (converted)", Data: resp})
                }</span>
                <span class="cov8" title="1">return c.JSON(Response{Status: fiber.StatusOK, Message: "Withdrawal successful", Data: ToTransactionDTO(tx)})</span>
        }
}

// GetTransactions returns a Fiber handler that retrieves the list of transactions for a specific account.
// It expects a UnitOfWork factory function as a dependency for service instantiation.
// The handler extracts the current user ID from the request context and parses the account ID from the URL parameters.
// On success, it returns the transactions as a JSON response. On error, it logs the error and returns an appropriate JSON error response.
// @Summary Get account transactions
// @Description Retrieve the list of transactions for a specific account
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Success 200 {object} Response
// @Failure 400 {object} ProblemDetails
// @Failure 401 {object} ProblemDetails
// @Failure 429 {object} ProblemDetails
// @Failure 500 {object} ProblemDetails
// @Router /account/{id}/transactions [get]
// @Security Bearer
func GetTransactions(
        accountSvc *service.AccountService,
        authSvc *service.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusUnauthorized, "unauthorized", "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        status := ErrorToStatusCode(err)
                        return ErrorResponseJSON(c, status, "invalid user ID", err.Error())
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("Invalid account ID for transactions: %v", err)
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Invalid account ID", err.Error())
                }</span>

                <span class="cov8" title="1">tx, err := accountSvc.GetTransactions(userID, id)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("Failed to list transactions for account ID %s: %v", id, err)
                        status := ErrorToStatusCode(err)
                        return ErrorResponseJSON(c, status, "Failed to list transactions", err.Error())
                }</span>
                <span class="cov8" title="1">return c.JSON(Response{Status: fiber.StatusOK, Message: "Transactions fetched", Data: tx})</span>
        }
}

// GetBalance returns a Fiber handler for retrieving the balance of a specific account.
// It expects a UnitOfWork factory function as a dependency for service instantiation.
// The handler extracts the current user ID from the request context and parses the account ID from the URL parameters.
// On success, it returns the account balance as a JSON response. On error, it logs the error and returns an appropriate JSON error response.
// @Summary Get account balance
// @Description Retrieve the balance of a specific account
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Success 200 {object} Response
// @Failure 400 {object} ProblemDetails
// @Failure 401 {object} ProblemDetails
// @Failure 429 {object} ProblemDetails
// @Failure 500 {object} ProblemDetails
// @Router /account/{id}/balance [get]
// @Security Bearer
func GetBalance(
        accountSvc *service.AccountService,
        authSvc *service.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusUnauthorized, "unauthorized", "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        status := ErrorToStatusCode(err)
                        return ErrorResponseJSON(c, status, "invalid user ID", err.Error())
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("Invalid account ID for balance: %v", err)
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Invalid account ID", err.Error())
                }</span>

                <span class="cov8" title="1">balance, err := accountSvc.GetBalance(userID, id)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("Failed to fetch balance for account ID %s: %v", id, err)
                        status := ErrorToStatusCode(err)
                        return ErrorResponseJSON(c, status, "Failed to fetch balance", err.Error())
                }</span>
                <span class="cov8" title="1">return c.Status(fiber.StatusOK).JSON(Response{Status: fiber.StatusOK, Message: "Balance fetched", Data: fiber.Map{"balance": balance}})</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package webapi

import (
        "time"

        "github.com/amirasaad/fintech/pkg/service"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/limiter"
        "github.com/gofiber/fiber/v2/middleware/recover"
        "github.com/gofiber/swagger"

        // docs are generated by Swag CLI, you have to import them.
        _ "github.com/amirasaad/fintech/docs"
)

func NewApp(
        accountSvc *service.AccountService,
        userSvc *service.UserService,
        authSvc *service.AuthService,
) *fiber.App <span class="cov8" title="1">{
        app := fiber.New(fiber.Config{
                ErrorHandler: func(c *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                        // Default to 500 if status code cannot be determined
                        status := fiber.StatusInternalServerError
                        if e, ok := err.(*fiber.Error); ok </span><span class="cov0" title="0">{
                                status = e.Code
                        }</span>
                        <span class="cov0" title="0">return ErrorResponseJSON(c, status, "Internal Server Error", err.Error())</span>
                },
        })
        <span class="cov8" title="1">app.Get("/swagger/*", swagger.New(swagger.Config{
                TryItOutEnabled:      true,
                WithCredentials:      true,
                PersistAuthorization: true,
        }))

        app.Use(limiter.New(limiter.Config{
                Max:        5,
                Expiration: 1 * time.Second,
                KeyGenerator: func(c *fiber.Ctx) string </span><span class="cov8" title="1">{
                        return c.IP()
                }</span>,
                LimitReached: func(c *fiber.Ctx) error <span class="cov8" title="1">{
                        return ErrorResponseJSON(c, fiber.StatusTooManyRequests, "Too Many Requests", "Rate limit exceeded")
                }</span>,
        }))
        <span class="cov8" title="1">app.Use(recover.New())

        app.Get("/", func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                return c.SendString("App is working! ")
        }</span>)

        <span class="cov8" title="1">AccountRoutes(app, accountSvc, authSvc)
        UserRoutes(app, userSvc, authSvc)
        AuthRoutes(app, authSvc)

        return app</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package webapi

import (
        "github.com/amirasaad/fintech/pkg/service"
        "github.com/gofiber/fiber/v2"
)

type LoginInput struct {
        Identity string `json:"identity"`
        Password string `json:"password"`
}

func AuthRoutes(app *fiber.App, authSvc *service.AuthService) <span class="cov8" title="1">{
        app.Post("/login", Login(authSvc))
}</span>

// Login handles user authentication and returns a JWT token.
// @Summary User login
// @Description Authenticate user with identity (username or email) and password
// @Tags auth
// @Accept json
// @Produce json
// @Param request body LoginInput true "Login credentials"
// @Success 200 {object} Response
// @Failure 400 {object} ProblemDetails
// @Failure 401 {object} ProblemDetails
// @Failure 429 {object} ProblemDetails
// @Failure 500 {object} ProblemDetails
// @Router /login [post]
func Login(authSvc *service.AuthService) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                input := new(LoginInput)
                if err := c.BodyParser(input); err != nil </span><span class="cov8" title="1">{
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Error on login request", err.Error())
                }</span>
                <span class="cov8" title="1">user, token, err := authSvc.Login(input.Identity, input.Password)
                if err != nil </span><span class="cov8" title="1">{
                        return ErrorResponseJSON(c, fiber.StatusInternalServerError, "Internal Server Error", err.Error())
                }</span>
                <span class="cov8" title="1">if user == nil || token == "" </span><span class="cov8" title="1">{
                        return ErrorResponseJSON(c, fiber.StatusUnauthorized, "Invalid identity or password", nil)
                }</span>
                <span class="cov8" title="1">return c.JSON(Response{Status: fiber.StatusOK, Message: "Success login", Data: fiber.Map{"token": token}})</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package webapi

import (
        "bytes"
        "encoding/json"
        "io"
        "net/http/httptest"
        "runtime"
        "strings"
        "testing"

        "github.com/amirasaad/fintech/internal/fixtures"
        "github.com/stretchr/testify/mock"
        "github.com/stretchr/testify/suite"

        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/amirasaad/fintech/pkg/service"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "github.com/gofiber/fiber/v2/middleware/recover"
)

type E2ETestSuite struct {
        suite.Suite
        ts map[string]*testing.T // Map of test names &gt; *testing.T
}

func (suite *E2ETestSuite) BeforeTest(_, testName string) <span class="cov8" title="1">{
        t := suite.T()
        if suite.ts == nil </span><span class="cov8" title="1">{
                suite.ts = make(map[string]*testing.T, 1)
        }</span>
        <span class="cov8" title="1">suite.ts[testName] = t
        suite.T().Cleanup(func() </span><span class="cov8" title="1">{
                mock.AssertExpectationsForObjects(suite.T())
        }</span>)
        // Removed t.Parallel() to avoid concurrency issues with mocks
}

// T() overrides suite.Suite.T() with a way to find the proper *testing.T
// for the current test.
// This relies on `BeforeTest` storing the *testing.T pointers in a map
// before marking them parallel.
// This is a huge hack to make parallel testing work until
// https://github.com/stretchr/testify/issues/187 is fixed.
// There is still a small race:
// 1. test 1 calls SetT()
// 2. test 1 calls BeforeTest() with its own T
// 3. test 1 is marked as parallel and starts executing
// 4. test 2 calls SetT()
// 5. test 1 completes and calls SetT() to reset to the parent T
// 6. test 2 calls BeforeTest() with its parent T instead of its own
// The time between 4. &amp; 6. is extremely low, enough that this should be really rare on our e2e tests.
func (suite *E2ETestSuite) T() *testing.T <span class="cov8" title="1">{
        // Try to find in the call stack a method name that is stored in `ts` (the test method).
        for i := 1; ; i++ </span><span class="cov8" title="1">{
                pc, _, _, ok := runtime.Caller(i)
                if !ok </span><span class="cov8" title="1">{
                        break</span>
                }
                // Example rawFuncName:
                // github.com/foo/bar/tests/e2e.(*E2ETestSuite).MyTest
                <span class="cov8" title="1">rawFuncName := runtime.FuncForPC(pc).Name()
                splittedFuncName := strings.Split(rawFuncName, ".")
                funcName := splittedFuncName[len(splittedFuncName)-1]
                t := suite.ts[funcName]
                if t != nil </span><span class="cov8" title="1">{
                        return t
                }</span>
        }
        // Fallback to the globally stored Suite.T()
        <span class="cov8" title="1">return suite.Suite.T()</span>
}

// NewTestApp creates a new Fiber app for testing without rate limiting
func NewTestApp(
        accountSvc *service.AccountService,
        userSvc *service.UserService,
        authSvc *service.AuthService,
) *fiber.App <span class="cov8" title="1">{
        app := fiber.New(fiber.Config{
                ErrorHandler: func(c *fiber.Ctx, err error) error </span><span class="cov8" title="1">{
                        // Default to 500 if status code cannot be determined
                        status := fiber.StatusInternalServerError
                        if e, ok := err.(*fiber.Error); ok </span><span class="cov0" title="0">{
                                status = e.Code
                        }</span>
                        <span class="cov8" title="1">return ErrorResponseJSON(c, status, "Internal Server Error", err.Error())</span>
                },
        })
        // No rate limiting for tests
        <span class="cov8" title="1">app.Use(recover.New())

        app.Get("/", func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                return c.SendString("App is working! ")
        }</span>)

        <span class="cov8" title="1">AccountRoutes(app, accountSvc, authSvc)
        UserRoutes(app, userSvc, authSvc)
        AuthRoutes(app, authSvc)

        return app</span>
}

func SetupTestApp(
        t *testing.T,
) (
        app *fiber.App,
        userRepo *fixtures.MockUserRepository,
        accountRepo *fixtures.MockAccountRepository,
        transactionRepo *fixtures.MockTransactionRepository,
        mockUow *fixtures.MockUnitOfWork,
        testUser *domain.User,
        authService *service.AuthService,
        mockConverter *fixtures.MockCurrencyConverter,
) <span class="cov8" title="1">{
        t.Helper()
        // Set JWT secret key before creating the app
        t.Setenv("JWT_SECRET_KEY", "secret")

        userRepo = fixtures.NewMockUserRepository(t)
        accountRepo = fixtures.NewMockAccountRepository(t)
        transactionRepo = fixtures.NewMockTransactionRepository(t)

        mockUow = fixtures.NewMockUnitOfWork(t)

        authStrategy := service.NewJWTAuthStrategy(func() (repository.UnitOfWork, error) </span><span class="cov8" title="1">{ return mockUow, nil }</span>)
        <span class="cov8" title="1">authService = service.NewAuthService(func() (repository.UnitOfWork, error) </span><span class="cov0" title="0">{ return mockUow, nil }</span>, authStrategy)
        <span class="cov8" title="1">mockConverter = fixtures.NewMockCurrencyConverter(t)
        // Create services with the mock UOW factory
        accountSvc := service.NewAccountService(func() (repository.UnitOfWork, error) </span><span class="cov8" title="1">{ return mockUow, nil }</span>, mockConverter)
        <span class="cov8" title="1">userSvc := service.NewUserService(func() (repository.UnitOfWork, error) </span><span class="cov8" title="1">{ return mockUow, nil }</span>)

        <span class="cov8" title="1">app = NewTestApp(accountSvc, userSvc, authService)
        testUser, _ = domain.NewUser("testuser", "testuser@example.com", "password123")
        log.SetOutput(io.Discard)

        return</span>
}

func getTestToken(
        t *testing.T,
        app *fiber.App,
        testUser *domain.User,
) string <span class="cov8" title="1">{
        t.Helper()
        loginBody := &amp;LoginInput{Identity: testUser.Username, Password: "password123"}
        body, _ := json.Marshal(loginBody)

        req := httptest.NewRequest("POST", "/login", bytes.NewReader(body))
        req.Header.Set("Content-Type", "application/json")

        resp, err := app.Test(req, 10000)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>
        <span class="cov8" title="1">if resp.StatusCode != fiber.StatusOK </span><span class="cov0" title="0">{
                // Read response body for debugging
                respBody, _ := io.ReadAll(resp.Body)
                t.Logf("Login failed with status %d, body: %s", resp.StatusCode, string(respBody))
                t.Fatalf("expected status 200 but got %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">var response Response
        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>
        <span class="cov8" title="1">token, ok := response.Data.(map[string]interface{})["token"].(string)
        if !ok </span><span class="cov0" title="0">{
                t.Fatal("unable to extract token from response")
        }</span>
        <span class="cov8" title="1">return token</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package webapi

import (
        "github.com/amirasaad/fintech/pkg/middleware"
        "github.com/amirasaad/fintech/pkg/service"
        "github.com/go-playground/validator"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

type NewUser struct {
        Username string `json:"username" validate:"required,max=50"`
        Email    string `json:"email" validate:"required,email,max=50"`
        Password string `json:"password" validate:"required,min=6"`
}

type UpdateUserInput struct {
        Names string `json:"names"`
}

type PasswordInput struct {
        Password string `json:"password"`
}

func UserRoutes(app *fiber.App, userSvc *service.UserService, authSvc *service.AuthService) <span class="cov8" title="1">{
        app.Get("/user/:id", middleware.Protected(), GetUser(userSvc))
        app.Post("/user", CreateUser(userSvc))
        app.Put("/user/:id", middleware.Protected(), UpdateUser(userSvc, authSvc))
        app.Delete("/user/:id", middleware.Protected(), DeleteUser(userSvc, authSvc))
}</span>

// GetUser retrieves a user by ID.
// @Summary Get user by ID
// @Description Get a user by their unique identifier
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Success 200 {object} Response
// @Failure 400 {object} Response
// @Failure 404 {object} Response
// @Router /user/{id} [get]
// @Security Bearer
func GetUser(userSvc *service.UserService) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for deposit: %v", err)
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Invalid user ID", err.Error())
                }</span>
                <span class="cov8" title="1">user, err := userSvc.GetUser(id)
                if err != nil </span><span class="cov8" title="1">{
                        return ErrorResponseJSON(c, fiber.StatusNotFound, "No user found with ID", nil)
                }</span>
                <span class="cov8" title="1">return c.JSON(Response{Status: fiber.StatusCreated, Message: "User found", Data: user})</span>
        }
}

// CreateUser creates a new user account.
// @Summary Create a new user
// @Description Create a new user account with username, email, and password
// @Tags users
// @Accept json
// @Produce json
// @Param request body NewUser true "User creation data"
// @Success 201 {object} Response
// @Failure 400 {object} ProblemDetails
// @Failure 401 {object} ProblemDetails
// @Failure 429 {object} ProblemDetails
// @Failure 500 {object} ProblemDetails
// @Router /user [post]
func CreateUser(userSvc *service.UserService) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                var newUser NewUser
                if err := c.BodyParser(&amp;newUser); err != nil </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Review your input", err.Error())
                }</span>
                <span class="cov8" title="1">validate := validator.New()
                if err := validate.Struct(newUser); err != nil </span><span class="cov8" title="1">{
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Invalid request body", err.Error())
                }</span>
                <span class="cov8" title="1">if len(newUser.Password) &gt; 72 </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Invalid request body", "Password too long")
                }</span>
                <span class="cov8" title="1">user, err := userSvc.CreateUser(newUser.Username, newUser.Email, newUser.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusInternalServerError, "Couldn't create user", err.Error())
                }</span>
                <span class="cov8" title="1">return c.Status(fiber.StatusCreated).JSON(Response{Status: fiber.StatusCreated, Message: "Created user", Data: user})</span>
        }
}

// UpdateUser updates user information.
// @Summary Update user
// @Description Update user information by ID
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Param request body UpdateUserInput true "User update data"
// @Success 200 {object} Response
// @Failure 400 {object} ProblemDetails
// @Failure 401 {object} ProblemDetails
// @Failure 429 {object} ProblemDetails
// @Failure 500 {object} ProblemDetails
// @Router /user/{id} [put]
// @Security Bearer
func UpdateUser(
        userSvc *service.UserService,
        authSvc *service.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                var uui UpdateUserInput
                if err := c.BodyParser(&amp;uui); err != nil </span><span class="cov8" title="1">{
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Review your input", err.Error())
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for deposit: %v", err)
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Invalid user ID", err.Error())
                }</span>
                <span class="cov8" title="1">token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusUnauthorized, "unauthorized", "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        status := ErrorToStatusCode(err)
                        return ErrorResponseJSON(c, status, "invalid user ID", err.Error())
                }</span>
                <span class="cov8" title="1">if id != userID </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusForbidden, "You are not allowed to update this user", nil)
                }</span>
                <span class="cov8" title="1">user, err := userSvc.GetUser(id)
                if err != nil </span><span class="cov8" title="1">{
                        return ErrorResponseJSON(c, fiber.StatusNotFound, "User not found", nil)
                }</span>
                <span class="cov8" title="1">err = userSvc.UpdateUser(user)
                if err != nil </span><span class="cov8" title="1">{
                        return ErrorResponseJSON(c, fiber.StatusInternalServerError, "Failed to update user", err.Error())
                }</span>
                <span class="cov8" title="1">return c.JSON(Response{Status: fiber.StatusOK, Message: "User updated successfully", Data: user})</span>
        }
}

// DeleteUser deletes a user account.
// @Summary Delete user
// @Description Delete a user account by ID with password confirmation
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Param request body PasswordInput true "Password confirmation"
// @Success 204 {object} Response
// @Failure 400 {object} ProblemDetails
// @Failure 401 {object} ProblemDetails
// @Failure 429 {object} ProblemDetails
// @Failure 500 {object} ProblemDetails
// @Router /user/{id} [delete]
// @Security Bearer
func DeleteUser(
        userSvc *service.UserService,
        authSvc *service.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                var pi PasswordInput
                if err := c.BodyParser(&amp;pi); err != nil </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Review your input", err.Error())
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for deposit: %v", err)
                        return ErrorResponseJSON(c, fiber.StatusBadRequest, "Invalid user ID", err.Error())
                }</span>
                <span class="cov8" title="1">token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusUnauthorized, "unauthorized", "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        status := ErrorToStatusCode(err)
                        return ErrorResponseJSON(c, status, "invalid user ID", err.Error())
                }</span>
                <span class="cov8" title="1">if id != userID </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusForbidden, "You are not allowed to update this user", nil)
                }</span>
                <span class="cov8" title="1">isValid, err := userSvc.ValidUser(id, pi.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrorResponseJSON(c, fiber.StatusInternalServerError, "Failed to validate user", err.Error())
                }</span>
                <span class="cov8" title="1">if !isValid </span><span class="cov8" title="1">{
                        return ErrorResponseJSON(c, fiber.StatusUnauthorized, "Not valid user", nil)
                }</span>
                <span class="cov8" title="1">err = userSvc.DeleteUser(id)
                if err != nil </span><span class="cov8" title="1">{
                        return ErrorResponseJSON(c, fiber.StatusInternalServerError, "Failed to delete user", err.Error())
                }</span>
                <span class="cov8" title="1">return c.Status(fiber.StatusNoContent).JSON(Response{Status: fiber.StatusNoContent, Message: "User successfully deleted", Data: nil})</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package webapi

import (
        "errors"

        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/gofiber/fiber/v2"
)

// Response defines the standard API response structure for success cases.
type Response struct {
        Status  int    `json:"status"`         // HTTP status code
        Message string `json:"message"`        // Human-readable explanation
        Data    any    `json:"data,omitempty"` // Response data
}

// ProblemDetails follows RFC 9457 Problem Details for HTTP APIs.
type ProblemDetails struct {
        Type     string `json:"type,omitempty"`     // A URI reference that identifies the problem type
        Title    string `json:"title"`              // Short, human-readable summary
        Status   int    `json:"status"`             // HTTP status code
        Detail   string `json:"detail,omitempty"`   // Human-readable explanation
        Instance string `json:"instance,omitempty"` // URI reference that identifies the specific occurrence
        Errors   any    `json:"errors,omitempty"`   // Optional: additional error details
}

// ErrorResponseJSON returns a response following RFC 9457 Problem Details
func ErrorResponseJSON(
        c *fiber.Ctx,
        status int,
        title string,
        detail any,
) error <span class="cov8" title="1">{
        pd := ProblemDetails{
                Type:   "about:blank",
                Title:  title,
                Status: status,
        }
        if detail != nil </span><span class="cov8" title="1">{
                if s, ok := detail.(string); ok </span><span class="cov8" title="1">{
                        pd.Detail = s
                }</span> else<span class="cov0" title="0"> {
                        pd.Errors = detail
                }</span>
        }
        <span class="cov8" title="1">pd.Instance = c.OriginalURL()
        c.Set(fiber.HeaderContentType, "application/problem+json")

        return c.Status(status).JSON(pd)</span>
}

// ErrorToStatusCode maps domain errors to appropriate HTTP status codes.
func ErrorToStatusCode(err error) int <span class="cov8" title="1">{
        switch </span>{
        case errors.Is(err, domain.ErrAccountNotFound):<span class="cov8" title="1">
                return fiber.StatusNotFound</span>
        case errors.Is(err, domain.ErrInvalidCurrencyCode):<span class="cov0" title="0">
                return fiber.StatusUnprocessableEntity</span>
        case errors.Is(err, domain.ErrDepositAmountExceedsMaxSafeInt):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, domain.ErrTransactionAmountMustBePositive):<span class="cov8" title="1">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, domain.ErrWithdrawalAmountMustBePositive):<span class="cov8" title="1">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, domain.ErrInsufficientFunds):<span class="cov0" title="0">
                return fiber.StatusUnprocessableEntity</span>
        case errors.Is(err, domain.ErrUserUnauthorized):<span class="cov0" title="0">
                return fiber.StatusUnauthorized</span>
        default:<span class="cov8" title="1">
                return fiber.StatusInternalServerError</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
