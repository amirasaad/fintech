
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/amirasaad/fintech/docs/docs.go (0.0%)</option>
				
				<option value="file1">github.com/amirasaad/fintech/infra/cache/memory_cache.go (0.0%)</option>
				
				<option value="file2">github.com/amirasaad/fintech/infra/cache/redis_cache.go (0.0%)</option>
				
				<option value="file3">github.com/amirasaad/fintech/infra/database.go (0.0%)</option>
				
				<option value="file4">github.com/amirasaad/fintech/infra/factory.go (0.0%)</option>
				
				<option value="file5">github.com/amirasaad/fintech/infra/provider/currency_converter.go (0.0%)</option>
				
				<option value="file6">github.com/amirasaad/fintech/infra/provider/exchange_rates.go (68.0%)</option>
				
				<option value="file7">github.com/amirasaad/fintech/infra/provider/exchangerate_api.go (0.0%)</option>
				
				<option value="file8">github.com/amirasaad/fintech/infra/provider/stub_currency_converter.go (0.0%)</option>
				
				<option value="file9">github.com/amirasaad/fintech/infra/repository/clean_generic_impl.go (0.0%)</option>
				
				<option value="file10">github.com/amirasaad/fintech/infra/repository/repository.go (22.2%)</option>
				
				<option value="file11">github.com/amirasaad/fintech/infra/repository/uow.go (48.1%)</option>
				
				<option value="file12">github.com/amirasaad/fintech/infra/repository/uow_string_based.go (0.0%)</option>
				
				<option value="file13">github.com/amirasaad/fintech/pkg/config/app_config.go (0.0%)</option>
				
				<option value="file14">github.com/amirasaad/fintech/pkg/config/env.go (43.5%)</option>
				
				<option value="file15">github.com/amirasaad/fintech/pkg/currency/currency.go (74.4%)</option>
				
				<option value="file16">github.com/amirasaad/fintech/pkg/currency/examples.go (0.0%)</option>
				
				<option value="file17">github.com/amirasaad/fintech/pkg/domain/account/account.go (75.0%)</option>
				
				<option value="file18">github.com/amirasaad/fintech/pkg/domain/account/transaction.go (59.1%)</option>
				
				<option value="file19">github.com/amirasaad/fintech/pkg/domain/money/money.go (81.6%)</option>
				
				<option value="file20">github.com/amirasaad/fintech/pkg/domain/user/user.go (66.7%)</option>
				
				<option value="file21">github.com/amirasaad/fintech/pkg/middleware/auth.go (100.0%)</option>
				
				<option value="file22">github.com/amirasaad/fintech/pkg/registry/currency_example.go (0.0%)</option>
				
				<option value="file23">github.com/amirasaad/fintech/pkg/registry/enhanced_registry.go (63.4%)</option>
				
				<option value="file24">github.com/amirasaad/fintech/pkg/registry/examples.go (0.0%)</option>
				
				<option value="file25">github.com/amirasaad/fintech/pkg/registry/factory.go (34.9%)</option>
				
				<option value="file26">github.com/amirasaad/fintech/pkg/registry/implementations.go (59.8%)</option>
				
				<option value="file27">github.com/amirasaad/fintech/pkg/registry/interface.go (89.3%)</option>
				
				<option value="file28">github.com/amirasaad/fintech/pkg/registry/registry.go (98.4%)</option>
				
				<option value="file29">github.com/amirasaad/fintech/pkg/repository/clean_generic_repository.go (0.0%)</option>
				
				<option value="file30">github.com/amirasaad/fintech/pkg/repository/generic_repository.go (0.0%)</option>
				
				<option value="file31">github.com/amirasaad/fintech/pkg/repository/uow_generic.go (0.0%)</option>
				
				<option value="file32">github.com/amirasaad/fintech/pkg/repository/uow_generic_complete.go (0.0%)</option>
				
				<option value="file33">github.com/amirasaad/fintech/pkg/repository/uow_hybrid.go (0.0%)</option>
				
				<option value="file34">github.com/amirasaad/fintech/pkg/repository/uow_improved.go (0.0%)</option>
				
				<option value="file35">github.com/amirasaad/fintech/pkg/service/account/account.go (51.8%)</option>
				
				<option value="file36">github.com/amirasaad/fintech/pkg/service/account/account_complete_generic.go (0.0%)</option>
				
				<option value="file37">github.com/amirasaad/fintech/pkg/service/account/account_direct.go (0.0%)</option>
				
				<option value="file38">github.com/amirasaad/fintech/pkg/service/account/account_generic_example.go (0.0%)</option>
				
				<option value="file39">github.com/amirasaad/fintech/pkg/service/account/account_string_based_example.go (0.0%)</option>
				
				<option value="file40">github.com/amirasaad/fintech/pkg/service/account/account_typesafe_example.go (0.0%)</option>
				
				<option value="file41">github.com/amirasaad/fintech/pkg/service/account/chain.go (89.8%)</option>
				
				<option value="file42">github.com/amirasaad/fintech/pkg/service/account/queries.go (75.6%)</option>
				
				<option value="file43">github.com/amirasaad/fintech/pkg/service/auth/auth.go (47.7%)</option>
				
				<option value="file44">github.com/amirasaad/fintech/pkg/service/currency/currency.go (91.3%)</option>
				
				<option value="file45">github.com/amirasaad/fintech/pkg/service/currency/currency_converter.go (0.0%)</option>
				
				<option value="file46">github.com/amirasaad/fintech/pkg/service/user/user.go (82.1%)</option>
				
				<option value="file47">github.com/amirasaad/fintech/pkg/utils/utils.go (0.0%)</option>
				
				<option value="file48">github.com/amirasaad/fintech/webapi/account/account.go (57.0%)</option>
				
				<option value="file49">github.com/amirasaad/fintech/webapi/account/dto.go (40.0%)</option>
				
				<option value="file50">github.com/amirasaad/fintech/webapi/app.go (93.3%)</option>
				
				<option value="file51">github.com/amirasaad/fintech/webapi/auth/auth.go (81.2%)</option>
				
				<option value="file52">github.com/amirasaad/fintech/webapi/common/utils.go (0.0%)</option>
				
				<option value="file53">github.com/amirasaad/fintech/webapi/currency/currency.go (0.0%)</option>
				
				<option value="file54">github.com/amirasaad/fintech/webapi/testutils/testutils.go (0.0%)</option>
				
				<option value="file55">github.com/amirasaad/fintech/webapi/user/user.go (73.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "email": "fiber@swagger.io"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/account": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Create a new account for the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Create a new account",
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/account/{id}/balance": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Retrieve the balance of a specific account",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Get account balance",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/account/{id}/deposit": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Deposit a specified amount into the user's account",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Deposit funds into an account",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Deposit request with amount",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/account.DepositRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/account/{id}/transactions": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Retrieve the list of transactions for a specific account",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Get account transactions",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/account/{id}/withdraw": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Withdraw a specified amount from the user's account",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Withdraw funds from an account",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Withdrawal request with amount",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/account.WithdrawRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/admin": {
            "post": {
                "description": "Register a new currency (admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Register currency",
                "parameters": [
                    {
                        "description": "Currency information",
                        "name": "currency",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/currency.RegisterCurrencyRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/currency.CurrencyMeta"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/admin/{code}": {
            "delete": {
                "description": "Remove a currency from the registry (admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Unregister currency",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Currency code",
                        "name": "code",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/admin/{code}/activate": {
            "put": {
                "description": "Activate a currency (admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Activate currency",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Currency code",
                        "name": "code",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/admin/{code}/deactivate": {
            "put": {
                "description": "Deactivate a currency (admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Deactivate currency",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Currency code",
                        "name": "code",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/default": {
            "get": {
                "description": "Get the default currency information",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Get default currency",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/currency.CurrencyMeta"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/region/{region}": {
            "get": {
                "description": "Search for currencies by region",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Search currencies by region",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Region name",
                        "name": "region",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/currency.CurrencyMeta"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/search": {
            "get": {
                "description": "Search for currencies by name",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Search currencies",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Search query",
                        "name": "q",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/currency.CurrencyMeta"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/statistics": {
            "get": {
                "description": "Get currency registry statistics",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Get currency statistics",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/supported": {
            "get": {
                "description": "Get all supported currency codes",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "List supported currencies",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/{code}": {
            "get": {
                "description": "Get currency information by ISO 4217 code",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Get currency by code",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Currency code (e.g., USD, EUR)",
                        "name": "code",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/currency.CurrencyMeta"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/{code}/supported": {
            "get": {
                "description": "Check if a currency code is supported",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Check if currency is supported",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Currency code (e.g., USD, EUR)",
                        "name": "code",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/auth/login": {
            "post": {
                "description": "Authenticate user with identity (username or email) and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "Login credentials",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/auth.LoginInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/currency": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get a list of all available currencies in the system",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "List all currencies",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/user": {
            "post": {
                "description": "Create a new user account with username, email, and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Create a new user",
                "parameters": [
                    {
                        "description": "User creation data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user.NewUser"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/user/{id}": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Retrieve a user by their ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get user by ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Update user information by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Update user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "User update data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user.UpdateUserInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Delete a user account by ID with password confirmation",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Delete user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Password confirmation",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user.PasswordInput"
                        }
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "account.DepositRequest": {
            "type": "object",
            "required": [
                "amount"
            ],
            "properties": {
                "amount": {
                    "type": "number"
                },
                "currency": {
                    "type": "string"
                }
            }
        },
        "account.WithdrawRequest": {
            "type": "object",
            "required": [
                "amount"
            ],
            "properties": {
                "amount": {
                    "type": "number"
                },
                "currency": {
                    "type": "string"
                }
            }
        },
        "auth.LoginInput": {
            "type": "object",
            "required": [
                "identity",
                "password"
            ],
            "properties": {
                "identity": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "common.ProblemDetails": {
            "type": "object",
            "properties": {
                "detail": {
                    "description": "Human-readable explanation",
                    "type": "string"
                },
                "errors": {
                    "description": "Optional: additional error details"
                },
                "instance": {
                    "description": "URI reference that identifies the specific occurrence",
                    "type": "string"
                },
                "status": {
                    "description": "HTTP status code",
                    "type": "integer"
                },
                "title": {
                    "description": "Short, human-readable summary",
                    "type": "string"
                },
                "type": {
                    "description": "A URI reference that identifies the problem type",
                    "type": "string"
                }
            }
        },
        "common.Response": {
            "type": "object",
            "properties": {
                "data": {
                    "description": "Response data"
                },
                "message": {
                    "description": "Human-readable explanation",
                    "type": "string"
                },
                "status": {
                    "description": "HTTP status code",
                    "type": "integer"
                }
            }
        },
        "currency.CurrencyMeta": {
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "code": {
                    "type": "string"
                },
                "country": {
                    "type": "string"
                },
                "created": {
                    "type": "string"
                },
                "decimals": {
                    "type": "integer"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "region": {
                    "type": "string"
                },
                "symbol": {
                    "type": "string"
                },
                "updated": {
                    "type": "string"
                }
            }
        },
        "currency.RegisterCurrencyRequest": {
            "type": "object",
            "required": [
                "code",
                "decimals",
                "name",
                "symbol"
            ],
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "code": {
                    "type": "string"
                },
                "country": {
                    "type": "string"
                },
                "decimals": {
                    "type": "integer",
                    "maximum": 8,
                    "minimum": 0
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "region": {
                    "type": "string"
                },
                "symbol": {
                    "type": "string"
                }
            }
        },
        "user.NewUser": {
            "type": "object",
            "required": [
                "email",
                "password",
                "username"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "maxLength": 50
                },
                "password": {
                    "type": "string",
                    "maxLength": 72,
                    "minLength": 6
                },
                "username": {
                    "type": "string",
                    "maxLength": 50,
                    "minLength": 3
                }
            }
        },
        "user.PasswordInput": {
            "type": "object",
            "required": [
                "password"
            ],
            "properties": {
                "password": {
                    "type": "string"
                }
            }
        },
        "user.UpdateUserInput": {
            "type": "object",
            "properties": {
                "names": {
                    "type": "string",
                    "maxLength": 100
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0.0",
        Host:             "fintech-beryl-beta.vercel.app",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "Fintech API",
        Description:      "Fintech API documentation",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cache

import (
        "sync"
        "time"

        "github.com/amirasaad/fintech/pkg/domain"
)

// MemoryCache implements ExchangeRateCache using in-memory storage
type MemoryCache struct {
        cache      map[string]*cacheEntry
        lastUpdate map[string]time.Time
        mu         sync.RWMutex
}

// NewMemoryCache creates a new in-memory cache
func NewMemoryCache() *MemoryCache <span class="cov0" title="0">{
        cache := &amp;MemoryCache{
                cache:      make(map[string]*cacheEntry),
                lastUpdate: make(map[string]time.Time),
        }

        // Start cleanup goroutine
        go cache.cleanup()

        return cache
}</span>

// Get retrieves a rate from cache
func (c *MemoryCache) Get(key string) (*domain.ExchangeRate, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        entry, exists := c.cache[key]
        if !exists </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if time.Now().After(entry.expiresAt) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return entry.rate, nil</span>
}

// Set stores a rate in cache with TTL
func (c *MemoryCache) Set(key string, rate *domain.ExchangeRate, ttl time.Duration) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.cache[key] = &amp;cacheEntry{
                rate:      rate,
                expiresAt: time.Now().Add(ttl),
        }

        return nil
}</span>

// Delete removes a rate from cache
func (c *MemoryCache) Delete(key string) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.cache, key)
        return nil
}</span>

// GetLastUpdate returns the last update timestamp for a key
func (c *MemoryCache) GetLastUpdate(key string) (time.Time, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        ts, ok := c.lastUpdate[key]
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, nil
        }</span>
        <span class="cov0" title="0">return ts, nil</span>
}

// SetLastUpdate sets the last update timestamp for a key
func (c *MemoryCache) SetLastUpdate(key string, t time.Time) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.lastUpdate[key] = t
        return nil
}</span>

// cleanup removes expired entries from cache
func (c *MemoryCache) cleanup() <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                c.mu.Lock()
                now := time.Now()
                for key, entry := range c.cache </span><span class="cov0" title="0">{
                        if now.After(entry.expiresAt) </span><span class="cov0" title="0">{
                                delete(c.cache, key)
                        }</span>
                }
                <span class="cov0" title="0">c.mu.Unlock()</span>
        }
}

type cacheEntry struct {
        rate      *domain.ExchangeRate
        expiresAt time.Time
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "time"

        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/redis/go-redis/v9"
)

// RedisExchangeRateCache implements ExchangeRateCache using Redis.
type RedisExchangeRateCache struct {
        client *redis.Client
        prefix string
        logger *slog.Logger
}

// NewRedisExchangeRateCache creates a new RedisExchangeRateCache.
func NewRedisExchangeRateCache(addr, password string, db int, prefix string) *RedisExchangeRateCache <span class="cov0" title="0">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:     addr,
                Password: password,
                DB:       db,
        })
        return &amp;RedisExchangeRateCache{client: client, prefix: prefix}
}</span>

// NewRedisExchangeRateCacheWithOptions creates a new RedisExchangeRateCache from redis.Options.
func NewRedisExchangeRateCacheWithOptions(opt *redis.Options, prefix string, logger *slog.Logger) *RedisExchangeRateCache <span class="cov0" title="0">{
        client := redis.NewClient(opt)
        return &amp;RedisExchangeRateCache{client: client, prefix: prefix, logger: logger}
}</span>

func (r *RedisExchangeRateCache) key(key string) string <span class="cov0" title="0">{
        return r.prefix + key
}</span>

func (r *RedisExchangeRateCache) Get(key string) (*domain.ExchangeRate, error) <span class="cov0" title="0">{
        ctx := context.Background()
        val, err := r.client.Get(ctx, r.key(key)).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                r.logger.Debug("Redis cache miss", "key", key)
                return nil, nil // cache miss
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache get error", "key", key, "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">var rate domain.ExchangeRate
        if err := json.Unmarshal([]byte(val), &amp;rate); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache unmarshal error", "key", key, "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">r.logger.Debug("Redis cache hit", "key", key, "rate", rate.Rate)
        return &amp;rate, nil</span>
}

func (r *RedisExchangeRateCache) Set(key string, rate *domain.ExchangeRate, ttl time.Duration) error <span class="cov0" title="0">{
        ctx := context.Background()
        data, err := json.Marshal(rate)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache marshal error", "key", key, "error", err)
                return err
        }</span>
        <span class="cov0" title="0">err = r.client.Set(ctx, r.key(key), data, ttl).Err()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache set error", "key", key, "error", err)
                return err
        }</span>
        <span class="cov0" title="0">r.logger.Debug("Redis cache set", "key", key, "rate", rate.Rate, "ttl", ttl)
        return nil</span>
}

func (r *RedisExchangeRateCache) Delete(key string) error <span class="cov0" title="0">{
        ctx := context.Background()
        err := r.client.Del(ctx, r.key(key)).Err()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache delete error", "key", key, "error", err)
                return err
        }</span>
        <span class="cov0" title="0">r.logger.Debug("Redis cache delete", "key", key)
        return nil</span>
}

func (r *RedisExchangeRateCache) GetLastUpdate(key string) (time.Time, error) <span class="cov0" title="0">{
        ctx := context.Background()
        val, err := r.client.Get(ctx, r.key("last_update:"+key)).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return time.Time{}, nil // not set
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache get last update error", "key", key, "error", err)
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">ts, err := time.Parse(time.RFC3339Nano, val)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache parse last update error", "key", key, "error", err)
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">return ts, nil</span>
}

func (r *RedisExchangeRateCache) SetLastUpdate(key string, t time.Time) error <span class="cov0" title="0">{
        ctx := context.Background()
        err := r.client.Set(ctx, r.key("last_update:"+key), t.Format(time.RFC3339Nano), 0).Err()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache set last update error", "key", key, "error", err)
                return err
        }</span>
        <span class="cov0" title="0">r.logger.Debug("Redis cache set last update", "key", key, "timestamp", t)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package infra

import (
        "errors"
        "time"

        "github.com/amirasaad/fintech/pkg/config"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

// Add appEnv as a parameter for dependency-injected environment
func NewDBConnection(cnf config.DBConfig, appEnv string) (*gorm.DB, error) <span class="cov0" title="0">{
        databaseUrl := cnf.Url
        if databaseUrl == "" </span><span class="cov0" title="0">{
                return nil, errors.New("DATABASE_URL is not set")
        }</span>

        <span class="cov0" title="0">var logMode logger.LogLevel
        if appEnv == "development" </span><span class="cov0" title="0">{
                logMode = logger.Info
        }</span> else<span class="cov0" title="0"> {
                logMode = logger.Silent
        }</span>

        <span class="cov0" title="0">connection, err := gorm.Open(postgres.Open(databaseUrl), &amp;gorm.Config{
                Logger:                 logger.Default.LogMode(logMode),
                SkipDefaultTransaction: true})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sqlDB, err := connection.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(25)
        sqlDB.SetMaxIdleConns(25)
        sqlDB.SetConnMaxLifetime(1 * time.Hour)

        return connection, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package infra

import (
        "log/slog"

        infra_cache "github.com/amirasaad/fintech/infra/cache"
        infra_provider "github.com/amirasaad/fintech/infra/provider"
        "github.com/amirasaad/fintech/pkg/cache"
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/redis/go-redis/v9"
)

// NewExchangeRateSystem creates a complete exchange rate system with providers, cache, and converter
func NewExchangeRateSystem(logger *slog.Logger, cfg config.AppConfig) (domain.CurrencyConverter, error) <span class="cov0" title="0">{
        // Create cache
        var rateCache cache.ExchangeRateCache
        if cfg.Redis.URL != "" </span><span class="cov0" title="0">{
                opt, err := redis.ParseURL(cfg.Redis.URL)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Invalid Redis URL", "url", cfg.Redis.URL, "error", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">rateCache = infra_cache.NewRedisExchangeRateCacheWithOptions(opt, cfg.Exchange.CachePrefix, logger)
                logger.Info("Using Redis for exchange rate cache", "url", cfg.Redis.URL)</span>
        } else<span class="cov0" title="0"> {
                rateCache = infra_cache.NewMemoryCache()
                logger.Info("Using in-memory cache for exchange rates")
        }</span>

        // Create providers
        <span class="cov0" title="0">var exchangeRateProviders []provider.ExchangeRateProvider

        // Use USD as the base currency for now (configurable in future)
        baseCurrency := "USD"
        // TODO: Make base currency configurable via config.Exchange.BaseCurrency

        // Add ExchangeRate API provider if API key is configured
        var exchangeRateProvider *infra_provider.ExchangeRateAPIProvider
        if cfg.Exchange.ApiKey != "" </span><span class="cov0" title="0">{
                exchangeRateProvider = infra_provider.NewExchangeRateAPIProvider(cfg.Exchange, logger)
                exchangeRateProviders = append(exchangeRateProviders, exchangeRateProvider)
                logger.Info("ExchangeRate API provider configured", "apiKey", maskAPIKey(cfg.Exchange.ApiKey))
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("No ExchangeRate API key configured, using fallback only")
        }</span>

        // Fetch and cache rates ONCE at startup for POC
        <span class="cov0" title="0">if exchangeRateProvider != nil </span><span class="cov0" title="0">{
                err := exchangeRateProvider.FetchAndCacheRates(baseCurrency, rateCache, cfg.Exchange.CacheTTL)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to fetch and cache exchange rates at startup", "error", err)
                }</span>
        }

        // Create exchange rate service
        <span class="cov0" title="0">exchangeRateService := infra_provider.NewExchangeRateService(exchangeRateProviders, rateCache, logger, &amp;cfg.Exchange)

        // Create fallback converter
        var fallback domain.CurrencyConverter
        if cfg.Exchange.EnableFallback </span><span class="cov0" title="0">{
                fallback = infra_provider.NewStubCurrencyConverter()
                logger.Info("Fallback currency converter enabled")
        }</span>

        // Create real currency converter
        <span class="cov0" title="0">converter := infra_provider.NewRealCurrencyConverter(exchangeRateService, fallback, logger)

        logger.Info("Exchange rate system initialized",
                "providers", len(exchangeRateProviders),
                "fallbackEnabled", cfg.Exchange.EnableFallback,
                "cacheTTL", cfg.Exchange.CacheTTL)

        return converter, nil</span>
}

// maskAPIKey returns a masked version of the API key for logging
func maskAPIKey(apiKey string) string <span class="cov0" title="0">{
        if len(apiKey) &lt;= 8 </span><span class="cov0" title="0">{
                return "***"
        }</span>
        <span class="cov0" title="0">return apiKey[:4] + "..." + apiKey[len(apiKey)-4:]</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package provider

import (
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain"
)

// RealCurrencyConverter implements the CurrencyConverter interface using real exchange rates.
type RealCurrencyConverter struct {
        exchangeRateService *ExchangeRateService
        logger              *slog.Logger
        fallback            domain.CurrencyConverter
}

// NewRealCurrencyConverter creates a new real currency converter with fallback support.
func NewRealCurrencyConverter(exchangeRateService *ExchangeRateService, fallback domain.CurrencyConverter, logger *slog.Logger) *RealCurrencyConverter <span class="cov0" title="0">{
        return &amp;RealCurrencyConverter{
                exchangeRateService: exchangeRateService,
                logger:              logger,
                fallback:            fallback,
        }
}</span>

// Convert converts an amount from one currency to another using real exchange rates.
func (c *RealCurrencyConverter) Convert(amount float64, from, to string) (*domain.ConversionInfo, error) <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return &amp;domain.ConversionInfo{
                        OriginalAmount:    amount,
                        OriginalCurrency:  from,
                        ConvertedAmount:   amount,
                        ConvertedCurrency: to,
                        ConversionRate:    1.0,
                }, nil
        }</span>

        // Try to get real exchange rate
        <span class="cov0" title="0">rate, err := c.exchangeRateService.GetRate(from, to)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to get real exchange rate, falling back", "from", from, "to", to, "error", err)

                // Use fallback converter
                if c.fallback != nil </span><span class="cov0" title="0">{
                        return c.fallback.Convert(amount, from, to)
                }</span>

                <span class="cov0" title="0">return nil, domain.ErrExchangeRateUnavailable</span>
        }

        <span class="cov0" title="0">convertedAmount := amount * rate.Rate

        c.logger.Info("Currency conversion completed",
                "from", from, "to", to, "amount", amount,
                "converted", convertedAmount, "rate", rate.Rate, "source", rate.Source)

        return &amp;domain.ConversionInfo{
                OriginalAmount:    amount,
                OriginalCurrency:  from,
                ConvertedAmount:   convertedAmount,
                ConvertedCurrency: to,
                ConversionRate:    rate.Rate,
        }, nil</span>
}

// GetRate returns the current exchange rate between two currencies.
func (c *RealCurrencyConverter) GetRate(from, to string) (float64, error) <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return 1.0, nil
        }</span>

        <span class="cov0" title="0">rate, err := c.exchangeRateService.GetRate(from, to)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to get real exchange rate, falling back", "from", from, "to", to, "error", err)

                // Use fallback converter
                if c.fallback != nil </span><span class="cov0" title="0">{
                        return c.fallback.GetRate(from, to)
                }</span>

                <span class="cov0" title="0">return 0, domain.ErrExchangeRateUnavailable</span>
        }

        <span class="cov0" title="0">return rate.Rate, nil</span>
}

// IsSupported checks if a currency pair is supported by checking if we can get a rate.
func (c *RealCurrencyConverter) IsSupported(from, to string) bool <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return true
        }</span>

        // Try to get a rate to check if supported
        <span class="cov0" title="0">_, err := c.exchangeRateService.GetRate(from, to)
        if err == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check fallback
        <span class="cov0" title="0">if c.fallback != nil </span><span class="cov0" title="0">{
                return c.fallback.IsSupported(from, to)
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package provider

import (
        "fmt"
        "log/slog"
        "math"
        "time"

        infra_cache "github.com/amirasaad/fintech/infra/cache"
        "github.com/amirasaad/fintech/pkg/cache"
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/provider"
)

// ExchangeRateService provides real-time exchange rates with caching and fallback providers.
type ExchangeRateService struct {
        providers []provider.ExchangeRateProvider
        cache     cache.ExchangeRateCache
        logger    *slog.Logger
        cfg       *config.ExchangeRateConfig
        // mu        sync.RWMutex
}

// NewExchangeRateService creates a new exchange rate service with the given providers, cache, and exchange rate config.
func NewExchangeRateService(providers []provider.ExchangeRateProvider, cache cache.ExchangeRateCache, logger *slog.Logger, cfg *config.ExchangeRateConfig) *ExchangeRateService <span class="cov8" title="1">{
        return &amp;ExchangeRateService{
                providers: providers,
                cache:     cache,
                logger:    logger,
                cfg:       cfg,
        }
}</span>

// GetRate retrieves an exchange rate, trying cache first, then providers in order.
func (s *ExchangeRateService) GetRate(from, to string) (*domain.ExchangeRate, error) <span class="cov8" title="1">{
        s.logger.Info("[DIAG] Cache type", "type", fmt.Sprintf("%T", s.cache))
        if from == to </span><span class="cov8" title="1">{
                return &amp;domain.ExchangeRate{
                        FromCurrency: from,
                        ToCurrency:   to,
                        Rate:         1.0,
                        LastUpdated:  time.Now(),
                        Source:       "internal",
                        ExpiresAt:    time.Now().Add(24 * time.Hour),
                }, nil
        }</span>

        <span class="cov8" title="1">cacheKey := fmt.Sprintf("%s:%s", from, to)

        // Check last update timestamp
        if redisCache, ok := s.cache.(*infra_cache.RedisExchangeRateCache); ok </span><span class="cov0" title="0">{
                s.logger.Info("[DIAG] Checking last update timestamp in Redis", "key", cacheKey)
                lastUpdate, err := redisCache.GetLastUpdate(cacheKey)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("[DIAG] Failed to get last update from Redis", "key", cacheKey, "error", err)
                }</span>
                <span class="cov0" title="0">if err == nil &amp;&amp; !lastUpdate.IsZero() </span><span class="cov0" title="0">{
                        s.logger.Info("[DIAG] Last update timestamp found", "key", cacheKey, "lastUpdate", lastUpdate, "age", time.Since(lastUpdate), "ttl", s.cfg.CacheTTL)
                }</span>
                <span class="cov0" title="0">if err == nil &amp;&amp; !lastUpdate.IsZero() &amp;&amp; time.Since(lastUpdate) &lt; s.cfg.CacheTTL </span><span class="cov0" title="0">{
                        // Try cache first
                        if cached, err := s.cache.Get(cacheKey); err == nil &amp;&amp; cached != nil </span><span class="cov0" title="0">{
                                if time.Now().Before(cached.ExpiresAt) </span><span class="cov0" title="0">{
                                        s.logger.Info("[DIAG] Exchange rate retrieved from cache (last update valid)", "from", from, "to", to, "rate", cached.Rate)
                                        return cached, nil
                                }</span>
                        }
                }
        }

        // Try reverse pair in cache and invert
        <span class="cov8" title="1">reverseKey := fmt.Sprintf("%s:%s", to, from)
        if cached, err := s.cache.Get(reverseKey); err == nil &amp;&amp; cached != nil </span><span class="cov0" title="0">{
                if time.Now().Before(cached.ExpiresAt) &amp;&amp; cached.Rate != 0 </span><span class="cov0" title="0">{
                        s.logger.Debug("Exchange rate retrieved from cache (reversed)", "from", to, "to", from, "rate", cached.Rate)
                        return &amp;domain.ExchangeRate{
                                FromCurrency: from,
                                ToCurrency:   to,
                                Rate:         1 / cached.Rate,
                                LastUpdated:  cached.LastUpdated,
                                Source:       cached.Source + " (reversed)",
                                ExpiresAt:    cached.ExpiresAt,
                        }, nil
                }</span>
        }

        // Try providers in order
        <span class="cov8" title="1">for _, provider := range s.providers </span><span class="cov8" title="1">{
                if !provider.IsHealthy() </span><span class="cov8" title="1">{
                        s.logger.Warn("Provider not healthy, skipping", "provider", provider.Name())
                        continue</span>
                }

                <span class="cov8" title="1">rate, err := provider.GetRate(from, to)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Warn("Failed to get rate from provider", "provider", provider.Name(), "error", err)
                        continue</span>
                }

                // Validate rate
                <span class="cov8" title="1">if rate.Rate &lt;= 0 || math.IsNaN(rate.Rate) || math.IsInf(rate.Rate, 0) </span><span class="cov8" title="1">{
                        s.logger.Warn("Invalid rate received from provider", "provider", provider.Name(), "rate", rate.Rate)
                        continue</span>
                }

                // Cache the rate
                <span class="cov8" title="1">ttl := time.Until(rate.ExpiresAt)
                if ttl &gt; 0 </span><span class="cov8" title="1">{
                        _ = s.cache.Set(cacheKey, rate, ttl)
                        if redisCache, ok := s.cache.(*infra_cache.RedisExchangeRateCache); ok </span><span class="cov0" title="0">{
                                _ = redisCache.SetLastUpdate(cacheKey, time.Now())
                        }</span>
                }

                <span class="cov8" title="1">s.logger.Info("Exchange rate retrieved from provider", "provider", provider.Name(), "from", from, "to", to, "rate", rate.Rate)
                return rate, nil</span>
        }

        <span class="cov8" title="1">return nil, domain.ErrExchangeRateUnavailable</span>
}

// GetRates retrieves multiple exchange rates efficiently.
func (s *ExchangeRateService) GetRates(from string, to []string) (map[string]*domain.ExchangeRate, error) <span class="cov8" title="1">{
        results := make(map[string]*domain.ExchangeRate)
        var missing []string

        // Try cache first for each currency
        for _, currency := range to </span><span class="cov8" title="1">{
                cacheKey := fmt.Sprintf("%s:%s", from, currency)
                if cached, err := s.cache.Get(cacheKey); err == nil &amp;&amp; cached != nil </span><span class="cov0" title="0">{
                        if time.Now().Before(cached.ExpiresAt) </span><span class="cov0" title="0">{
                                results[currency] = cached
                                continue</span>
                        }
                        <span class="cov0" title="0">_ = s.cache.Delete(cacheKey)</span>
                }
                <span class="cov8" title="1">missing = append(missing, currency)</span>
        }

        // If we have missing rates, try providers
        <span class="cov8" title="1">if len(missing) &gt; 0 </span><span class="cov8" title="1">{
                for _, provider := range s.providers </span><span class="cov8" title="1">{
                        if !provider.IsHealthy() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">rates, err := provider.GetRates(from, missing)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to get rates from provider", "provider", provider.Name(), "error", err)
                                continue</span>
                        }

                        // Cache and add valid rates
                        <span class="cov8" title="1">for currency, rate := range rates </span><span class="cov8" title="1">{
                                if rate.Rate &gt; 0 &amp;&amp; !math.IsNaN(rate.Rate) &amp;&amp; !math.IsInf(rate.Rate, 0) </span><span class="cov8" title="1">{
                                        results[currency] = rate
                                        cacheKey := fmt.Sprintf("%s:%s", from, currency)
                                        ttl := time.Until(rate.ExpiresAt)
                                        if ttl &gt; 0 </span><span class="cov8" title="1">{
                                                _ = s.cache.Set(cacheKey, rate, ttl)
                                        }</span>
                                }
                        }

                        // Update missing list
                        <span class="cov8" title="1">missing = missing[:0]
                        for _, currency := range to </span><span class="cov8" title="1">{
                                if _, exists := results[currency]; !exists </span><span class="cov0" title="0">{
                                        missing = append(missing, currency)
                                }</span>
                        }

                        <span class="cov8" title="1">if len(missing) == 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, domain.ErrExchangeRateUnavailable
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package provider

import (
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "time"

        "github.com/amirasaad/fintech/pkg/cache"
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/provider"
)

// ExchangeRateAPIProvider implements the ExchangeRateProvider interface for exchangerate-api.com
// Updated to use v6 endpoint and config
type ExchangeRateAPIProvider struct {
        apiKey     string
        baseURL    string
        httpClient *http.Client
        logger     *slog.Logger
        timeout    time.Duration
}

// ExchangeRateAPIResponseV6 represents the v6 response from the ExchangeRate API
// See: https://www.exchangerate-api.com/docs/standard-requests
// Example: { "result": "success", "documentation": "...", "terms_of_use": "...", "time_last_update_unix": 1585267200, ... }
type ExchangeRateAPIResponseV6 struct {
        Result             string             `json:"result"`
        Documentation      string             `json:"documentation"`
        TermsOfUse         string             `json:"terms_of_use"`
        TimeLastUpdateUnix int64              `json:"time_last_update_unix"`
        TimeLastUpdateUTC  string             `json:"time_last_update_utc"`
        TimeNextUpdateUnix int64              `json:"time_next_update_unix"`
        TimeNextUpdateUTC  string             `json:"time_next_update_utc"`
        BaseCode           string             `json:"base_code"`
        ConversionRates    map[string]float64 `json:"conversion_rates"`
        // Error fields (if any)
        ErrorType string `json:"error-type,omitempty"`
}

// NewExchangeRateAPIProvider creates a new ExchangeRate API provider using config
func NewExchangeRateAPIProvider(cfg config.ExchangeRateConfig, logger *slog.Logger) *ExchangeRateAPIProvider <span class="cov0" title="0">{
        return &amp;ExchangeRateAPIProvider{
                apiKey:  cfg.ApiKey,
                baseURL: cfg.ApiUrl, // Should be like https://v6.exchangerate-api.com/v6
                httpClient: &amp;http.Client{
                        Timeout: cfg.HTTPTimeout,
                },
                logger:  logger,
                timeout: cfg.HTTPTimeout,
        }
}</span>

// FetchAndCacheRates fetches all rates for the base currency and caches them
func (p *ExchangeRateAPIProvider) FetchAndCacheRates(base string, cache cache.ExchangeRateCache, ttl time.Duration) error <span class="cov0" title="0">{
        // Check last update before fetching
        lastUpdate, err := cache.GetLastUpdate(base)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Warn("Could not check last update for exchange rates", "error", err)
        }</span>
        <span class="cov0" title="0">if !lastUpdate.IsZero() &amp;&amp; time.Since(lastUpdate) &lt; ttl </span><span class="cov0" title="0">{
                p.logger.Info("Exchange rates cache is still valid, skipping fetch", "base", base, "lastUpdate", lastUpdate)
                return nil
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s/%s/latest/%s", p.baseURL, p.apiKey, base)
        p.logger.Info("Fetching exchange rates from", "baseUrl", p.baseURL)

        resp, err := p.httpClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to fetch rates: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := resp.Body.Close(); cerr != nil </span><span class="cov0" title="0">{
                        p.logger.Warn("Failed to close response body", "error", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("API returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResp ExchangeRateAPIResponseV6
        if err := json.NewDecoder(resp.Body).Decode(&amp;apiResp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if apiResp.Result != "success" </span><span class="cov0" title="0">{
                return fmt.Errorf("API returned result=%s", apiResp.Result)
        }</span>

        // Cache each rate as base:to
        <span class="cov0" title="0">for to, rate := range apiResp.ConversionRates </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%s:%s", base, to)
                rateObj := &amp;domain.ExchangeRate{
                        FromCurrency: base,
                        ToCurrency:   to,
                        Rate:         rate,
                        LastUpdated:  time.Now(),
                        Source:       "exchangerate-api",
                        ExpiresAt:    time.Now().Add(ttl),
                }
                if err := cache.Set(key, rateObj, ttl); err != nil </span><span class="cov0" title="0">{
                        p.logger.Warn("Failed to cache exchange rate", "key", key, "error", err)
                }</span>
        }
        // Set last update for this base
        <span class="cov0" title="0">_ = cache.SetLastUpdate(base, time.Now())
        p.logger.Info("Exchange rates cached successfully", "base", base, "count", len(apiResp.ConversionRates))
        return nil</span>
}

// GetRate fetches the current exchange rate for a currency pair
func (p *ExchangeRateAPIProvider) GetRate(from, to string) (*domain.ExchangeRate, error) <span class="cov0" title="0">{
        // Update GetRate to use the v6 endpoint and response if needed, or rely on cache for POC
        // For now, we'll assume a simple call to the base URL with the API key
        url := fmt.Sprintf("%s/%s", p.baseURL, from)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">if p.apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+p.apiKey)
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := resp.Body.Close(); cerr != nil </span><span class="cov0" title="0">{
                        p.logger.Warn("Failed to close response body", "error", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResp ExchangeRateAPIResponseV6
        if err = json.NewDecoder(resp.Body).Decode(&amp;apiResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if apiResp.Result != "success" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned result=%s", apiResp.Result)
        }</span>

        <span class="cov0" title="0">rate, exists := apiResp.ConversionRates[to]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("currency %s not found in response", to)
        }</span>

        // Parse the date from the API response
        <span class="cov0" title="0">date, err := time.Parse("2006-01-02", "2006-01-02") // No date field in v6 response
        if err != nil </span><span class="cov0" title="0">{
                date = time.Now()
        }</span>

        <span class="cov0" title="0">return &amp;domain.ExchangeRate{
                FromCurrency: from,
                ToCurrency:   to,
                Rate:         rate,
                LastUpdated:  time.Now(),
                Source:       "exchangerate-api",
                ExpiresAt:    date.Add(24 * time.Hour), // Rates typically valid for 24 hours
        }, nil</span>
}

// GetRates fetches multiple exchange rates in a single request
func (p *ExchangeRateAPIProvider) GetRates(from string, to []string) (map[string]*domain.ExchangeRate, error) <span class="cov0" title="0">{
        // For this provider, we need to make a single request and extract the rates we need
        // We'll make a direct request to get all rates for the base currency

        // Since this provider returns all rates in one call, we need to make a full request
        url := fmt.Sprintf("%s/%s", p.baseURL, from)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">if p.apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+p.apiKey)
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := resp.Body.Close(); cerr != nil </span><span class="cov0" title="0">{
                        p.logger.Warn("Failed to close response body", "error", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResp ExchangeRateAPIResponseV6
        if err = json.NewDecoder(resp.Body).Decode(&amp;apiResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if apiResp.Result != "success" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned result=%s", apiResp.Result)
        }</span>

        // Parse the date from the API response
        <span class="cov0" title="0">date, err := time.Parse("2006-01-02", "2006-01-02") // No date field in v6 response
        if err != nil </span><span class="cov0" title="0">{
                date = time.Now()
        }</span>

        <span class="cov0" title="0">results := make(map[string]*domain.ExchangeRate)
        for _, currency := range to </span><span class="cov0" title="0">{
                if rate, exists := apiResp.ConversionRates[currency]; exists </span><span class="cov0" title="0">{
                        results[currency] = &amp;domain.ExchangeRate{
                                FromCurrency: from,
                                ToCurrency:   currency,
                                Rate:         rate,
                                LastUpdated:  time.Now(),
                                Source:       "exchangerate-api",
                                ExpiresAt:    date.Add(24 * time.Hour),
                        }
                }</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// Name returns the provider's name
func (p *ExchangeRateAPIProvider) Name() string <span class="cov0" title="0">{
        return "exchangerate-api"
}</span>

// IsHealthy checks if the provider is currently available
func (p *ExchangeRateAPIProvider) IsHealthy() bool <span class="cov0" title="0">{
        // Make a simple health check request
        url := fmt.Sprintf("%s/USD", p.baseURL)
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if p.apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+p.apiKey)
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := resp.Body.Close(); cerr != nil </span><span class="cov0" title="0">{
                        p.logger.Warn("Failed to close response body", "error", cerr)
                }</span>
        }()

        <span class="cov0" title="0">return resp.StatusCode == http.StatusOK</span>
}

// Ensure ExchangeRateAPIProvider implements provider.ExchangeRateProvider
var _ provider.ExchangeRateProvider = (*ExchangeRateAPIProvider)(nil)
</pre>
		
		<pre class="file" id="file8" style="display: none">package provider

import (
        "github.com/amirasaad/fintech/pkg/domain"
)

// StubCurrencyConverter is a simple implementation that returns the same amount (1:1 conversion).
type StubCurrencyConverter struct {
        rates map[string]map[string]float64
}

// NewStubCurrencyConverter creates a new StubCurrencyConverter with an empty rates map.
func NewStubCurrencyConverter() *StubCurrencyConverter <span class="cov0" title="0">{
        return &amp;StubCurrencyConverter{rates: map[string]map[string]float64{
                "USD": {
                        "EUR": 0.84,
                        "GBP": 0.76,
                        "JPY": 0.0027,
                },
                "EUR": {
                        "USD": 1.19,
                        "GBP": 0.90,
                        "JPY": 0.0024,
                },
                "GBP": {
                        "USD": 1.32,
                        "EUR": 1.11,
                        "JPY": 0.0024,
                },
                "JPY": {
                        "USD": 0.0027,
                        "EUR": 0.0024,
                        "GBP": 0.0024,
                },
        }}
}</span>

func (s *StubCurrencyConverter) Convert(amount float64, from, to string) (*domain.ConversionInfo, error) <span class="cov0" title="0">{
        rate, exists := s.rates[from][to]
        if !exists </span><span class="cov0" title="0">{
                return nil, domain.ErrUnsupportedCurrencyPair
        }</span>
        <span class="cov0" title="0">return &amp;domain.ConversionInfo{
                OriginalAmount:    amount,
                OriginalCurrency:  from,
                ConvertedAmount:   amount * rate,
                ConvertedCurrency: to,
                ConversionRate:    rate,
        }, nil</span>
}

func (s *StubCurrencyConverter) GetRate(from, to string) (float64, error) <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return 1.0, nil
        }</span>
        <span class="cov0" title="0">rate, exists := s.rates[from][to]
        if !exists </span><span class="cov0" title="0">{
                return 0, domain.ErrUnsupportedCurrencyPair
        }</span>
        <span class="cov0" title="0">return rate, nil</span>
}

func (s *StubCurrencyConverter) IsSupported(from, to string) bool <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">_, exists := s.rates[from][to]
        return exists</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package repository

import (
        "context"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

// CleanGenericRepositoryImpl implements CleanGenericRepository for GORM
type CleanGenericRepositoryImpl[T any] struct {
        db *gorm.DB
}

// NewCleanGenericRepository creates a new clean generic repository
func NewCleanGenericRepository[T any](db *gorm.DB) repository.CleanGenericRepository[T] <span class="cov0" title="0">{
        return &amp;CleanGenericRepositoryImpl[T]{
                db: db,
        }
}</span>

// Create saves a new entity to the database
func (r *CleanGenericRepositoryImpl[T]) Create(ctx context.Context, entity *T) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(entity).Error
}</span>

// Get retrieves an entity by ID
func (r *CleanGenericRepositoryImpl[T]) Get(ctx context.Context, id uuid.UUID) (*T, error) <span class="cov0" title="0">{
        var entity T
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;entity).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;entity, nil</span>
}

// Update modifies an existing entity
func (r *CleanGenericRepositoryImpl[T]) Update(ctx context.Context, entity *T) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(entity).Error
}</span>

// Delete removes an entity by ID
func (r *CleanGenericRepositoryImpl[T]) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Where("id = ?", id).Delete(new(T)).Error
}</span>

// List retrieves all entities
func (r *CleanGenericRepositoryImpl[T]) List(ctx context.Context) ([]*T, error) <span class="cov0" title="0">{
        var entities []*T
        err := r.db.WithContext(ctx).Find(&amp;entities).Error
        return entities, err
}</span>

// FindBy retrieves entities matching the query
func (r *CleanGenericRepositoryImpl[T]) FindBy(ctx context.Context, query interface{}, args ...interface{}) ([]*T, error) <span class="cov0" title="0">{
        var entities []*T
        err := r.db.WithContext(ctx).Where(query, args...).Find(&amp;entities).Error
        return entities, err
}</span>

// FindOneBy retrieves a single entity matching the query
func (r *CleanGenericRepositoryImpl[T]) FindOneBy(ctx context.Context, query interface{}, args ...interface{}) (*T, error) <span class="cov0" title="0">{
        var entity T
        err := r.db.WithContext(ctx).Where(query, args...).First(&amp;entity).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;entity, nil</span>
}

// GORMTransactionManager implements TransactionManager for GORM
type GORMTransactionManager struct {
        db *gorm.DB
}

// NewGORMTransactionManager creates a new GORM transaction manager
func NewGORMTransactionManager(db *gorm.DB) repository.TransactionManager <span class="cov0" title="0">{
        return &amp;GORMTransactionManager{
                db: db,
        }
}</span>

// ExecuteInTransaction runs a function within a GORM transaction
func (tm *GORMTransactionManager) ExecuteInTransaction(ctx context.Context, fn func() error) error <span class="cov0" title="0">{
        return tm.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                return fn()
        }</span>)
}

// NewCleanUnitOfWorkWithGORM creates a new clean UOW with GORM implementation
func NewCleanUnitOfWorkWithGORM(db *gorm.DB) repository.CleanUnitOfWork <span class="cov0" title="0">{
        return repository.NewCleanUnitOfWork(
                NewCleanGenericRepository[account.Account](db),
                NewCleanGenericRepository[account.Transaction](db),
                NewCleanGenericRepository[user.User](db),
                NewGORMTransactionManager(db),
        )
}</span>

// Example usage:
//
// func main() {
//     db := // ... initialize GORM DB
//     uow := NewCleanUnitOfWorkWithGORM(db)
//
//     accountService := &amp;AccountService{
//         uow: uow,
//         converter: converter,
//         logger: logger,
//     }
//
//     // Use the service - no infrastructure coupling in business logic!
//     err := accountService.Deposit(userID, accountID, amount, currency)
// }
</pre>
		
		<pre class="file" id="file10" style="display: none">package repository

import (
        "errors"
        "time"

        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/amirasaad/fintech/pkg/utils"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type accountRepository struct {
        db *gorm.DB
}

func NewAccountRepository(db *gorm.DB) repository.AccountRepository <span class="cov8" title="1">{
        return &amp;accountRepository{db: db}
}</span>

func (r *accountRepository) Get(id uuid.UUID) (*account.Account, error) <span class="cov8" title="1">{
        var a account.Account
        result := r.db.First(&amp;a, id)
        if result.Error != nil </span><span class="cov8" title="1">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, account.ErrAccountNotFound
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }
        <span class="cov8" title="1">return account.NewAccountFromData(a.ID, a.UserID, a.Balance, a.Currency, a.CreatedAt, a.UpdatedAt), nil</span>
}

func (r *accountRepository) Create(a *account.Account) error <span class="cov0" title="0">{
        result := r.db.Create(a)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *accountRepository) Update(a *account.Account) error <span class="cov0" title="0">{
        // Use infra.Account for DB operations
        dbModel := Account{
                Model: gorm.Model{
                        CreatedAt: a.CreatedAt,
                        DeletedAt: gorm.DeletedAt{},
                        UpdatedAt: time.Now().UTC(),
                },
                ID:       a.ID,
                UserID:   a.UserID,
                Balance:  a.Balance,
                Currency: string(a.Currency),
        }
        result := r.db.Save(&amp;dbModel)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *accountRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.Delete(&amp;Account{}, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type transactionRepository struct {
        db *gorm.DB
}

func NewTransactionRepository(db *gorm.DB) repository.TransactionRepository <span class="cov8" title="1">{
        return &amp;transactionRepository{db: db}
}</span>

func (r *transactionRepository) Create(transaction *account.Transaction) error <span class="cov8" title="1">{
        // Convert domain transaction to GORM model
        dbTransaction := Transaction{
                Model: gorm.Model{
                        CreatedAt: transaction.CreatedAt,
                        UpdatedAt: transaction.CreatedAt,
                },
                ID:               transaction.ID,
                AccountID:        transaction.AccountID,
                UserID:           transaction.UserID,
                Amount:           transaction.Amount,
                Currency:         string(transaction.Currency),
                Balance:          transaction.Balance,
                OriginalAmount:   transaction.OriginalAmount,
                OriginalCurrency: transaction.OriginalCurrency,
                ConversionRate:   transaction.ConversionRate,
        }

        result := r.db.Create(&amp;dbTransaction)
        if result.Error != nil </span><span class="cov8" title="1">{
                return result.Error
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *transactionRepository) Get(
        id uuid.UUID,
) (
        *account.Transaction,
        error,
) <span class="cov0" title="0">{
        var t Transaction
        result := r.db.First(&amp;t, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, account.ErrAccountNotFound
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }
        <span class="cov0" title="0">return account.NewTransactionFromData(t.ID, t.UserID, t.AccountID, t.Amount, t.Balance, currency.Code(t.Currency), t.CreatedAt, t.OriginalAmount, t.OriginalCurrency, t.ConversionRate), nil</span>
}

func (r *transactionRepository) List(
        userID, accountID uuid.UUID,
) ([]*account.Transaction, error) <span class="cov0" title="0">{
        var dbTransactions []*Transaction
        result := r.db.Where("account_id = ? and user_id = ?", accountID, userID).Order("created_at desc").Limit(100).Find(&amp;dbTransactions)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">tx := make([]*account.Transaction, 0, len(dbTransactions))
        for _, t := range dbTransactions </span><span class="cov0" title="0">{
                tx = append(tx, account.NewTransactionFromData(t.ID, t.UserID, t.AccountID, t.Amount, t.Balance, currency.Code(t.Currency), t.CreatedAt, t.OriginalAmount, t.OriginalCurrency, t.ConversionRate))
        }</span>
        <span class="cov0" title="0">return tx, nil</span>
}

type userRepository struct {
        db *gorm.DB
}

// Valid implements repository.UserRepository.
func (u *userRepository) Valid(id uuid.UUID, password string) bool <span class="cov0" title="0">{
        var usr user.User
        result := u.db.Where("id = ?", id).First(&amp;usr)
        if result.Error != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // Compare the provided password with the stored hash
        <span class="cov0" title="0">return utils.CheckPasswordHash(password, usr.Password)</span>
}

// Create implements repository.UserRepository.
func (u *userRepository) Create(user *user.User) error <span class="cov8" title="1">{
        result := u.db.Create(user)
        if result.Error != nil </span><span class="cov8" title="1">{
                return result.Error
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Delete implements repository.UserRepository.
func (u *userRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        result := u.db.Delete(&amp;user.User{}, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Get implements repository.UserRepository.
func (u *userRepository) Get(id uuid.UUID) (*user.User, error) <span class="cov0" title="0">{
        var usr user.User
        result := u.db.First(&amp;usr, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, user.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }
        <span class="cov0" title="0">return &amp;usr, nil</span>
}

// GetByEmail implements repository.UserRepository.
func (u *userRepository) GetByEmail(email string) (*user.User, error) <span class="cov0" title="0">{
        var usr user.User
        result := u.db.Where("email = ?", email).First(&amp;usr)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, user.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }
        <span class="cov0" title="0">return &amp;usr, nil</span>
}

// GetByUsername implements repository.UserRepository.
func (u *userRepository) GetByUsername(username string) (*user.User, error) <span class="cov0" title="0">{
        var usr user.User
        result := u.db.Where("username = ?", username).First(&amp;usr)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, user.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }
        <span class="cov0" title="0">return &amp;usr, nil</span>
}

// Update implements repository.UserRepository.
func (u *userRepository) Update(user *user.User) error <span class="cov0" title="0">{
        result := u.db.Save(user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func NewUserRepository(db *gorm.DB) repository.UserRepository <span class="cov8" title="1">{
        return &amp;userRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package repository

import (
        "context"
        "fmt"
        "reflect"

        "github.com/amirasaad/fintech/pkg/repository"
        "gorm.io/gorm"
)

// UoW provides transaction boundary and repository access in one abstraction.
//
// Why is GetRepository part of UoW?
// - Ensures all repositories use the same DB session/transaction for true atomicity.
// - Keeps service code clean and focused on business logic.
// - Centralizes repository wiring and registry for maintainability.
// - Prevents accidental use of the wrong DB session (which would break transactionality).
// - Is idiomatic for Go UoW patterns and easy to mock in tests.
type UoW struct {
        db           *gorm.DB
        tx           *gorm.DB
        repoRegistry map[reflect.Type]func(*gorm.DB) interface{}
}

// NewUoW creates a new UoW for the given *gorm.DB.
func NewUoW(db *gorm.DB) *UoW <span class="cov8" title="1">{
        return &amp;UoW{
                db: db,
                repoRegistry: map[reflect.Type]func(*gorm.DB) interface{}{
                        reflect.TypeOf((*repository.AccountRepository)(nil)).Elem():     func(db *gorm.DB) interface{} </span><span class="cov8" title="1">{ return NewAccountRepository(db) }</span>,
                        reflect.TypeOf((*repository.TransactionRepository)(nil)).Elem(): func(db *gorm.DB) interface{} <span class="cov8" title="1">{ return NewTransactionRepository(db) }</span>,
                        reflect.TypeOf((*repository.UserRepository)(nil)).Elem():        func(db *gorm.DB) interface{} <span class="cov8" title="1">{ return NewUserRepository(db) }</span>,
                },
        }
}

// Do runs the given function in a transaction boundary, providing a UoW with repository access.
func (u *UoW) Do(ctx context.Context, fn func(uow repository.UnitOfWork) error) error <span class="cov8" title="1">{
        return u.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                txnUow := &amp;UoW{db: u.db, tx: tx, repoRegistry: u.repoRegistry}
                return fn(txnUow)
        }</span>)
}

// GetRepository provides generic, type-safe access to repositories using the transaction session.
//
// This method is part of UoW to guarantee that all repository operations within a transaction
// use the same DB session, ensuring atomicity and consistency. It also centralizes repository
// construction and makes testing and extension easier.
func (u *UoW) GetRepository(repoType reflect.Type) (any, error) <span class="cov8" title="1">{
        constructor, ok := u.repoRegistry[repoType]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported repository type: %v", repoType)
        }</span>

        // Use transaction DB if available, otherwise use main DB
        <span class="cov8" title="1">dbToUse := u.tx
        if dbToUse == nil </span><span class="cov0" title="0">{
                dbToUse = u.db
        }</span>

        <span class="cov8" title="1">repo := constructor(dbToUse)
        return repo, nil</span>
}

// Type-safe repository access methods (convenience methods)

// AccountRepository returns the account repository bound to the current transaction
func (u *UoW) AccountRepository() (repository.AccountRepository, error) <span class="cov0" title="0">{
        repoAny, err := u.GetRepository(reflect.TypeOf((*repository.AccountRepository)(nil)).Elem())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return repoAny.(repository.AccountRepository), nil</span>
}

// TransactionRepository returns the transaction repository bound to the current transaction
func (u *UoW) TransactionRepository() (repository.TransactionRepository, error) <span class="cov0" title="0">{
        repoAny, err := u.GetRepository(reflect.TypeOf((*repository.TransactionRepository)(nil)).Elem())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return repoAny.(repository.TransactionRepository), nil</span>
}

// UserRepository returns the user repository bound to the current transaction
func (u *UoW) UserRepository() (repository.UserRepository, error) <span class="cov0" title="0">{
        repoAny, err := u.GetRepository(reflect.TypeOf((*repository.UserRepository)(nil)).Elem())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return repoAny.(repository.UserRepository), nil</span>
}

// ---
// Sample mock for tests:
//
// type MockUnitOfWork struct {
//     DoFunc func(ctx context.Context, fn func(uow UnitOfWork) error) error
//     GetRepositoryFunc func(repoType any) (any, error)
// }
//
// func (m *MockUnitOfWork) Do(ctx context.Context, fn func(uow UnitOfWork) error) error {
//     if m.DoFunc != nil { return m.DoFunc(ctx, fn) }
//     return fn(m)
// }
// func (m *MockUnitOfWork) GetRepository(repoType reflect.Type) (any, error) {
//     if m.GetRepositoryFunc != nil {
//         return m.GetRepositoryFunc(repoType)
//     }
//     return nil, nil
// }
</pre>
		
		<pre class="file" id="file12" style="display: none">package repository

import (
        "context"
        "fmt"

        "github.com/amirasaad/fintech/pkg/repository"
        "gorm.io/gorm"
)

// StringBasedUnitOfWork defines the contract for transactional work using string-based repository names.
type StringBasedUnitOfWork interface {
        // Do executes the given function within a transaction boundary.
        Do(ctx context.Context, fn func(uow StringBasedUnitOfWork) error) error

        // GetRepository returns a repository by name, bound to the current transaction/session.
        GetRepository(repoName string) (any, error)

        // Type-safe convenience methods
        AccountRepository() (repository.AccountRepository, error)
        TransactionRepository() (repository.TransactionRepository, error)
        UserRepository() (repository.UserRepository, error)
}

// Repository constants for type safety
const (
        AccountRepositoryName     = "account"
        TransactionRepositoryName = "transaction"
        UserRepositoryName        = "user"
)

// StringBasedUoW provides transaction boundary and repository access using string names.
type StringBasedUoW struct {
        db           *gorm.DB
        tx           *gorm.DB
        repoRegistry map[string]func(*gorm.DB) interface{}
}

// NewStringBasedUoW creates a new string-based UoW for the given *gorm.DB.
func NewStringBasedUoW(db *gorm.DB) *StringBasedUoW <span class="cov0" title="0">{
        return &amp;StringBasedUoW{
                db: db,
                repoRegistry: map[string]func(*gorm.DB) interface{}{
                        AccountRepositoryName:     func(db *gorm.DB) interface{} </span><span class="cov0" title="0">{ return NewAccountRepository(db) }</span>,
                        TransactionRepositoryName: func(db *gorm.DB) interface{} <span class="cov0" title="0">{ return NewTransactionRepository(db) }</span>,
                        UserRepositoryName:        func(db *gorm.DB) interface{} <span class="cov0" title="0">{ return NewUserRepository(db) }</span>,
                },
        }
}

// Do runs the given function in a transaction boundary.
func (u *StringBasedUoW) Do(ctx context.Context, fn func(uow StringBasedUnitOfWork) error) error <span class="cov0" title="0">{
        return u.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                txnUow := &amp;StringBasedUoW{db: u.db, tx: tx, repoRegistry: u.repoRegistry}
                return fn(txnUow)
        }</span>)
}

// GetRepository provides access to repositories using string names.
func (u *StringBasedUoW) GetRepository(repoName string) (any, error) <span class="cov0" title="0">{
        constructor, ok := u.repoRegistry[repoName]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported repository name: %s", repoName)
        }</span>
        <span class="cov0" title="0">repo := constructor(u.tx)
        return repo, nil</span>
}

// Type-safe repository access methods

// AccountRepository returns the account repository bound to the current transaction
func (u *StringBasedUoW) AccountRepository() (repository.AccountRepository, error) <span class="cov0" title="0">{
        repoAny, err := u.GetRepository(AccountRepositoryName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return repoAny.(repository.AccountRepository), nil</span>
}

// TransactionRepository returns the transaction repository bound to the current transaction
func (u *StringBasedUoW) TransactionRepository() (repository.TransactionRepository, error) <span class="cov0" title="0">{
        repoAny, err := u.GetRepository(TransactionRepositoryName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return repoAny.(repository.TransactionRepository), nil</span>
}

// UserRepository returns the user repository bound to the current transaction
func (u *StringBasedUoW) UserRepository() (repository.UserRepository, error) <span class="cov0" title="0">{
        repoAny, err := u.GetRepository(UserRepositoryName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return repoAny.(repository.UserRepository), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package config

import (
        "log/slog"
        "regexp"
        "time"

        "github.com/joho/godotenv"
        "github.com/kelseyhightower/envconfig"
)

type DBConfig struct {
        Url string `envconfig:"URL" default:"postgres://postgres:password@localhost:5432/fintech?sslmode=disable"`
}

type AuthConfig struct {
        Strategy string `envconfig:"STRATEGY" default:"jwt"`
}
type JwtConfig struct {
        Secret string        `envconfig:"SECRET_KEY" required:"true"`
        Expiry time.Duration `envconfig:"EXPIRY" default:"24h"`
}

type RedisConfig struct {
        URL string `envconfig:"REDIS_URL" default:"redis://localhost:6379/0"`
}

type ExchangeRateConfig struct {
        ApiKey            string        `envconfig:"API_KEY"`
        ApiUrl            string        `envconfig:"API_URL" default:"https://api.exchangerate-api.com/v4/latest"`
        CacheTTL          time.Duration `envconfig:"CACHE_TTL" default:"15m"`
        HTTPTimeout       time.Duration `envconfig:"HTTP_TIMEOUT" default:"10s"`
        MaxRetries        int           `envconfig:"MAX_RETRIES" default:"3"`
        RequestsPerMinute int           `envconfig:"REQUESTS_PER_MINUTE" default:"60"`
        BurstSize         int           `envconfig:"BURST_SIZE" default:"10"`
        EnableFallback    bool          `envconfig:"ENABLE_FALLBACK" default:"true"`
        FallbackTTL       time.Duration `envconfig:"FALLBACK_TTL" default:"1h"`
        CachePrefix       string        `envconfig:"CACHE_PREFIX" default:"exr:rate:"`
}

type AppConfig struct {
        Env      string             `envconfig:"APP_ENV" default:"development"`
        Host     string             `envconfig:"APP_HOST" default:"localhost"`
        Port     int                `envconfig:"APP_PORT" default:"3000"`
        DB       DBConfig           `envconfig:"DATABASE"`
        Auth     AuthConfig         `envconfig:"AUTH"`
        Jwt      JwtConfig          `envconfig:"JWT"`
        Exchange ExchangeRateConfig `envconfig:"EXCHANGE_RATE"`
        Redis    RedisConfig        `envconfig:"REDIS"`
}

func maskApiKey(key string) string <span class="cov0" title="0">{
        if len(key) &lt;= 6 </span><span class="cov0" title="0">{
                return "****"
        }</span>
        <span class="cov0" title="0">return key[:2] + "****" + key[len(key)-4:]</span>
}

func maskApiKeyInUrl(url string) string <span class="cov0" title="0">{
        // Mask /v6/&lt;key&gt; in path
        re := regexp.MustCompile(`(v6/)[^/]+`)
        masked := re.ReplaceAllString(url, `${1}[MASKED]`)
        // Mask api_key in query string
        qre := regexp.MustCompile(`([?&amp;]api_key=)[^&amp;]+`)
        masked = qre.ReplaceAllString(masked, `${1}[MASKED]`)
        return masked
}</span>

func LoadAppConfig(logger *slog.Logger, envFilePath ...string) (*AppConfig, error) <span class="cov0" title="0">{
        var err error
        if len(envFilePath) &gt; 0 &amp;&amp; envFilePath[0] != "" </span><span class="cov0" title="0">{
                err = godotenv.Load(envFilePath[0])
        }</span> else<span class="cov0" title="0"> {
                err = godotenv.Load()
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Warn("No .env file found or specified, using system environment variables")
        }</span> else<span class="cov0" title="0"> {
                logger.Info("Environment variables loaded from .env file")
        }</span>
        <span class="cov0" title="0">var cfg AppConfig
        if err := envconfig.Process("", &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">logger.Info("App config loaded",
                "db", cfg.DB.Url,
                "jwt_expiry", cfg.Jwt.Expiry,
                "exchange_cache_ttl", cfg.Exchange.CacheTTL,
                "exchange_api_url", maskApiKeyInUrl(cfg.Exchange.ApiUrl),
                "exchange_api_key", maskApiKey(cfg.Exchange.ApiKey),
        )
        return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package config

import (
        "log/slog"
        "os"
        "strconv"
        "time"

        "github.com/joho/godotenv"
)

// LoadEnv loads environment variables from .env file
// If .env file is not found, it logs a warning and continues
func LoadEnv(logger *slog.Logger) <span class="cov8" title="1">{
        if err := godotenv.Load(); err != nil </span><span class="cov8" title="1">{
                logger.Warn("No .env file found, using system environment variables")
        }</span> else<span class="cov0" title="0"> {
                logger.Info("Environment variables loaded from .env file")
        }</span>
}

// GetEnv retrieves an environment variable with a default value
func GetEnv(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

// GetEnvRequired retrieves a required environment variable
// Panics if the environment variable is not set
func GetEnvRequired(key string) string <span class="cov8" title="1">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov8" title="1">{
                panic("Required environment variable " + key + " is not set")</span>
        }
        <span class="cov8" title="1">return value</span>
}

// IsEnvSet checks if an environment variable is set
func IsEnvSet(key string) bool <span class="cov8" title="1">{
        return os.Getenv(key) != ""
}</span>

// GetEnvAsInt retrieves an environment variable as int with a default value
func GetEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

// GetEnvAsBool retrieves an environment variable as bool with a default value
func GetEnvAsBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

// GetEnvAsDuration retrieves an environment variable as time.Duration with a default value
func GetEnvAsDuration(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package currency

import (
        "context"
        "errors"
        "fmt"
        "regexp"
        "strconv"
        "time"

        "github.com/amirasaad/fintech/pkg/registry"
)

// Common errors
var (
        ErrInvalidCurrencyCode = errors.New("invalid currency code: must be 3 uppercase letters")
        ErrInvalidDecimals     = errors.New("invalid decimals: must be between 0 and 8")
        ErrInvalidSymbol       = errors.New("invalid symbol: must not be empty and max 10 characters")
        ErrCurrencyNotFound    = errors.New("currency not found")
        ErrCurrencyExists      = errors.New("currency already exists")
)

const (
        // DefaultCurrency is the fallback currency code (USD)
        DefaultCurrency = "USD"
        // DefaultDecimals is the default number of decimal places for currencies
        DefaultDecimals = 2
        // MaxDecimals is the maximum number of decimal places allowed
        MaxDecimals = 8
        // MaxSymbolLength is the maximum length for currency symbols
        MaxSymbolLength = 10

        USD = Code("USD")
        EUR = Code("EUR")
)

// Code represents a 3-letter ISO currency code
type Code string

// CurrencyMeta holds currency-specific metadata
type CurrencyMeta struct {
        Code     string            `json:"code"`
        Name     string            `json:"name"`
        Symbol   string            `json:"symbol"`
        Decimals int               `json:"decimals"`
        Country  string            `json:"country,omitempty"`
        Region   string            `json:"region,omitempty"`
        Active   bool              `json:"active"`
        Metadata map[string]string `json:"metadata,omitempty"`
        Created  time.Time         `json:"created"`
        Updated  time.Time         `json:"updated"`
}

// CurrencyEntity implements the registry.Entity interface
type CurrencyEntity struct {
        *registry.BaseEntity
        meta CurrencyMeta
}

// NewCurrencyEntity creates a new currency entity
func NewCurrencyEntity(meta CurrencyMeta) *CurrencyEntity <span class="cov8" title="1">{
        now := time.Now()
        meta.Created = now
        meta.Updated = now

        return &amp;CurrencyEntity{
                BaseEntity: registry.NewBaseEntity(meta.Code, meta.Name),
                meta:       meta,
        }
}</span>

// Code returns the currency code
func (c *CurrencyEntity) Code() string <span class="cov8" title="1">{
        return c.meta.Code
}</span>

// Name returns the currency name
func (c *CurrencyEntity) Name() string <span class="cov8" title="1">{
        return c.meta.Name
}</span>

// Active returns whether the currency is active
func (c *CurrencyEntity) Active() bool <span class="cov8" title="1">{
        return c.meta.Active
}</span>

// Metadata returns currency metadata
func (c *CurrencyEntity) Metadata() map[string]string <span class="cov8" title="1">{
        metadata := c.BaseEntity.Metadata()
        metadata["code"] = c.meta.Code
        metadata["symbol"] = c.meta.Symbol
        metadata["decimals"] = strconv.Itoa(c.meta.Decimals)
        metadata["country"] = c.meta.Country
        metadata["region"] = c.meta.Region
        metadata["active"] = strconv.FormatBool(c.meta.Active)
        metadata["created"] = c.meta.Created.Format(time.RFC3339)
        metadata["updated"] = c.meta.Updated.Format(time.RFC3339)

        // Add custom metadata
        for k, v := range c.meta.Metadata </span><span class="cov8" title="1">{
                metadata[k] = v
        }</span>

        <span class="cov8" title="1">return metadata</span>
}

// CreatedAt returns the creation timestamp
func (c *CurrencyEntity) CreatedAt() time.Time <span class="cov8" title="1">{
        return c.meta.Created
}</span>

// UpdatedAt returns the last update timestamp
func (c *CurrencyEntity) UpdatedAt() time.Time <span class="cov8" title="1">{
        return c.meta.Updated
}</span>

// Meta returns the currency metadata
func (c *CurrencyEntity) Meta() CurrencyMeta <span class="cov8" title="1">{
        return c.meta
}</span>

// CurrencyValidator implements registry.RegistryValidator for currency entities
type CurrencyValidator struct{}

// NewCurrencyValidator creates a new currency validator
func NewCurrencyValidator() *CurrencyValidator <span class="cov8" title="1">{
        return &amp;CurrencyValidator{}
}</span>

// Validate validates a currency entity
func (cv *CurrencyValidator) Validate(ctx context.Context, entity registry.Entity) error <span class="cov8" title="1">{
        // Try to convert to CurrencyEntity first
        if currencyEntity, ok := entity.(*CurrencyEntity); ok </span><span class="cov8" title="1">{
                return validateCurrencyMeta(currencyEntity.Meta())
        }</span>

        // If it's not a CurrencyEntity, try to validate using metadata
        // This handles cases where the entity might be a BaseEntity or other type
        <span class="cov8" title="1">metadata := entity.Metadata()
        if len(metadata) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid entity type: expected *CurrencyEntity or entity with metadata")
        }</span>

        // Validate required metadata fields
        <span class="cov8" title="1">requiredFields := []string{"code", "symbol", "decimals"}
        for _, field := range requiredFields </span><span class="cov8" title="1">{
                if value, exists := metadata[field]; !exists || value == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("required metadata field missing: %s", field)
                }</span>
        }

        // Validate currency code format
        <span class="cov8" title="1">if code, exists := metadata["code"]; exists </span><span class="cov8" title="1">{
                if !isValidCurrencyCode(code) </span><span class="cov0" title="0">{
                        return ErrInvalidCurrencyCode
                }</span>
        }

        // Validate decimals
        <span class="cov8" title="1">if decimalsStr, exists := metadata["decimals"]; exists </span><span class="cov8" title="1">{
                if decimals, err := strconv.Atoi(decimalsStr); err != nil </span><span class="cov0" title="0">{
                        return ErrInvalidDecimals
                }</span> else<span class="cov8" title="1"> if decimals &lt; 0 || decimals &gt; MaxDecimals </span><span class="cov0" title="0">{
                        return ErrInvalidDecimals
                }</span>
        }

        // Validate symbol
        <span class="cov8" title="1">if symbol, exists := metadata["symbol"]; exists </span><span class="cov8" title="1">{
                if symbol == "" || len(symbol) &gt; MaxSymbolLength </span><span class="cov0" title="0">{
                        return ErrInvalidSymbol
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateMetadata validates currency metadata
func (cv *CurrencyValidator) ValidateMetadata(ctx context.Context, metadata map[string]string) error <span class="cov8" title="1">{
        // Validate required metadata fields
        requiredFields := []string{"code", "symbol", "decimals"}
        for _, field := range requiredFields </span><span class="cov8" title="1">{
                if value, exists := metadata[field]; !exists || value == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("required metadata field missing: %s", field)
                }</span>
        }

        // Validate currency code format
        <span class="cov8" title="1">if code, exists := metadata["code"]; exists </span><span class="cov8" title="1">{
                if !isValidCurrencyCode(code) </span><span class="cov8" title="1">{
                        return ErrInvalidCurrencyCode
                }</span>
        }

        // Validate decimals
        <span class="cov8" title="1">if decimalsStr, exists := metadata["decimals"]; exists </span><span class="cov8" title="1">{
                if decimals, err := strconv.Atoi(decimalsStr); err != nil </span><span class="cov8" title="1">{
                        return ErrInvalidDecimals
                }</span> else<span class="cov8" title="1"> if decimals &lt; 0 || decimals &gt; MaxDecimals </span><span class="cov0" title="0">{
                        return ErrInvalidDecimals
                }</span>
        }

        // Validate symbol
        <span class="cov8" title="1">if symbol, exists := metadata["symbol"]; exists </span><span class="cov8" title="1">{
                if symbol == "" || len(symbol) &gt; MaxSymbolLength </span><span class="cov0" title="0">{
                        return ErrInvalidSymbol
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateCurrencyMeta validates currency metadata
func validateCurrencyMeta(meta CurrencyMeta) error <span class="cov8" title="1">{
        // Validate currency code format
        if !isValidCurrencyCode(meta.Code) </span><span class="cov8" title="1">{
                return ErrInvalidCurrencyCode
        }</span>

        // Validate decimals
        <span class="cov8" title="1">if meta.Decimals &lt; 0 || meta.Decimals &gt; MaxDecimals </span><span class="cov8" title="1">{
                return ErrInvalidDecimals
        }</span>

        // Validate symbol
        <span class="cov8" title="1">if meta.Symbol == "" || len(meta.Symbol) &gt; MaxSymbolLength </span><span class="cov8" title="1">{
                return ErrInvalidSymbol
        }</span>

        // Validate name
        <span class="cov8" title="1">if meta.Name == "" </span><span class="cov8" title="1">{
                return errors.New("currency name cannot be empty")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsValidCurrencyFormat returns true if the code is a well-formed ISO 4217 currency code (3 uppercase letters).
func IsValidCurrencyFormat(code string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^[A-Z]{3}$`)
        return re.MatchString(code)
}</span>

// isValidCurrencyCode checks if a currency code is valid (3 uppercase letters)
func isValidCurrencyCode(code string) bool <span class="cov8" title="1">{
        return IsValidCurrencyFormat(code)
}</span>

// CurrencyRegistry provides currency-specific operations using the registry system
type CurrencyRegistry struct {
        registry registry.RegistryProvider
        ctx      context.Context
}

// NewCurrencyRegistry creates a new currency registry with default currencies
func NewCurrencyRegistry(ctx context.Context) (*CurrencyRegistry, error) <span class="cov8" title="1">{
        // Create registry with currency-specific configuration
        config := registry.RegistryConfig{
                Name:             "currency-registry",
                MaxEntities:      1000,
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         10 * time.Minute,
        }

        reg := registry.NewEnhancedRegistry(config)
        reg.WithValidator(NewCurrencyValidator())
        reg.WithCache(registry.NewMemoryCache(10 * time.Minute))

        cr := &amp;CurrencyRegistry{
                registry: reg,
                ctx:      ctx,
        }

        // Register default currencies
        if err := cr.registerDefaults(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to register default currencies: %w", err)
        }</span>

        <span class="cov8" title="1">return cr, nil</span>
}

// NewCurrencyRegistryWithPersistence creates a currency registry with persistence
func NewCurrencyRegistryWithPersistence(ctx context.Context, persistencePath string) (*CurrencyRegistry, error) <span class="cov0" title="0">{
        config := registry.RegistryConfig{
                Name:              "currency-registry",
                MaxEntities:       1000,
                EnableEvents:      true,
                EnableValidation:  true,
                CacheSize:         100,
                CacheTTL:          10 * time.Minute,
                EnablePersistence: true,
                PersistencePath:   persistencePath,
                AutoSaveInterval:  time.Minute,
        }

        reg := registry.NewEnhancedRegistry(config)
        reg.WithValidator(NewCurrencyValidator())
        reg.WithCache(registry.NewMemoryCache(10 * time.Minute))

        // Add persistence
        persistence := registry.NewFilePersistence(persistencePath)
        reg.WithPersistence(persistence)

        cr := &amp;CurrencyRegistry{
                registry: reg,
                ctx:      ctx,
        }

        // Load existing currencies from persistence
        entities, err := persistence.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load currencies from persistence: %w", err)
        }</span>

        // Register loaded currencies
        <span class="cov0" title="0">for _, entity := range entities </span><span class="cov0" title="0">{
                if err := reg.Register(ctx, entity); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to register loaded currency: %w", err)
                }</span>
        }

        // If no currencies were loaded, register defaults
        <span class="cov0" title="0">if len(entities) == 0 </span><span class="cov0" title="0">{
                if err := cr.registerDefaults(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to register default currencies: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return cr, nil</span>
}

// registerDefaults registers the default set of currencies
func (cr *CurrencyRegistry) registerDefaults() error <span class="cov8" title="1">{
        defaultCurrencies := []CurrencyMeta{
                {Code: "USD", Name: "US Dollar", Symbol: "$", Decimals: 2, Country: "United States", Region: "North America", Active: true},
                {Code: "EUR", Name: "Euro", Symbol: "€", Decimals: 2, Country: "European Union", Region: "Europe", Active: true},
                {Code: "GBP", Name: "British Pound", Symbol: "£", Decimals: 2, Country: "United Kingdom", Region: "Europe", Active: true},
                {Code: "JPY", Name: "Japanese Yen", Symbol: "¥", Decimals: 0, Country: "Japan", Region: "Asia", Active: true},
                {Code: "CAD", Name: "Canadian Dollar", Symbol: "C$", Decimals: 2, Country: "Canada", Region: "North America", Active: true},
                {Code: "AUD", Name: "Australian Dollar", Symbol: "A$", Decimals: 2, Country: "Australia", Region: "Oceania", Active: true},
                {Code: "CHF", Name: "Swiss Franc", Symbol: "CHF", Decimals: 2, Country: "Switzerland", Region: "Europe", Active: true},
                {Code: "CNY", Name: "Chinese Yuan", Symbol: "¥", Decimals: 2, Country: "China", Region: "Asia", Active: true},
                {Code: "INR", Name: "Indian Rupee", Symbol: "₹", Decimals: 2, Country: "India", Region: "Asia", Active: true},
                {Code: "BRL", Name: "Brazilian Real", Symbol: "R$", Decimals: 2, Country: "Brazil", Region: "South America", Active: true},
                {Code: "KWD", Name: "Kuwaiti Dinar", Symbol: "د.ك", Decimals: 3, Country: "Kuwait", Region: "Middle East", Active: true},
                {Code: "EGP", Name: "Egyptian Pound", Symbol: "£", Decimals: 2, Country: "Egypt", Region: "Africa", Active: true},
        }

        for _, meta := range defaultCurrencies </span><span class="cov8" title="1">{
                if err := cr.Register(meta); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to register %s: %w", meta.Code, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Register adds or updates a currency in the registry
func (cr *CurrencyRegistry) Register(meta CurrencyMeta) error <span class="cov8" title="1">{
        // Validate currency metadata
        if err := validateCurrencyMeta(meta); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        // Create currency entity
        <span class="cov8" title="1">entity := NewCurrencyEntity(meta)

        // Register with the registry
        if err := cr.registry.Register(cr.ctx, entity); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register currency: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Get returns currency metadata for the given code
func (cr *CurrencyRegistry) Get(code string) (CurrencyMeta, error) <span class="cov8" title="1">{
        entity, err := cr.registry.Get(cr.ctx, code)
        if err != nil </span><span class="cov8" title="1">{
                return CurrencyMeta{}, fmt.Errorf("currency not found: %w", err)
        }</span>

        // Convert entity back to currency metadata
        <span class="cov8" title="1">currencyEntity, ok := entity.(*CurrencyEntity)
        if !ok </span><span class="cov0" title="0">{
                // Fallback: try to convert from BaseEntity
                metadata := entity.Metadata()
                decimals, _ := strconv.Atoi(metadata["decimals"])
                active, _ := strconv.ParseBool(metadata["active"])

                return CurrencyMeta{
                        Code:     metadata["code"],
                        Name:     entity.Name(),
                        Symbol:   metadata["symbol"],
                        Decimals: decimals,
                        Country:  metadata["country"],
                        Region:   metadata["region"],
                        Active:   active,
                }, nil
        }</span>

        <span class="cov8" title="1">return currencyEntity.Meta(), nil</span>
}

// IsSupported checks if a currency code is registered and active
func (cr *CurrencyRegistry) IsSupported(code string) bool <span class="cov8" title="1">{
        if !cr.registry.IsRegistered(cr.ctx, code) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">entity, err := cr.registry.Get(cr.ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if ce, ok := entity.(*CurrencyEntity); ok </span><span class="cov8" title="1">{
                return ce.Active()
        }</span> else<span class="cov8" title="1"> {
                return entity.Active()
        }</span>
}

// ListSupported returns a list of all supported currency codes
func (cr *CurrencyRegistry) ListSupported() ([]string, error) <span class="cov8" title="1">{
        entities, err := cr.registry.ListActive(cr.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list currencies: %w", err)
        }</span>

        <span class="cov8" title="1">codes := make([]string, len(entities))
        for i, entity := range entities </span><span class="cov8" title="1">{
                if ce, ok := entity.(*CurrencyEntity); ok </span><span class="cov8" title="1">{
                        codes[i] = ce.Code()
                }</span> else<span class="cov0" title="0"> {
                        codes[i] = entity.ID()
                }</span>
        }

        <span class="cov8" title="1">return codes, nil</span>
}

// ListAll returns all registered currencies (active and inactive)
func (cr *CurrencyRegistry) ListAll() ([]CurrencyMeta, error) <span class="cov8" title="1">{
        entities, err := cr.registry.List(cr.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list currencies: %w", err)
        }</span>

        <span class="cov8" title="1">currencies := make([]CurrencyMeta, len(entities))
        for i, entity := range entities </span><span class="cov8" title="1">{
                if currencyEntity, ok := entity.(*CurrencyEntity); ok </span><span class="cov8" title="1">{
                        currencies[i] = currencyEntity.Meta()
                }</span> else<span class="cov0" title="0"> {
                        // Fallback conversion
                        metadata := entity.Metadata()
                        decimals, _ := strconv.Atoi(metadata["decimals"])
                        active, _ := strconv.ParseBool(metadata["active"])

                        currencies[i] = CurrencyMeta{
                                Code:     metadata["code"],
                                Name:     entity.Name(),
                                Symbol:   metadata["symbol"],
                                Decimals: decimals,
                                Country:  metadata["country"],
                                Region:   metadata["region"],
                                Active:   active,
                        }
                }</span>
        }

        <span class="cov8" title="1">return currencies, nil</span>
}

// Unregister removes a currency from the registry
func (cr *CurrencyRegistry) Unregister(code string) error <span class="cov8" title="1">{
        if err := cr.registry.Unregister(cr.ctx, code); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unregister currency: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Activate activates a currency
func (cr *CurrencyRegistry) Activate(code string) error <span class="cov8" title="1">{
        if err := cr.registry.Activate(cr.ctx, code); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to activate currency: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Deactivate deactivates a currency
func (cr *CurrencyRegistry) Deactivate(code string) error <span class="cov8" title="1">{
        if err := cr.registry.Deactivate(cr.ctx, code); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deactivate currency: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Count returns the total number of registered currencies
func (cr *CurrencyRegistry) Count() (int, error) <span class="cov8" title="1">{
        return cr.registry.Count(cr.ctx)
}</span>

// CountActive returns the number of active currencies
func (cr *CurrencyRegistry) CountActive() (int, error) <span class="cov8" title="1">{
        return cr.registry.CountActive(cr.ctx)
}</span>

// Search searches for currencies by name
func (cr *CurrencyRegistry) Search(query string) ([]CurrencyMeta, error) <span class="cov8" title="1">{
        entities, err := cr.registry.Search(cr.ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search currencies: %w", err)
        }</span>

        <span class="cov8" title="1">currencies := make([]CurrencyMeta, len(entities))
        for i, entity := range entities </span><span class="cov8" title="1">{
                if currencyEntity, ok := entity.(*CurrencyEntity); ok </span><span class="cov8" title="1">{
                        currencies[i] = currencyEntity.Meta()
                }</span>
        }

        <span class="cov8" title="1">return currencies, nil</span>
}

// SearchByRegion searches for currencies by region
func (cr *CurrencyRegistry) SearchByRegion(region string) ([]CurrencyMeta, error) <span class="cov8" title="1">{
        entities, err := cr.registry.SearchByMetadata(cr.ctx, map[string]string{"region": region})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search currencies by region: %w", err)
        }</span>

        <span class="cov8" title="1">currencies := make([]CurrencyMeta, len(entities))
        for i, entity := range entities </span><span class="cov8" title="1">{
                if currencyEntity, ok := entity.(*CurrencyEntity); ok </span><span class="cov8" title="1">{
                        currencies[i] = currencyEntity.Meta()
                }</span>
        }

        <span class="cov8" title="1">return currencies, nil</span>
}

// GetRegistry returns the underlying registry provider
func (cr *CurrencyRegistry) GetRegistry() registry.RegistryProvider <span class="cov0" title="0">{
        return cr.registry
}</span>

// Global currency registry instance
var globalCurrencyRegistry *CurrencyRegistry

// Initialize global registry
func init() <span class="cov8" title="1">{
        var err error
        globalCurrencyRegistry, err = NewCurrencyRegistry(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to initialize global currency registry: %v", err))</span>
        }
}

// Global convenience functions with error handling
func Register(meta CurrencyMeta) error <span class="cov8" title="1">{
        return globalCurrencyRegistry.Register(meta)
}</span>

func Get(code string) (CurrencyMeta, error) <span class="cov8" title="1">{
        return globalCurrencyRegistry.Get(code)
}</span>

func IsSupported(code string) bool <span class="cov8" title="1">{
        return globalCurrencyRegistry.IsSupported(code)
}</span>

func ListSupported() ([]string, error) <span class="cov8" title="1">{
        return globalCurrencyRegistry.ListSupported()
}</span>

func ListAll() ([]CurrencyMeta, error) <span class="cov0" title="0">{
        return globalCurrencyRegistry.ListAll()
}</span>

func Unregister(code string) error <span class="cov8" title="1">{
        return globalCurrencyRegistry.Unregister(code)
}</span>

func Count() (int, error) <span class="cov8" title="1">{
        return globalCurrencyRegistry.Count()
}</span>

func CountActive() (int, error) <span class="cov0" title="0">{
        return globalCurrencyRegistry.CountActive()
}</span>

func Search(query string) ([]CurrencyMeta, error) <span class="cov8" title="1">{
        return globalCurrencyRegistry.Search(query)
}</span>

func SearchByRegion(region string) ([]CurrencyMeta, error) <span class="cov0" title="0">{
        return globalCurrencyRegistry.SearchByRegion(region)
}</span>

// Backward compatibility functions (deprecated)
func RegisterLegacy(code string, meta CurrencyMeta) <span class="cov8" title="1">{
        // Convert legacy format to new format
        newMeta := CurrencyMeta{
                Code:     code,
                Name:     code,
                Symbol:   meta.Symbol,
                Decimals: meta.Decimals,
                Active:   true,
        }

        if err := Register(newMeta); err != nil </span><span class="cov0" title="0">{
                // Log error but don't panic for backward compatibility
                fmt.Printf("Warning: failed to register currency %s: %v\n", code, err)
        }</span>
}

func GetLegacy(code string) CurrencyMeta <span class="cov8" title="1">{
        meta, err := Get(code)
        if err != nil </span><span class="cov8" title="1">{
                // Return default for backward compatibility
                return CurrencyMeta{
                        Code:     code,
                        Name:     code,
                        Symbol:   code,
                        Decimals: DefaultDecimals,
                        Active:   false,
                }
        }</span>
        <span class="cov8" title="1">return meta</span>
}

func IsSupportedLegacy(code string) bool <span class="cov8" title="1">{
        return IsSupported(code)
}</span>

func ListSupportedLegacy() []string <span class="cov8" title="1">{
        codes, err := ListSupported()
        if err != nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov8" title="1">return codes</span>
}

func UnregisterLegacy(code string) bool <span class="cov8" title="1">{
        err := Unregister(code)
        return err == nil
}</span>

func CountLegacy() int <span class="cov8" title="1">{
        count, err := Count()
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return count</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package currency

import (
        "context"
        "fmt"
        "log"
        "time"
)

// ExampleBasicUsage demonstrates basic currency operations
func ExampleBasicUsage() <span class="cov0" title="0">{
        // Get currency information
        usd, err := Get("USD")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("USD: %s (%s) - %d decimals\n", usd.Name, usd.Symbol, usd.Decimals)

        // Check if currency is supported
        if IsSupported("EUR") </span><span class="cov0" title="0">{
                fmt.Println("EUR is supported")
        }</span>

        // List all supported currencies
        <span class="cov0" title="0">supported, err := ListSupported()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Supported currencies: %v\n", supported)</span>
}

// ExampleCustomRegistry demonstrates creating a custom currency registry
func ExampleCustomRegistry() <span class="cov0" title="0">{
        ctx := context.Background()

        // Create a new registry
        registry, err := NewCurrencyRegistry(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Register a custom cryptocurrency
        <span class="cov0" title="0">crypto := CurrencyMeta{
                Code:     "BTC",
                Name:     "Bitcoin",
                Symbol:   "₿",
                Decimals: 8,
                Country:  "Global",
                Region:   "Digital",
                Active:   true,
                Metadata: map[string]string{
                        "type":       "cryptocurrency",
                        "blockchain": "Bitcoin",
                        "max_supply": "21000000",
                },
        }

        if err = registry.Register(crypto); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Retrieve the currency
        <span class="cov0" title="0">retrieved, err := registry.Get("BTC")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Registered: %s (%s) - %s\n",
                retrieved.Name, retrieved.Symbol, retrieved.Metadata["type"])</span>
}

// ExamplePersistence demonstrates using persistence with currency registry
func ExamplePersistence() <span class="cov0" title="0">{
        ctx := context.Background()

        // Create registry with persistence
        registry, err := NewCurrencyRegistryWithPersistence(ctx, "./currencies.json")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Register a new currency
        <span class="cov0" title="0">newCurrency := CurrencyMeta{
                Code:     "CUSTOM",
                Name:     "Custom Currency",
                Symbol:   "C",
                Decimals: 2,
                Country:  "Custom Country",
                Region:   "Custom Region",
                Active:   true,
        }

        if err := registry.Register(newCurrency); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // The currency will be automatically saved to the file
        <span class="cov0" title="0">fmt.Println("Currency registered and persisted")</span>

        // Later, when you restart the application, the currency will be loaded
        // from the persistence file automatically
}

// ExampleSearch demonstrates searching for currencies
func ExampleSearch() <span class="cov0" title="0">{
        ctx := context.Background()
        registry, err := NewCurrencyRegistry(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Search by name
        <span class="cov0" title="0">results, err := registry.Search("Dollar")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Currencies with 'Dollar' in name:")
        for _, currency := range results </span><span class="cov0" title="0">{
                fmt.Printf("- %s (%s) from %s\n",
                        currency.Name, currency.Symbol, currency.Country)
        }</span>

        // Search by region
        <span class="cov0" title="0">european, err := registry.SearchByRegion("Europe")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Println("\nEuropean currencies:")
        for _, currency := range european </span><span class="cov0" title="0">{
                fmt.Printf("- %s (%s)\n", currency.Name, currency.Symbol)
        }</span>
}

// ExampleLifecycle demonstrates currency lifecycle management
func ExampleLifecycle() <span class="cov0" title="0">{
        ctx := context.Background()
        registry, err := NewCurrencyRegistry(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Register a currency as inactive
        <span class="cov0" title="0">currency := CurrencyMeta{
                Code:     "TEST",
                Name:     "Test Currency",
                Symbol:   "T",
                Decimals: 2,
                Active:   false, // Start as inactive
        }

        if err := registry.Register(currency); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Initially not supported (inactive)
        <span class="cov0" title="0">fmt.Printf("Is TEST supported? %t\n", registry.IsSupported("TEST"))

        // Activate the currency
        if err := registry.Activate("TEST"); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("After activation, is TEST supported? %t\n", registry.IsSupported("TEST"))

        // Deactivate the currency
        if err := registry.Deactivate("TEST"); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("After deactivation, is TEST supported? %t\n", registry.IsSupported("TEST"))

        // Unregister the currency
        if err := registry.Unregister("TEST"); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">fmt.Println("Currency unregistered")</span>
}

// ExampleValidation demonstrates currency validation
func ExampleValidation() <span class="cov0" title="0">{
        // Valid currency
        validCurrency := CurrencyMeta{
                Code:     "USD",
                Name:     "US Dollar",
                Symbol:   "$",
                Decimals: 2,
        }

        if err := Register(validCurrency); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Valid currency registration failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Valid currency registered successfully")
        }</span>

        // Invalid currency code
        <span class="cov0" title="0">invalidCode := CurrencyMeta{
                Code:     "usd", // lowercase is invalid
                Name:     "US Dollar",
                Symbol:   "$",
                Decimals: 2,
        }

        if err := Register(invalidCode); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Invalid currency code rejected: %v\n", err)
        }</span>

        // Invalid decimals
        <span class="cov0" title="0">invalidDecimals := CurrencyMeta{
                Code:     "USD",
                Name:     "US Dollar",
                Symbol:   "$",
                Decimals: 9, // too high
        }

        if err := Register(invalidDecimals); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Invalid decimals rejected: %v\n", err)
        }</span>

        // Invalid symbol
        <span class="cov0" title="0">invalidSymbol := CurrencyMeta{
                Code:     "USD",
                Name:     "US Dollar",
                Symbol:   "", // empty symbol
                Decimals: 2,
        }

        if err := Register(invalidSymbol); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Invalid symbol rejected: %v\n", err)
        }</span>
}

// ExampleBackwardCompatibility demonstrates legacy API usage
func ExampleBackwardCompatibility() <span class="cov0" title="0">{
        // Legacy registration (still works)
        RegisterLegacy("LEGACY", CurrencyMeta{
                Symbol:   "L",
                Decimals: 2,
        })

        // Legacy get (returns default for non-existent)
        meta := GetLegacy("LEGACY")
        fmt.Printf("Legacy currency: %s (%s)\n", meta.Code, meta.Symbol)

        // Legacy check
        if IsSupportedLegacy("USD") </span><span class="cov0" title="0">{
                fmt.Println("USD is supported (legacy check)")
        }</span>

        // Legacy list
        <span class="cov0" title="0">codes := ListSupportedLegacy()
        fmt.Printf("Legacy supported codes: %v\n", codes)

        // Legacy count
        count := CountLegacy()
        fmt.Printf("Legacy count: %d\n", count)</span>
}

// ExampleCurrencyMetadata demonstrates working with currency metadata
func ExampleCurrencyMetadata() <span class="cov0" title="0">{
        ctx := context.Background()
        registry, err := NewCurrencyRegistry(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Register currency with rich metadata
        <span class="cov0" title="0">richCurrency := CurrencyMeta{
                Code:     "GOLD",
                Name:     "Gold Standard",
                Symbol:   "Au",
                Decimals: 4,
                Country:  "Global",
                Region:   "Precious Metals",
                Active:   true,
                Metadata: map[string]string{
                        "type":          "commodity",
                        "atomic_number": "79",
                        "atomic_weight": "196.967",
                        "melting_point": "1064.18°C",
                        "density":       "19.32 g/cm³",
                        "exchange_type": "spot",
                },
        }

        if err = registry.Register(richCurrency); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Retrieve and display metadata
        <span class="cov0" title="0">retrieved, err := registry.Get("GOLD")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Gold currency metadata:\n")
        fmt.Printf("- Type: %s\n", retrieved.Metadata["type"])
        fmt.Printf("- Atomic Number: %s\n", retrieved.Metadata["atomic_number"])
        fmt.Printf("- Melting Point: %s\n", retrieved.Metadata["melting_point"])
        fmt.Printf("- Exchange Type: %s\n", retrieved.Metadata["exchange_type"])</span>
}

// ExampleCurrencyStatistics demonstrates getting currency statistics
func ExampleCurrencyStatistics() <span class="cov0" title="0">{
        ctx := context.Background()
        registry, err := NewCurrencyRegistry(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Get counts
        <span class="cov0" title="0">total, err := registry.Count()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">active, err := registry.CountActive()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Currency Statistics:\n")
        fmt.Printf("- Total currencies: %d\n", total)
        fmt.Printf("- Active currencies: %d\n", active)
        fmt.Printf("- Inactive currencies: %d\n", total-active)

        // List all currencies with details
        all, err := registry.ListAll()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nAll currencies:\n")
        for _, currency := range all </span><span class="cov0" title="0">{
                status := "Active"
                if !currency.Active </span><span class="cov0" title="0">{
                        status = "Inactive"
                }</span>
                <span class="cov0" title="0">fmt.Printf("- %s (%s): %s - %d decimals\n",
                        currency.Code, currency.Symbol, status, currency.Decimals)</span>
        }
}

// ExampleCurrencyEvents demonstrates working with currency events
func ExampleCurrencyEvents() <span class="cov0" title="0">{
        ctx := context.Background()
        registry, err := NewCurrencyRegistry(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // The enhanced registry automatically publishes events for:
        // - Entity registration
        // - Entity updates
        // - Entity unregistration
        // - Entity activation/deactivation

        // Register a currency (triggers registration event)
        <span class="cov0" title="0">eventCurrency := CurrencyMeta{
                Code:     "EVENT",
                Name:     "Event Currency",
                Symbol:   "E",
                Decimals: 2,
        }

        if err := registry.Register(eventCurrency); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Activate the currency (triggers activation event)
        <span class="cov0" title="0">if err := registry.Activate("EVENT"); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Deactivate the currency (triggers deactivation event)
        <span class="cov0" title="0">if err := registry.Deactivate("EVENT"); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Unregister the currency (triggers unregistration event)
        <span class="cov0" title="0">if err := registry.Unregister("EVENT"); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Currency events processed successfully")</span>
}

// ExampleCurrencyCaching demonstrates the caching behavior
func ExampleCurrencyCaching() <span class="cov0" title="0">{
        ctx := context.Background()
        registry, err := NewCurrencyRegistry(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // First get (cache miss)
        <span class="cov0" title="0">start := time.Now()
        _, err = registry.Get("USD")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">firstGet := time.Since(start)

        // Second get (cache hit)
        start = time.Now()
        _, err = registry.Get("USD")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">secondGet := time.Since(start)

        fmt.Printf("Cache performance:\n")
        fmt.Printf("- First get (cache miss): %v\n", firstGet)
        fmt.Printf("- Second get (cache hit): %v\n", secondGet)
        fmt.Printf("- Cache improvement: %v\n", firstGet-secondGet)</span>
}

// ExampleCurrencyHealth demonstrates health checking
func ExampleCurrencyHealth() <span class="cov0" title="0">{
        ctx := context.Background()
        _, err := NewCurrencyRegistry(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // The enhanced registry provides health monitoring
        // This includes:
        // - Registry availability
        // - Cache health
        // - Persistence health (if enabled)
        // - Error rates
        // - Performance metrics

        <span class="cov0" title="0">fmt.Println("Currency registry health monitoring enabled")
        fmt.Println("Health checks include:")
        fmt.Println("- Registry availability")
        fmt.Println("- Cache performance")
        fmt.Println("- Error rates")
        fmt.Println("- Response times")</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package account

import (
        "errors"
        "math"
        "regexp"
        "sync"
        "time"

        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/common"
        "github.com/amirasaad/fintech/pkg/domain/money"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/google/uuid"
)

var (
        // ErrDepositAmountExceedsMaxSafeInt is returned when a deposit would overflow the account balance.
        ErrDepositAmountExceedsMaxSafeInt = errors.New("deposit amount exceeds maximum safe integer value") // Deposit would overflow balance

        // ErrTransactionAmountMustBePositive is returned when a transaction amount is not positive.
        ErrTransactionAmountMustBePositive = errors.New("transaction amount must be positive") // Amount must be &gt; 0

        // ErrWithdrawalAmountMustBePositive is returned when a withdrawal amount is not positive.
        ErrWithdrawalAmountMustBePositive = errors.New("withdrawal amount must be positive") // Withdrawal must be &gt; 0

        // ErrInsufficientFunds is returned when an account has insufficient funds for a withdrawal.
        ErrInsufficientFunds = errors.New("insufficient funds for withdrawal") // Not enough balance

        // ErrAccountNotFound is returned when an account cannot be found.
        ErrAccountNotFound = errors.New("account not found") // Account does not exist
)

// Account represents a user's financial account, supporting multi-currency.
// Invariants:
//   - Only the account owner can perform actions.
//   - Currency must be valid and match the account’s currency.
//   - Balance cannot overflow int64.
//   - Balance cannot be negative.
//   - All operations are thread-safe.
type Account struct {
        ID        uuid.UUID
        UserID    uuid.UUID
        Balance   int64         // Account balance snapshot
        Currency  currency.Code // ISO 4217 currency code
        UpdatedAt time.Time
        CreatedAt time.Time
        mu        sync.Mutex
}

// IsValidCurrencyFormat returns true if the code is a well-formed ISO 4217 currency code (3 uppercase letters).
func IsValidCurrencyFormat(code currency.Code) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^[A-Z]{3}$`)
        return re.MatchString(string(code))
}</span>

// accountBuilder is used to build Account instances using a fluent API.
type accountBuilder struct {
        id        uuid.UUID
        userID    uuid.UUID
        balance   int64
        currency  currency.Code
        updatedAt time.Time
        createdAt time.Time
}

// New creates a new accountBuilder with default values.
func New() *accountBuilder <span class="cov8" title="1">{
        return &amp;accountBuilder{
                id:        uuid.New(),
                currency:  currency.DefaultCurrency,
                createdAt: time.Now(),
        }
}</span>

// WithUserID sets the user ID for the account.
func (b *accountBuilder) WithUserID(userID uuid.UUID) *accountBuilder <span class="cov8" title="1">{
        b.userID = userID
        return b
}</span>

// WithCurrency sets the currency for the account.
func (b *accountBuilder) WithCurrency(currencyCode currency.Code) *accountBuilder <span class="cov8" title="1">{
        b.currency = currencyCode
        return b
}</span>

// WithBalance sets the initial balance for the account (for test/data hydration only).
func (b *accountBuilder) WithBalance(balance int64) *accountBuilder <span class="cov0" title="0">{
        b.balance = balance
        return b
}</span>

// WithCreatedAt sets the createdAt timestamp (for test/data hydration only).
func (b *accountBuilder) WithCreatedAt(t time.Time) *accountBuilder <span class="cov0" title="0">{
        b.createdAt = t
        return b
}</span>

// WithUpdatedAt sets the updatedAt timestamp (for test/data hydration only).
func (b *accountBuilder) WithUpdatedAt(t time.Time) *accountBuilder <span class="cov0" title="0">{
        b.updatedAt = t
        return b
}</span>

// Build validates invariants and returns a new Account instance.
func (b *accountBuilder) Build() (*Account, error) <span class="cov8" title="1">{
        if !currency.IsValidCurrencyFormat(string(b.currency)) </span><span class="cov0" title="0">{
                return nil, common.ErrInvalidCurrencyCode
        }</span>
        <span class="cov8" title="1">if b.userID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, errors.New("userID is required")
        }</span>
        <span class="cov8" title="1">return &amp;Account{
                ID:        b.id,
                UserID:    b.userID,
                Balance:   b.balance,
                Currency:  b.currency,
                CreatedAt: b.createdAt,
                UpdatedAt: b.updatedAt,
                mu:        sync.Mutex{},
        }, nil</span>
}

// Deprecated: Use New().WithUserID(...).WithCurrency(...).Build() instead.
func NewAccount(userID uuid.UUID) (acc *Account) <span class="cov0" title="0">{
        acc, _ = New().WithUserID(userID).Build()
        return
}</span>

// Deprecated: Use New().WithUserID(...).WithCurrency(...).Build() instead.
func NewAccountWithCurrency(userID uuid.UUID, currencyCode currency.Code) (acc *Account, err error) <span class="cov0" title="0">{
        return New().WithUserID(userID).WithCurrency(currencyCode).Build()
}</span>

// NewAccountFromData creates an Account from raw data (used for DB hydration).
// This bypasses invariants and should only be used for repository hydration or tests.
func NewAccountFromData(
        id, userID uuid.UUID,
        balance int64,
        currencyCode currency.Code,
        created, updated time.Time,
) *Account <span class="cov0" title="0">{
        return &amp;Account{
                ID:        id,
                UserID:    userID,
                Balance:   balance,
                Currency:  currencyCode,
                CreatedAt: created,
                UpdatedAt: updated,
                mu:        sync.Mutex{},
        }
}</span>

// GetBalance returns the current balance of the account in the main currency unit (e.g., dollars for USD).
// Invariants enforced:
//   - Only the account owner can view the balance.
//   - Currency metadata must be valid.
//
// Returns the balance as float64 or an error if any invariant is violated.
func (a *Account) GetBalance(userID uuid.UUID) (balance float64, err error) <span class="cov8" title="1">{
        if a.UserID != userID </span><span class="cov8" title="1">{
                err = user.ErrUserUnauthorized
                return
        }</span>
        <span class="cov8" title="1">meta, err := currency.Get(string(a.Currency))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">divisor := math.Pow10(meta.Decimals)
        balance = float64(a.Balance) / divisor
        return</span>
}

// GetBalanceAsMoney returns the current balance as a Money value object.
// Invariants enforced:
//   - Only the account owner can view the balance.
//   - Currency must be valid.
//
// Returns Money or an error if any invariant is violated.
func (a *Account) GetBalanceAsMoney(userID uuid.UUID) (m money.Money, err error) <span class="cov8" title="1">{
        if a.UserID != userID </span><span class="cov0" title="0">{
                err = user.ErrUserUnauthorized
                return
        }</span>
        <span class="cov8" title="1">m, err = money.NewMoneyFromSmallestUnit(a.Balance, a.Currency)
        return</span>
}

// Deposit adds funds to the account if all business invariants are satisfied.
// Invariants enforced:
//   - Only the account owner can deposit.
//   - Deposit amount must be positive.
//   - Deposit currency must match account currency.
//   - Deposit must not cause integer overflow.
//
// Returns a Transaction or an error if any invariant is violated.
func (a *Account) Deposit(userID uuid.UUID, m money.Money) (tx *Transaction, err error) <span class="cov8" title="1">{
        if a.UserID != userID </span><span class="cov8" title="1">{
                err = user.ErrUserUnauthorized
                return
        }</span>
        <span class="cov8" title="1">a.mu.Lock()
        defer a.mu.Unlock()

        if !m.IsPositive() </span><span class="cov8" title="1">{
                err = ErrTransactionAmountMustBePositive
                return
        }</span>

        <span class="cov8" title="1">if string(m.Currency()) != string(a.Currency) </span><span class="cov0" title="0">{
                err = common.ErrInvalidCurrencyCode
                return
        }</span>

        // Check for overflow before performing the addition
        <span class="cov8" title="1">depositAmount := int64(m.Amount())
        if depositAmount &gt; 0 &amp;&amp; a.Balance &gt; 0 &amp;&amp; depositAmount &gt; math.MaxInt64-a.Balance </span><span class="cov8" title="1">{
                err = ErrDepositAmountExceedsMaxSafeInt
                return
        }</span>

        // Get current balance as Money
        <span class="cov8" title="1">var currentBalance money.Money
        currentBalance, err = a.GetBalanceAsMoney(userID)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Add the deposit amount to current balance
        <span class="cov8" title="1">var newBalance money.Money
        newBalance, err = currentBalance.Add(m)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Update account balance
        <span class="cov8" title="1">a.Balance = int64(newBalance.Amount())

        tx = &amp;Transaction{
                ID:        uuid.New(),
                UserID:    userID,
                AccountID: a.ID,
                Amount:    depositAmount,
                Currency:  m.Currency(),
                Balance:   a.Balance,
                CreatedAt: time.Now().UTC(),
        }
        return</span>
}

// Withdraw removes funds from the account if all business invariants are satisfied.
// Invariants enforced:
//   - Only the account owner can withdraw.
//   - Withdrawal amount must be positive.
//   - Withdrawal currency must match account currency.
//   - Cannot withdraw more than the current balance.
//
// Returns a Transaction or an error if any invariant is violated.
func (a *Account) Withdraw(userID uuid.UUID, m money.Money) (tx *Transaction, err error) <span class="cov8" title="1">{
        if a.UserID != userID </span><span class="cov8" title="1">{
                err = user.ErrUserUnauthorized
                return
        }</span>
        <span class="cov8" title="1">a.mu.Lock()
        defer a.mu.Unlock()

        if !m.IsPositive() </span><span class="cov8" title="1">{
                err = ErrWithdrawalAmountMustBePositive
                return
        }</span>

        // Get current balance as Money
        <span class="cov8" title="1">var currentBalance money.Money
        currentBalance, err = a.GetBalanceAsMoney(userID)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Check if we have sufficient funds
        <span class="cov8" title="1">var hasEnough bool
        hasEnough, err = currentBalance.GreaterThan(m)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !hasEnough &amp;&amp; !currentBalance.Equals(m) </span><span class="cov8" title="1">{
                err = ErrInsufficientFunds
                return
        }</span>

        // Subtract the withdrawal amount from current balance
        <span class="cov8" title="1">var newBalance money.Money
        newBalance, err = currentBalance.Subtract(m)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Update account balance
        <span class="cov8" title="1">a.Balance = int64(newBalance.Amount())

        tx = &amp;Transaction{
                ID:        uuid.New(),
                UserID:    userID,
                AccountID: a.ID,
                Amount:    -int64(m.Amount()),
                Currency:  m.Currency(),
                Balance:   a.Balance,
                CreatedAt: time.Now().UTC(),
        }
        return</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package account

import (
        "time"

        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/google/uuid"
)

// Transaction represents a financial transaction, supporting multi-currency.
type Transaction struct {
        ID        uuid.UUID
        UserID    uuid.UUID
        AccountID uuid.UUID
        Amount    int64
        Currency  currency.Code // Transaction Currency
        Balance   int64         // Account balance snapshot
        CreatedAt time.Time

        // Conversion fields (nullable when no conversion occurs)
        OriginalAmount   *float64 // Amount in original currency
        OriginalCurrency *string  // Original currency code
        ConversionRate   *float64 // Rate used for conversion
}

// NewTransactionFromData creates a Transaction from raw data (used for DB hydration or test fixtures).
// This bypasses invariants and should only be used for repository hydration or tests.
func NewTransactionFromData(
        id, userID, accountID uuid.UUID,
        amount, balance int64,
        currencyCode currency.Code,
        created time.Time,
        originalAmount *float64,
        originalCurrency *string,
        conversionRate *float64,
) *Transaction <span class="cov8" title="1">{
        return &amp;Transaction{
                ID:               id,
                UserID:           userID,
                AccountID:        accountID,
                Amount:           amount,
                Balance:          balance,
                Currency:         currencyCode,
                CreatedAt:        created,
                OriginalAmount:   originalAmount,
                OriginalCurrency: originalCurrency,
                ConversionRate:   conversionRate,
        }
}</span>

type transactionBuilder struct {
        id               uuid.UUID
        userID           uuid.UUID
        accountID        uuid.UUID
        amount           int64
        currency         currency.Code
        balance          int64
        createdAt        time.Time
        originalAmount   *float64
        originalCurrency *string
        conversionRate   *float64
}

// NewTransaction creates a new transactionBuilder with default values.
func NewTransaction() *transactionBuilder <span class="cov8" title="1">{
        return &amp;transactionBuilder{
                id:        uuid.New(),
                createdAt: time.Now(),
        }
}</span>

func (b *transactionBuilder) WithUserID(userID uuid.UUID) *transactionBuilder <span class="cov8" title="1">{
        b.userID = userID
        return b
}</span>

func (b *transactionBuilder) WithAccountID(accountID uuid.UUID) *transactionBuilder <span class="cov8" title="1">{
        b.accountID = accountID
        return b
}</span>

func (b *transactionBuilder) WithAmount(amount int64) *transactionBuilder <span class="cov8" title="1">{
        b.amount = amount
        return b
}</span>

func (b *transactionBuilder) WithCurrency(currencyCode currency.Code) *transactionBuilder <span class="cov8" title="1">{
        b.currency = currencyCode
        return b
}</span>

func (b *transactionBuilder) WithBalance(balance int64) *transactionBuilder <span class="cov8" title="1">{
        b.balance = balance
        return b
}</span>

func (b *transactionBuilder) WithCreatedAt(t time.Time) *transactionBuilder <span class="cov0" title="0">{
        b.createdAt = t
        return b
}</span>

func (b *transactionBuilder) WithOriginalAmount(v *float64) *transactionBuilder <span class="cov0" title="0">{
        b.originalAmount = v
        return b
}</span>

func (b *transactionBuilder) WithOriginalCurrency(v *string) *transactionBuilder <span class="cov0" title="0">{
        b.originalCurrency = v
        return b
}</span>

func (b *transactionBuilder) WithConversionRate(v *float64) *transactionBuilder <span class="cov0" title="0">{
        b.conversionRate = v
        return b
}</span>

// Build validates invariants and returns a new Transaction instance.
func (b *transactionBuilder) Build() *Transaction <span class="cov8" title="1">{
        // Optionally add validation here
        return &amp;Transaction{
                ID:               b.id,
                UserID:           b.userID,
                AccountID:        b.accountID,
                Amount:           b.amount,
                Currency:         b.currency,
                Balance:          b.balance,
                CreatedAt:        b.createdAt,
                OriginalAmount:   b.originalAmount,
                OriginalCurrency: b.originalCurrency,
                ConversionRate:   b.conversionRate,
        }
}</span>

// Deprecated: Use NewTransaction().With...().Build() instead.
func NewTransactionWithCurrency(id, userID, accountID uuid.UUID, amount, balance int64, currencyCode currency.Code) *Transaction <span class="cov0" title="0">{
        return NewTransaction().WithUserID(userID).
                WithAccountID(accountID).
                WithAmount(amount).
                WithCurrency(currencyCode).
                WithBalance(balance).
                WithCreatedAt(time.Now()).
                Build()
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package money

import (
        "fmt"
        "log/slog"
        "math"
        "math/big"

        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/common"
)

// Use common.ErrInvalidCurrencyCode and common.ConversionInfo

// Amount represents a monetary amount as an integer in the smallest currency unit (e.g., cents for USD).
type Amount = int64

// Money represents a monetary value in a specific currency.
// Invariants:
//   - Amount is always stored in the smallest currency unit (e.g., cents for USD).
//   - Currency code must be valid ISO 4217 (3 uppercase letters).
//   - All arithmetic operations require matching currencies.
type Money struct {
        amount   Amount
        currency currency.Code
}

// NewMoney creates a new Money value object with the given amount and currency code.
// Invariants enforced:
//   - Currency code must be valid ISO 4217 (3 uppercase letters).
//   - Amount must not have more decimal places than allowed by the currency.
//   - Amount is converted to the smallest currency unit.
//
// Returns Money or an error if any invariant is violated.
func NewMoney(
        amount float64,
        currencyCode currency.Code,
) (
        money Money,
        err error,
) <span class="cov8" title="1">{
        if currencyCode == "" </span><span class="cov0" title="0">{
                currencyCode = currency.Code(currency.DefaultCurrency)
        }</span>
        <span class="cov8" title="1">if !currency.IsValidCurrencyFormat(string(currencyCode)) </span><span class="cov8" title="1">{
                err = common.ErrInvalidCurrencyCode
                return
        }</span>

        <span class="cov8" title="1">smallestUnit, err := convertToSmallestUnit(amount, string(currencyCode))
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">money = Money{amount: Amount(smallestUnit), currency: currencyCode}
        return</span>
}

// NewMoneyFromSmallestUnit creates a new Money object from the smallest currency unit.
// Invariants enforced:
//   - Currency code must be valid ISO 4217 (3 uppercase letters).
//
// Returns Money or an error if any invariant is violated.
func NewMoneyFromSmallestUnit(
        amount int64,
        currencyCode currency.Code,
) (
        money Money,
        err error,
) <span class="cov8" title="1">{
        if currencyCode == "" </span><span class="cov0" title="0">{
                currencyCode = currency.Code(currency.DefaultCurrency)
        }</span>
        <span class="cov8" title="1">if !currency.IsValidCurrencyFormat(string(currencyCode)) </span><span class="cov8" title="1">{
                err = common.ErrInvalidCurrencyCode
                return
        }</span>

        <span class="cov8" title="1">money = Money{amount: Amount(amount), currency: currencyCode}
        return</span>
}

// Amount returns the amount of the Money object in the smallest currency unit.
func (m Money) Amount() Amount <span class="cov8" title="1">{
        return m.amount
}</span>

// AmountFloat returns the amount as a float64 in the main currency unit (e.g., dollars for USD).
// Invariants enforced:
//   - Currency metadata must be valid.
func (m Money) AmountFloat() float64 <span class="cov8" title="1">{
        meta, err := currency.Get(string(m.currency))
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("invalid currency code in AmountFloat", "currency", m.currency, "error", err)
                return 0
        }</span>

        <span class="cov8" title="1">divisor := math.Pow10(meta.Decimals)
        return float64(m.amount) / divisor</span>
}

// Currency returns the currency of the Money object.
func (m Money) Currency() currency.Code <span class="cov8" title="1">{
        return m.currency
}</span>

// Add adds another Money object to the current Money object.
// Invariants enforced:
//   - Currencies must match.
//
// Returns Money or an error if currencies do not match.
func (m Money) Add(other Money) (Money, error) <span class="cov8" title="1">{
        if !m.IsSameCurrency(other) </span><span class="cov8" title="1">{
                return Money{}, common.ErrInvalidCurrencyCode
        }</span>
        <span class="cov8" title="1">return Money{
                amount:   m.amount + other.amount,
                currency: m.currency,
        }, nil</span>
}

// Subtract subtracts another Money object from the current Money object.
// Invariants enforced:
//   - Currencies must match.
//
// Returns Money or an error if currencies do not match.
func (m Money) Subtract(other Money) (Money, error) <span class="cov8" title="1">{
        if !m.IsSameCurrency(other) </span><span class="cov0" title="0">{
                return Money{}, common.ErrInvalidCurrencyCode
        }</span>
        <span class="cov8" title="1">return Money{
                amount:   m.amount - other.amount,
                currency: m.currency,
        }, nil</span>
}

// Negate negates the current Money object.
func (m Money) Negate() Money <span class="cov8" title="1">{
        return Money{
                amount:   -m.amount,
                currency: m.currency,
        }
}</span>

// Equals checks if the current Money object is equal to another Money object.
// Invariants enforced:
//   - Currencies must match.
//
// Returns false if currencies do not match.
func (m Money) Equals(other Money) bool <span class="cov8" title="1">{
        return m.IsSameCurrency(other) &amp;&amp; m.amount == other.amount
}</span>

// GreaterThan checks if the current Money object is greater than another Money object.
// Invariants enforced:
//   - Currencies must match.
//
// Returns an error if currencies do not match.
func (m Money) GreaterThan(other Money) (bool, error) <span class="cov8" title="1">{
        if !m.IsSameCurrency(other) </span><span class="cov8" title="1">{
                return false, common.ErrInvalidCurrencyCode
        }</span>
        <span class="cov8" title="1">return m.amount &gt; other.amount, nil</span>
}

// LessThan checks if the current Money object is less than another Money object.
// Invariants enforced:
//   - Currencies must match.
//
// Returns an error if currencies do not match.
func (m Money) LessThan(other Money) (bool, error) <span class="cov0" title="0">{
        if !m.IsSameCurrency(other) </span><span class="cov0" title="0">{
                return false, common.ErrInvalidCurrencyCode
        }</span>
        <span class="cov0" title="0">return m.amount &lt; other.amount, nil</span>
}

// IsSameCurrency checks if the current Money object has the same currency as another Money object.
func (m Money) IsSameCurrency(other Money) bool <span class="cov8" title="1">{
        return m.currency == other.currency
}</span>

// IsPositive returns true if the amount is greater than zero.
func (m Money) IsPositive() bool <span class="cov8" title="1">{
        return m.amount &gt; 0
}</span>

// IsNegative returns true if the amount is less than zero.
func (m Money) IsNegative() bool <span class="cov8" title="1">{
        return m.amount &lt; 0
}</span>

// IsZero returns true if the amount is zero.
func (m Money) IsZero() bool <span class="cov8" title="1">{
        return m.amount == 0
}</span>

// Abs returns the absolute value of the Money amount.
func (m Money) Abs() Money <span class="cov8" title="1">{
        if m.amount &lt; 0 </span><span class="cov8" title="1">{
                return m.Negate()
        }</span>
        <span class="cov8" title="1">return m</span>
}

// Multiply multiplies the Money amount by a scalar factor.
// Invariants enforced:
//   - Result must not overflow int64.
//
// Returns Money or an error if overflow would occur.
func (m Money) Multiply(factor float64) (Money, error) <span class="cov8" title="1">{
        // Convert to float for multiplication
        resultFloat := float64(m.amount) * factor

        // Check for overflow
        if resultFloat &gt; float64(math.MaxInt64) || resultFloat &lt; float64(math.MinInt64) </span><span class="cov0" title="0">{
                return Money{}, fmt.Errorf("multiplication result would overflow")
        }</span>

        <span class="cov8" title="1">return Money{
                amount:   Amount(int64(resultFloat)),
                currency: m.currency,
        }, nil</span>
}

// Divide divides the Money amount by a scalar divisor.
// Invariants enforced:
//   - Divisor must not be zero.
//   - Result must not overflow int64.
//   - Division must not lose precision.
//
// Returns Money or an error if any invariant is violated.
func (m Money) Divide(divisor float64) (Money, error) <span class="cov8" title="1">{
        if divisor == 0 </span><span class="cov8" title="1">{
                return Money{}, fmt.Errorf("division by zero")
        }</span>

        // Convert to float for division
        <span class="cov8" title="1">resultFloat := float64(m.amount) / divisor

        // Check for overflow
        if resultFloat &gt; float64(math.MaxInt64) || resultFloat &lt; float64(math.MinInt64) </span><span class="cov0" title="0">{
                return Money{}, fmt.Errorf("division result would overflow")
        }</span>

        // Check if result is an integer (no precision loss)
        <span class="cov8" title="1">if resultFloat != float64(int64(resultFloat)) </span><span class="cov8" title="1">{
                return Money{}, fmt.Errorf("division would result in precision loss")
        }</span>

        <span class="cov8" title="1">return Money{
                amount:   Amount(int64(resultFloat)),
                currency: m.currency,
        }, nil</span>
}

// String returns a string representation of the Money object.
func (m Money) String() string <span class="cov8" title="1">{
        meta, err := currency.Get(string(m.currency))
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("invalid currency code in String", "currency", m.currency, "error", err)
                return ""
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.*f %s", meta.Decimals, m.AmountFloat(), m.currency)</span>
}

// convertToSmallestUnit converts a float64 amount to the smallest currency unit.
// This ensures precision by avoiding floating-point arithmetic issues.
func convertToSmallestUnit(amount float64, currencyCode string) (int64, error) <span class="cov8" title="1">{
        meta, err := currency.Get(currencyCode)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">factor := new(big.Rat).SetFloat64(math.Pow10(meta.Decimals))
        amountRat := new(big.Rat).SetFloat64(amount)
        if amountRat == nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid amount float")
        }</span>
        // Multiply amount by factor
        <span class="cov8" title="1">scaled := new(big.Rat).Mul(amountRat, factor)
        // Convert to float64 for rounding
        scaledFloat, _ := scaled.Float64()
        rounded := int64(math.Round(scaledFloat))
        if float64(rounded) &gt; float64(math.MaxInt64) || float64(rounded) &lt; float64(math.MinInt64) </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("amount exceeds maximum safe integer value")
        }</span>
        <span class="cov8" title="1">return rounded, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package user

import (
        "errors"
        "time"

        "github.com/amirasaad/fintech/pkg/utils"
        "github.com/google/uuid"
)

var (
        // ErrUserNotFound is returned when a user cannot be found in the repository.
        ErrUserNotFound = errors.New("user not found")
        // ErrUserUnauthorized is return when user
        ErrUserUnauthorized = errors.New("user unauthorized")
)

// User represents a user in the system.
type User struct {
        ID        uuid.UUID `json:"id"`
        Username  string    `json:"username"`
        Email     string    `json:"email"`
        Password  string    `json:"password"`
        Names     string    `json:"names"`
        CreatedAt time.Time `json:"created"`
        UpdatedAt time.Time `json:"updated"`
}

// NewUser creates a new User with a hashed password and current timestamps.
func NewUser(username, email, password string) (*User, error) <span class="cov8" title="1">{
        if username == "" </span><span class="cov8" title="1">{
                return nil, errors.New("username cannot be empty")
        }</span>
        <span class="cov8" title="1">if email == "" </span><span class="cov0" title="0">{
                return nil, errors.New("email cannot be empty")
        }</span>
        <span class="cov8" title="1">hashedPassword, err := utils.HashPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;User{
                ID:        uuid.New(),
                Username:  username,
                Email:     email,
                Password:  hashedPassword,
                CreatedAt: time.Now().UTC(),
                UpdatedAt: time.Now().UTC(),
        }, nil</span>
}

// NewUserFromData creates a User from raw data (used for DB hydration).
func NewUserFromData(
        id uuid.UUID,
        username, email, password string,
        created, updated time.Time,
) *User <span class="cov0" title="0">{
        return &amp;User{
                ID:        id,
                Username:  username,
                Email:     email,
                Password:  password,
                CreatedAt: created,
                UpdatedAt: updated,
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package middleware

import (
        "github.com/amirasaad/fintech/pkg/config"
        jwtware "github.com/gofiber/contrib/jwt"
        "github.com/gofiber/fiber/v2"
)

// JwtProtected protect routes
func JwtProtected(cfg config.JwtConfig) fiber.Handler <span class="cov8" title="1">{
        return jwtware.New(jwtware.Config{
                SigningKey:   jwtware.SigningKey{Key: []byte(cfg.Secret)},
                ErrorHandler: jwtError,
        })
}</span>

func jwtError(c *fiber.Ctx, err error) error <span class="cov8" title="1">{
        if err.Error() == "Missing or malformed JWT" </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusBadRequest).
                        JSON(fiber.Map{"status": "error", "message": "Missing or malformed JWT", "data": nil})

        }</span>
        <span class="cov8" title="1">return c.Status(fiber.StatusUnauthorized).
                JSON(fiber.Map{"status": "error", "message": "Invalid or expired JWT", "data": nil})</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package registry

import (
        "context"
        "fmt"
        "time"
)

// CurrencyEntity represents a currency in the registry
type CurrencyEntity struct {
        *BaseEntity
        code     string
        symbol   string
        decimals int
        active   bool
}

// NewCurrencyEntity creates a new currency entity
func NewCurrencyEntity(code, name, symbol string, decimals int) *CurrencyEntity <span class="cov0" title="0">{
        return &amp;CurrencyEntity{
                BaseEntity: NewBaseEntity(code, name),
                code:       code,
                symbol:     symbol,
                decimals:   decimals,
                active:     true,
        }
}</span>

// GetMetadata returns currency metadata
func (c *CurrencyEntity) Metadata() map[string]string <span class="cov0" title="0">{
        metadata := c.BaseEntity.Metadata()
        metadata["code"] = c.code
        metadata["symbol"] = c.symbol
        metadata["decimals"] = fmt.Sprintf("%d", c.decimals)
        metadata["active"] = fmt.Sprintf("%t", c.active)
        return metadata
}</span>

// IsActive returns whether the currency is active
func (c *CurrencyEntity) Active() bool <span class="cov0" title="0">{
        return c.active
}</span>

// Refactor CurrencyEntity to use property-style getter methods and forward to BaseEntity.
// Already implemented above or not needed due to direct field access

// Remove property-style getter methods that conflict.

// CurrencyRegistryExample demonstrates using the registry for currency management
func CurrencyRegistryExample() <span class="cov0" title="0">{
        fmt.Println("=== Currency Registry Example ===")

        // Create a registry optimized for currency management
        config := RegistryConfig{
                Name:             "currency-registry",
                MaxEntities:      1000,
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         10 * time.Minute,
        }

        registry := NewEnhancedRegistry(config)
        registry.WithValidator(NewCurrencyValidator())
        registry.WithCache(NewMemoryCache(10 * time.Minute))

        ctx := context.Background()

        // Register major currencies
        currencies := []Entity{
                NewCurrencyEntity("USD", "US Dollar", "$", 2),
                NewCurrencyEntity("EUR", "Euro", "€", 2),
                NewCurrencyEntity("GBP", "British Pound", "£", 2),
                NewCurrencyEntity("JPY", "Japanese Yen", "¥", 0),
                NewCurrencyEntity("CAD", "Canadian Dollar", "C$", 2),
                NewCurrencyEntity("AUD", "Australian Dollar", "A$", 2),
                NewCurrencyEntity("CHF", "Swiss Franc", "CHF", 2),
                NewCurrencyEntity("CNY", "Chinese Yuan", "¥", 2),
        }

        for _, currency := range currencies </span><span class="cov0" title="0">{
                registry.Register(ctx, currency) //nolint:errcheck
                fmt.Printf("Registered: %s (%s)\n", currency.Name(), currency.Metadata()["code"])
        }</span>

        // Demonstrate search capabilities
        <span class="cov0" title="0">fmt.Println("\n--- Search Examples ---")

        // Search by name
        dollarResults, _ := registry.Search(ctx, "Dollar")
        fmt.Printf("Found %d currencies with 'Dollar' in name:\n", len(dollarResults))
        for _, currency := range dollarResults </span><span class="cov0" title="0">{
                fmt.Printf("  - %s (%s)\n", currency.Name(), currency.Metadata()["code"])
        }</span>

        // Search by metadata (2 decimal places)
        <span class="cov0" title="0">twoDecimalCurrencies, _ := registry.SearchByMetadata(ctx, map[string]string{"decimals": "2"})
        fmt.Printf("\nFound %d currencies with 2 decimal places:\n", len(twoDecimalCurrencies))
        for _, currency := range twoDecimalCurrencies </span><span class="cov0" title="0">{
                fmt.Printf("  - %s (%s)\n", currency.Name(), currency.Metadata()["code"])
        }</span>

        // List all active currencies
        <span class="cov0" title="0">activeCurrencies, _ := registry.ListActive(ctx)
        fmt.Printf("\nFound %d active currencies:\n", len(activeCurrencies))
        for _, currency := range activeCurrencies </span><span class="cov0" title="0">{
                if ce, ok := currency.(*CurrencyEntity); ok </span><span class="cov0" title="0">{
                        fmt.Printf("  - %s (%s) %s\n",
                                ce.Name(),
                                ce.ID(),
                                ce.symbol)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  - %s (%s) %s\n",
                                currency.Name(),
                                currency.ID(),
                                currency.Metadata()["symbol"])
                }</span>
        }

        // Demonstrate metadata operations
        <span class="cov0" title="0">fmt.Println("\n--- Metadata Operations ---")

        // Add additional metadata to USD
        err := registry.SetMetadata(ctx, "USD", "country", "United States")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to set metadata: %v\n", err)
        }</span>

        // Get the metadata
        <span class="cov0" title="0">country, err := registry.GetMetadata(ctx, "USD", "country")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to get metadata: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("USD country: %s\n", country)
        }</span>

        // Demonstrate lifecycle operations
        <span class="cov0" title="0">fmt.Println("\n--- Lifecycle Operations ---")

        // Deactivate a currency
        err = registry.Deactivate(ctx, "JPY")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to deactivate JPY: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("JPY deactivated")
        }</span>

        // Check active count
        <span class="cov0" title="0">activeCount, _ := registry.CountActive(ctx)
        fmt.Printf("Active currencies: %d\n", activeCount)

        // Reactivate JPY
        err = registry.Activate(ctx, "JPY")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to activate JPY: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("JPY activated")
        }</span>

        // Demonstrate performance
        <span class="cov0" title="0">fmt.Println("\n--- Performance Test ---")

        // Register many currencies for performance testing
        start := time.Now()
        for i := 1; i &lt;= 100; i++ </span><span class="cov0" title="0">{
                currency := NewCurrencyEntity(
                        fmt.Sprintf("TEST%d", i),
                        fmt.Sprintf("Test Currency %d", i),
                        fmt.Sprintf("T%d", i),
                        2,
                )
                registry.Register(ctx, currency) //nolint:errcheck
        }</span>
        <span class="cov0" title="0">registerTime := time.Since(start)
        fmt.Printf("Registered 100 currencies in %v\n", registerTime)

        // Test lookup performance
        start = time.Now()
        for i := 1; i &lt;= 1000; i++ </span><span class="cov0" title="0">{
                registry.Get(ctx, "USD") //nolint:errcheck
        }</span>
        <span class="cov0" title="0">lookupTime := time.Since(start)
        fmt.Printf("1000 USD lookups in %v (avg: %v per lookup)\n",
                lookupTime, lookupTime/1000)

        // Demonstrate statistics
        fmt.Println("\n--- Registry Statistics ---")

        totalCount, _ := registry.Count(ctx)
        fmt.Printf("Total currencies: %d\n", totalCount)

        activeCount, _ = registry.CountActive(ctx)
        fmt.Printf("Active currencies: %d\n", activeCount)

        // List all currencies
        allCurrencies, _ := registry.List(ctx)
        fmt.Printf("\nAll registered currencies (%d):\n", len(allCurrencies))
        for _, currency := range allCurrencies </span><span class="cov0" title="0">{
                if ce, ok := currency.(*CurrencyEntity); ok </span><span class="cov0" title="0">{
                        metadata := ce.Metadata()
                        status := "Active"
                        if !ce.Active() </span><span class="cov0" title="0">{
                                status = "Inactive"
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("  %s: %s %s (%s decimals) - %s\n",
                                ce.ID(),
                                ce.symbol,
                                ce.Name(),
                                metadata["decimals"],
                                status)</span>
                } else<span class="cov0" title="0"> {
                        metadata := currency.Metadata()
                        status := "Active"
                        if !currency.Active() </span><span class="cov0" title="0">{
                                status = "Inactive"
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("  %s: %s %s (%s decimals) - %s\n",
                                currency.ID(),
                                metadata["symbol"],
                                currency.Name(),
                                metadata["decimals"],
                                status)</span>
                }
        }
}

// CurrencyValidator implements custom validation for currencies
type CurrencyValidator struct {
        *SimpleValidator
}

// NewCurrencyValidator creates a new currency validator
func NewCurrencyValidator() *CurrencyValidator <span class="cov0" title="0">{
        validator := &amp;CurrencyValidator{
                SimpleValidator: NewSimpleValidator(),
        }

        // Set required metadata for currencies
        validator.WithRequiredMetadata([]string{"code", "symbol", "decimals"})

        // Add custom validators
        validator.WithValidator("code", validateCurrencyCode)
        validator.WithValidator("symbol", validateCurrencySymbol)
        validator.WithValidator("decimals", validateDecimals)

        return validator
}</span>

// Validate validates a currency entity
func (v *CurrencyValidator) Validate(ctx context.Context, entity Entity) error <span class="cov0" title="0">{
        // First run basic validation
        if err := v.SimpleValidator.Validate(ctx, entity); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Additional currency-specific validation
        <span class="cov0" title="0">metadata := entity.Metadata()

        // Check code format (3 uppercase letters)
        code := metadata["code"]
        if len(code) != 3 </span><span class="cov0" title="0">{
                return fmt.Errorf("currency code must be exactly 3 characters")
        }</span>

        // Check decimals range
        <span class="cov0" title="0">decimals := metadata["decimals"]
        if decimals == "0" || decimals == "2" </span>{<span class="cov0" title="0">
                // Valid decimal places
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf("currency decimals must be 0 or 2")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Validation functions
func validateCurrencyCode(code string) error <span class="cov0" title="0">{
        if len(code) != 3 </span><span class="cov0" title="0">{
                return fmt.Errorf("currency code must be exactly 3 characters")
        }</span>

        <span class="cov0" title="0">for _, char := range code </span><span class="cov0" title="0">{
                if char &lt; 'A' || char &gt; 'Z' </span><span class="cov0" title="0">{
                        return fmt.Errorf("currency code must contain only uppercase letters")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func validateCurrencySymbol(symbol string) error <span class="cov0" title="0">{
        if len(symbol) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("currency symbol cannot be empty")
        }</span>
        <span class="cov0" title="0">if len(symbol) &gt; 5 </span><span class="cov0" title="0">{
                return fmt.Errorf("currency symbol too long (max 5 characters)")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateDecimals(decimals string) error <span class="cov0" title="0">{
        if decimals != "0" &amp;&amp; decimals != "2" </span><span class="cov0" title="0">{
                return fmt.Errorf("currency decimals must be 0 or 2")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CurrencyRegistryWithPersistence demonstrates persistent currency storage
func CurrencyRegistryWithPersistence() <span class="cov0" title="0">{
        fmt.Println("\n=== Currency Registry with Persistence ===")

        // Create registry with file persistence
        config := RegistryConfig{
                Name:              "persistent-currency-registry",
                EnableEvents:      true,
                EnableValidation:  true,
                CacheSize:         50,
                CacheTTL:          5 * time.Minute,
                EnablePersistence: true,
                PersistencePath:   "/tmp/currencies.json",
                AutoSaveInterval:  time.Minute,
        }

        registry := NewEnhancedRegistry(config)
        registry.WithValidator(NewCurrencyValidator())
        registry.WithCache(NewMemoryCache(5 * time.Minute))

        ctx := context.Background()

        // Register some currencies
        currencies := []Entity{
                NewCurrencyEntity("USD", "US Dollar", "$", 2),
                NewCurrencyEntity("EUR", "Euro", "€", 2),
                NewCurrencyEntity("GBP", "British Pound", "£", 2),
        }

        for _, currency := range currencies </span><span class="cov0" title="0">{
                registry.Register(ctx, currency) //nolint:errcheck
        }</span>

        <span class="cov0" title="0">fmt.Printf("Registered %d currencies to persistent storage\n", len(currencies))

        // Simulate application restart by creating a new registry
        fmt.Println("Simulating application restart...")

        newRegistry := NewEnhancedRegistry(config)
        newRegistry.WithValidator(NewCurrencyValidator())
        newRegistry.WithCache(NewMemoryCache(5 * time.Minute))

        // Load currencies from persistence
        persistence := NewFilePersistence("/tmp/currencies.json")
        entities, err := persistence.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to load currencies: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">for _, entity := range entities </span><span class="cov0" title="0">{
                newRegistry.Register(ctx, entity) //nolint:errcheck
        }</span>

        <span class="cov0" title="0">fmt.Printf("Loaded %d currencies from persistent storage\n", len(entities))

        // Verify the currencies are available
        loadedCurrencies, _ := newRegistry.List(ctx)
        fmt.Println("Available currencies after restart:")
        for _, currency := range loadedCurrencies </span><span class="cov0" title="0">{
                if ce, ok := currency.(*CurrencyEntity); ok </span><span class="cov0" title="0">{
                        fmt.Printf("  %s: %s %s\n",
                                ce.ID(),
                                ce.symbol,
                                ce.Name())
                }</span> else<span class="cov0" title="0"> {
                        metadata := currency.Metadata()
                        fmt.Printf("  %s: %s %s\n",
                                currency.ID(),
                                metadata["symbol"],
                                currency.Name())
                }</span>
        }
}

// CurrencyRegistryWithEvents demonstrates event-driven currency management
func CurrencyRegistryWithEvents() <span class="cov0" title="0">{
        fmt.Println("\n=== Currency Registry with Events ===")

        // Create registry with events
        config := RegistryConfig{
                Name:             "event-driven-currency-registry",
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        50,
                CacheTTL:         5 * time.Minute,
        }

        registry := NewEnhancedRegistry(config)
        registry.WithValidator(NewCurrencyValidator())

        // Create event observer
        observer := &amp;CurrencyEventLogger{}

        // In a real implementation, you'd subscribe to the event bus
        // For this example, we'll simulate events manually

        ctx := context.Background()

        // Register currencies and simulate events
        currencies := []Entity{
                NewCurrencyEntity("USD", "US Dollar", "$", 2),
                NewCurrencyEntity("EUR", "Euro", "€", 2),
        }

        for _, currency := range currencies </span><span class="cov0" title="0">{
                registry.Register(ctx, currency) //nolint:errcheck
                observer.OnEntityRegistered(ctx, currency)
        }</span>

        // Simulate currency updates
        <span class="cov0" title="0">usd, _ := registry.Get(ctx, "USD")
        if usd != nil </span><span class="cov0" title="0">{
                registry.SetMetadata(ctx, "USD", "last_updated", time.Now().Format(time.RFC3339)) //nolint:errcheck
                observer.OnEntityUpdated(ctx, usd)
        }</span>

        // Simulate currency deactivation
        <span class="cov0" title="0">registry.Deactivate(ctx, "EUR") //nolint:errcheck
        observer.OnEntityDeactivated(ctx, "EUR")

        fmt.Println("Currency events processed successfully")</span>
}

// CurrencyEventLogger implements RegistryObserver for currency events
type CurrencyEventLogger struct{}

func (l *CurrencyEventLogger) OnEntityRegistered(ctx context.Context, entity Entity) <span class="cov0" title="0">{
        if ce, ok := entity.(*CurrencyEntity); ok </span><span class="cov0" title="0">{
                fmt.Printf("CURRENCY REGISTERED: %s (%s) %s\n",
                        ce.Name(),
                        ce.ID(),
                        ce.symbol)
        }</span> else<span class="cov0" title="0"> {
                metadata := entity.Metadata()
                fmt.Printf("CURRENCY REGISTERED: %s (%s) %s\n",
                        entity.Name(),
                        entity.ID(),
                        metadata["symbol"])
        }</span>
}

func (l *CurrencyEventLogger) OnEntityUnregistered(ctx context.Context, id string) <span class="cov0" title="0">{
        fmt.Printf("CURRENCY UNREGISTERED: %s\n", id)
}</span>

func (l *CurrencyEventLogger) OnEntityUpdated(ctx context.Context, entity Entity) <span class="cov0" title="0">{
        if ce, ok := entity.(*CurrencyEntity); ok </span><span class="cov0" title="0">{
                fmt.Printf("CURRENCY UPDATED: %s (%s)\n",
                        ce.Name(),
                        ce.ID())
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("CURRENCY UPDATED: %s (%s)\n",
                        entity.Name(),
                        entity.ID())
        }</span>
}

func (l *CurrencyEventLogger) OnEntityActivated(ctx context.Context, id string) <span class="cov0" title="0">{
        fmt.Printf("CURRENCY ACTIVATED: %s\n", id)
}</span>

func (l *CurrencyEventLogger) OnEntityDeactivated(ctx context.Context, id string) <span class="cov0" title="0">{
        fmt.Printf("CURRENCY DEACTIVATED: %s\n", id)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package registry

import (
        "context"
        "fmt"
        "sync"
        "time"
)

// EnhancedRegistry provides a full-featured registry implementation
type EnhancedRegistry struct {
        config      RegistryConfig
        entities    map[string]Entity
        mu          sync.RWMutex
        observers   []RegistryObserver
        validator   RegistryValidator
        cache       RegistryCache
        persistence RegistryPersistence
        metrics     RegistryMetrics
        health      RegistryHealth
        eventBus    RegistryEventBus
}

// NewEnhancedRegistry creates a new enhanced registry
func NewEnhancedRegistry(config RegistryConfig) *EnhancedRegistry <span class="cov8" title="1">{
        return &amp;EnhancedRegistry{
                config:    config,
                entities:  make(map[string]Entity),
                observers: make([]RegistryObserver, 0),
        }
}</span>

// WithValidator sets the validator for the registry
func (r *EnhancedRegistry) WithValidator(validator RegistryValidator) *EnhancedRegistry <span class="cov8" title="1">{
        r.validator = validator
        return r
}</span>

// WithCache sets the cache for the registry
func (r *EnhancedRegistry) WithCache(cache RegistryCache) *EnhancedRegistry <span class="cov8" title="1">{
        r.cache = cache
        return r
}</span>

// WithPersistence sets the persistence layer for the registry
func (r *EnhancedRegistry) WithPersistence(persistence RegistryPersistence) *EnhancedRegistry <span class="cov0" title="0">{
        r.persistence = persistence
        return r
}</span>

// WithMetrics sets the metrics collector for the registry
func (r *EnhancedRegistry) WithMetrics(metrics RegistryMetrics) *EnhancedRegistry <span class="cov8" title="1">{
        r.metrics = metrics
        return r
}</span>

// WithHealth sets the health checker for the registry
func (r *EnhancedRegistry) WithHealth(health RegistryHealth) *EnhancedRegistry <span class="cov0" title="0">{
        r.health = health
        return r
}</span>

// WithEventBus sets the event bus for the registry
func (r *EnhancedRegistry) WithEventBus(eventBus RegistryEventBus) *EnhancedRegistry <span class="cov8" title="1">{
        r.eventBus = eventBus
        return r
}</span>

// Register adds or updates an entity in the registry
func (r *EnhancedRegistry) Register(ctx context.Context, entity Entity) error <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if r.metrics != nil </span><span class="cov8" title="1">{
                        r.metrics.RecordLatency("register", time.Since(start))
                }</span>
        }()

        // Validate entity if validator is set
        <span class="cov8" title="1">if r.validator != nil </span><span class="cov8" title="1">{
                if err := r.validator.Validate(ctx, entity); err != nil </span><span class="cov8" title="1">{
                        if r.metrics != nil </span><span class="cov0" title="0">{
                                r.metrics.IncrementError()
                        }</span>
                        <span class="cov8" title="1">return fmt.Errorf("validation failed: %w", err)</span>
                }
        }

        // Check max entities limit
        <span class="cov8" title="1">if r.config.MaxEntities &gt; 0 </span><span class="cov0" title="0">{
                r.mu.RLock()
                currentCount := len(r.entities)
                r.mu.RUnlock()
                if currentCount &gt;= r.config.MaxEntities </span><span class="cov0" title="0">{
                        if r.metrics != nil </span><span class="cov0" title="0">{
                                r.metrics.IncrementError()
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("registry is full (max entities: %d)", r.config.MaxEntities)</span>
                }
        }

        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()

        // Check if entity already exists
        _, exists := r.entities[entity.ID()]
        r.entities[entity.ID()] = entity

        // Update cache if available
        if r.cache != nil </span><span class="cov8" title="1">{
                r.cache.Set(ctx, entity) //nolint:errcheck
        }</span>

        // Update metrics
        <span class="cov8" title="1">if r.metrics != nil </span><span class="cov8" title="1">{
                r.metrics.IncrementRegistration()
                r.metrics.SetEntityCount(len(r.entities))
                if entity.Active() </span><span class="cov8" title="1">{
                        activeCount := r.countActiveLocked()
                        r.metrics.SetActiveCount(activeCount)
                }</span>
        }

        // Publish event
        <span class="cov8" title="1">if r.eventBus != nil </span><span class="cov8" title="1">{
                eventType := EventEntityRegistered
                if exists </span><span class="cov0" title="0">{
                        eventType = EventEntityUpdated
                }</span>
                <span class="cov8" title="1">event := RegistryEvent{
                        Type:      eventType,
                        EntityID:  entity.ID(),
                        Entity:    entity,
                        Timestamp: time.Now(),
                }
                r.eventBus.Publish(ctx, event)</span> //nolint:errcheck
        }

        // Notify observers
        <span class="cov8" title="1">for _, observer := range r.observers </span><span class="cov0" title="0">{
                if exists </span><span class="cov0" title="0">{
                        observer.OnEntityUpdated(ctx, entity)
                }</span> else<span class="cov0" title="0"> {
                        observer.OnEntityRegistered(ctx, entity)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Get retrieves an entity by ID
func (r *EnhancedRegistry) Get(ctx context.Context, id string) (Entity, error) <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if r.metrics != nil </span><span class="cov8" title="1">{
                        r.metrics.RecordLatency("get", time.Since(start))
                }</span>
        }()

        // Try cache first
        <span class="cov8" title="1">if r.cache != nil </span><span class="cov0" title="0">{
                if entity, found := r.cache.Get(ctx, id); found </span><span class="cov0" title="0">{
                        if r.metrics != nil </span><span class="cov0" title="0">{
                                r.metrics.IncrementLookup()
                        }</span>
                        <span class="cov0" title="0">return entity, nil</span>
                }
        }

        <span class="cov8" title="1">r.mu.RLock()
        entity, exists := r.entities[id]
        r.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                if r.metrics != nil </span><span class="cov0" title="0">{
                        r.metrics.IncrementError()
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("entity not found: %s", id)</span>
        }

        // Update cache
        <span class="cov8" title="1">if r.cache != nil </span><span class="cov0" title="0">{
                r.cache.Set(ctx, entity) //nolint:errcheck
        }</span>

        <span class="cov8" title="1">if r.metrics != nil </span><span class="cov8" title="1">{
                r.metrics.IncrementLookup()
        }</span>

        <span class="cov8" title="1">return entity, nil</span>
}

// Unregister removes an entity from the registry
func (r *EnhancedRegistry) Unregister(ctx context.Context, id string) error <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if r.metrics != nil </span><span class="cov8" title="1">{
                        r.metrics.RecordLatency("unregister", time.Since(start))
                }</span>
        }()

        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.entities[id]; !exists </span><span class="cov0" title="0">{
                if r.metrics != nil </span><span class="cov0" title="0">{
                        r.metrics.IncrementError()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("entity not found: %s", id)</span>
        }

        <span class="cov8" title="1">delete(r.entities, id)

        // Remove from cache
        if r.cache != nil </span><span class="cov0" title="0">{
                r.cache.Delete(ctx, id) //nolint:errcheck
        }</span>

        // Update metrics
        <span class="cov8" title="1">if r.metrics != nil </span><span class="cov8" title="1">{
                r.metrics.IncrementUnregistration()
                r.metrics.SetEntityCount(len(r.entities))
                activeCount := r.countActiveLocked()
                r.metrics.SetActiveCount(activeCount)
        }</span>

        // Publish event
        <span class="cov8" title="1">if r.eventBus != nil </span><span class="cov8" title="1">{
                event := RegistryEvent{
                        Type:      EventEntityUnregistered,
                        EntityID:  id,
                        Timestamp: time.Now(),
                }
                r.eventBus.Publish(ctx, event) //nolint:errcheck
        }</span>

        // Notify observers
        <span class="cov8" title="1">for _, observer := range r.observers </span><span class="cov0" title="0">{
                observer.OnEntityUnregistered(ctx, id)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsRegistered checks if an entity is registered
func (r *EnhancedRegistry) IsRegistered(ctx context.Context, id string) bool <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        _, exists := r.entities[id]
        return exists
}</span>

// List returns all entities
func (r *EnhancedRegistry) List(ctx context.Context) ([]Entity, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0, len(r.entities))
        for _, entity := range r.entities </span><span class="cov8" title="1">{
                entities = append(entities, entity)
        }</span>
        <span class="cov8" title="1">return entities, nil</span>
}

// ListActive returns all active entities
func (r *EnhancedRegistry) ListActive(ctx context.Context) ([]Entity, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0)
        for _, entity := range r.entities </span><span class="cov0" title="0">{
                if entity.Active() </span><span class="cov0" title="0">{
                        entities = append(entities, entity)
                }</span>
        }
        <span class="cov0" title="0">return entities, nil</span>
}

// ListByMetadata returns entities with specific metadata
func (r *EnhancedRegistry) ListByMetadata(ctx context.Context, key, value string) ([]Entity, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0)
        for _, entity := range r.entities </span><span class="cov0" title="0">{
                if metadata := entity.Metadata(); metadata != nil </span><span class="cov0" title="0">{
                        if val, exists := metadata[key]; exists &amp;&amp; val == value </span><span class="cov0" title="0">{
                                entities = append(entities, entity)
                        }</span>
                }
        }
        <span class="cov0" title="0">return entities, nil</span>
}

// Count returns the total number of entities
func (r *EnhancedRegistry) Count(ctx context.Context) (int, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return len(r.entities), nil
}</span>

// CountActive returns the number of active entities
func (r *EnhancedRegistry) CountActive(ctx context.Context) (int, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.countActiveLocked(), nil
}</span>

// countActiveLocked is a helper method that assumes the lock is already held
func (r *EnhancedRegistry) countActiveLocked() int <span class="cov8" title="1">{
        count := 0
        for _, entity := range r.entities </span><span class="cov8" title="1">{
                if entity.Active() </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// GetMetadata retrieves specific metadata for an entity
func (r *EnhancedRegistry) GetMetadata(ctx context.Context, id, key string) (string, error) <span class="cov8" title="1">{
        entity, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">metadata := entity.Metadata()
        if val, exists := metadata[key]; exists </span><span class="cov8" title="1">{
                return val, nil
        }</span>

        <span class="cov8" title="1">return "", fmt.Errorf("metadata key not found: %s", key)</span>
}

// SetMetadata sets specific metadata for an entity
func (r *EnhancedRegistry) SetMetadata(ctx context.Context, id, key, value string) error <span class="cov8" title="1">{
        entity, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate metadata if validator is set
        <span class="cov8" title="1">if r.validator != nil </span><span class="cov0" title="0">{
                metadata := entity.Metadata()
                metadata[key] = value
                if err := r.validator.ValidateMetadata(ctx, metadata); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("metadata validation failed: %w", err)
                }</span>
        }

        // Update the entity's metadata
        <span class="cov8" title="1">metadata := entity.Metadata()
        metadata[key] = value

        // Re-register the entity to update it
        return r.Register(ctx, entity)</span>
}

// RemoveMetadata removes specific metadata from an entity
func (r *EnhancedRegistry) RemoveMetadata(ctx context.Context, id, key string) error <span class="cov8" title="1">{
        entity, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">metadata := entity.Metadata()
        delete(metadata, key)

        // Re-register the entity to update it
        return r.Register(ctx, entity)</span>
}

// Activate activates an entity
func (r *EnhancedRegistry) Activate(ctx context.Context, id string) error <span class="cov0" title="0">{
        entity, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create a new entity with active status
        // Note: This is a simplified approach - in a real implementation,
        // you might want to make the Entity interface mutable or use a different approach
        <span class="cov0" title="0">baseEntity := &amp;BaseEntity{
                BEId:        entity.ID(),
                BEName:      entity.Name(),
                BEActive:    true,
                BEMetadata:  entity.Metadata(),
                BECreatedAt: entity.CreatedAt(),
                BEUpdatedAt: entity.UpdatedAt(),
        }

        return r.Register(ctx, baseEntity)</span>
}

// Deactivate deactivates an entity
func (r *EnhancedRegistry) Deactivate(ctx context.Context, id string) error <span class="cov0" title="0">{
        entity, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create a new entity with inactive status
        <span class="cov0" title="0">baseEntity := &amp;BaseEntity{
                BEId:        entity.ID(),
                BEName:      entity.Name(),
                BEActive:    false,
                BEMetadata:  entity.Metadata(),
                BECreatedAt: entity.CreatedAt(),
                BEUpdatedAt: entity.UpdatedAt(),
        }

        return r.Register(ctx, baseEntity)</span>
}

// Search performs a simple search on entity names
func (r *EnhancedRegistry) Search(ctx context.Context, query string) ([]Entity, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0)
        for _, entity := range r.entities </span><span class="cov8" title="1">{
                if contains(entity.Name(), query) </span><span class="cov8" title="1">{
                        entities = append(entities, entity)
                }</span>
        }
        <span class="cov8" title="1">return entities, nil</span>
}

// SearchByMetadata searches entities by metadata
func (r *EnhancedRegistry) SearchByMetadata(ctx context.Context, metadata map[string]string) ([]Entity, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0)
        for _, entity := range r.entities </span><span class="cov8" title="1">{
                entityMetadata := entity.Metadata()
                matches := true
                for key, value := range metadata </span><span class="cov8" title="1">{
                        if val, exists := entityMetadata[key]; !exists || val != value </span><span class="cov8" title="1">{
                                matches = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if matches </span><span class="cov8" title="1">{
                        entities = append(entities, entity)
                }</span>
        }
        <span class="cov8" title="1">return entities, nil</span>
}

// AddObserver adds an observer to the registry
func (r *EnhancedRegistry) AddObserver(observer RegistryObserver) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.observers = append(r.observers, observer)
}</span>

// RemoveObserver removes an observer from the registry
func (r *EnhancedRegistry) RemoveObserver(observer RegistryObserver) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        for i, obs := range r.observers </span><span class="cov0" title="0">{
                if obs == observer </span><span class="cov0" title="0">{
                        r.observers = append(r.observers[:i], r.observers[i+1:]...)
                        break</span>
                }
        }
}

// contains is a helper function for string search
func contains(s, substr string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr ||
                (len(s) &gt; len(substr) &amp;&amp; (s[:len(substr)] == substr ||
                        s[len(s)-len(substr):] == substr ||
                        containsSubstring(s, substr))))
}</span>

// containsSubstring is a helper function for substring search
func containsSubstring(s, substr string) bool <span class="cov8" title="1">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package registry

import (
        "context"
        "fmt"
        "log"
        "time"
)

// Example 1: Basic Registry Usage
func ExampleBasicRegistry() <span class="cov0" title="0">{
        // Create a basic registry with default settings
        registry := NewBasicRegistry()
        ctx := context.Background()

        // Register entities
        user1 := NewBaseEntity("user-1", "John Doe")
        user1.Metadata()["email"] = "john@example.com"
        user1.Metadata()["role"] = "admin"

        user2 := NewBaseEntity("user-2", "Jane Smith")
        user2.Metadata()["email"] = "jane@example.com"
        user2.Metadata()["role"] = "user"

        registry.Register(ctx, user1) //nolint:errcheck
        registry.Register(ctx, user2) //nolint:errcheck

        // List all entities
        entities, _ := registry.List(ctx)
        fmt.Printf("Total entities: %d\n", len(entities))

        // Search by metadata
        admins, _ := registry.SearchByMetadata(ctx, map[string]string{"role": "admin"})
        fmt.Printf("Admin users: %d\n", len(admins))

        // Get specific entity
        if user, err := registry.Get(ctx, "user-1"); err == nil </span><span class="cov0" title="0">{
                fmt.Printf("Found user: %s (%s)\n", user.Name(), user.Metadata()["email"])
        }</span>
}

// Example 2: Registry with Persistence
func ExamplePersistentRegistry() <span class="cov0" title="0">{
        // Create a registry with file persistence
        registry, err := NewPersistentRegistry("/tmp/users.json")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">ctx := context.Background()

        // Register users
        users := []Entity{
                NewBaseEntity("user-1", "Alice Johnson"),
                NewBaseEntity("user-2", "Bob Wilson"),
                NewBaseEntity("user-3", "Carol Davis"),
        }

        for _, user := range users </span><span class="cov0" title="0">{
                registry.Register(ctx, user) //nolint:errcheck
        }</span>

        // The registry automatically persists to file
        <span class="cov0" title="0">fmt.Println("Users saved to persistent storage")

        // Create a new registry instance (simulating application restart)
        newRegistry, _ := NewPersistentRegistry("/tmp/users.json")

        // Users are automatically loaded from file
        entities, _ := newRegistry.List(ctx)
        fmt.Printf("Loaded %d users from persistent storage\n", len(entities))</span>
}

// Example 3: Registry with Caching
func ExampleCachedRegistry() <span class="cov0" title="0">{
        // Create a registry with enhanced caching
        registry := NewCachedRegistry(100, 5*time.Minute)
        ctx := context.Background()

        // Register many entities
        for i := 1; i &lt;= 50; i++ </span><span class="cov0" title="0">{
                user := NewBaseEntity(fmt.Sprintf("user-%d", i), fmt.Sprintf("User %d", i))
                registry.Register(ctx, user) //nolint:errcheck
        }</span>

        // Repeated lookups will be served from cache
        <span class="cov0" title="0">start := time.Now()
        for i := 0; i &lt; 1000; i++ </span><span class="cov0" title="0">{
                registry.Get(ctx, "user-1") //nolint:errcheck
        }</span>
        <span class="cov0" title="0">duration := time.Since(start)
        fmt.Printf("1000 lookups completed in %v\n", duration)</span>
}

// Example 4: Registry with Metrics and Monitoring
func ExampleMonitoredRegistry() <span class="cov0" title="0">{
        // Create a monitored registry
        registry := NewMonitoredRegistry("user-registry")
        ctx := context.Background()

        // Perform operations
        for i := 1; i &lt;= 10; i++ </span><span class="cov0" title="0">{
                user := NewBaseEntity(fmt.Sprintf("user-%d", i), fmt.Sprintf("User %d", i))
                registry.Register(ctx, user) //nolint:errcheck
        }</span>

        // Simulate some lookups and errors
        <span class="cov0" title="0">for i := 1; i &lt;= 5; i++ </span><span class="cov0" title="0">{
                registry.Get(ctx, fmt.Sprintf("user-%d", i)) //nolint:errcheck
        }</span>

        // Try to get non-existent user (will increment error count)
        <span class="cov0" title="0">registry.Get(ctx, "non-existent") //nolint:errcheck

        // The registry automatically tracks metrics
        fmt.Println("Registry operations completed with metrics tracking")</span>
}

// Example 5: Registry Builder Pattern
func ExampleRegistryBuilder() <span class="cov0" title="0">{
        // Use the builder pattern for complex configuration
        registry, err := NewRegistryBuilder().
                WithName("production-user-registry").
                WithMaxEntities(10000).
                WithCache(1000, 10*time.Minute).
                WithPersistence("/data/users.json", 30*time.Second).
                WithValidation([]string{"email", "role"}, []string{"password"}).
                BuildRegistry()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Register a user with required metadata
        user := NewBaseEntity("user-1", "John Doe")
        user.Metadata()["email"] = "john@example.com"
        user.Metadata()["role"] = "admin"

        err = registry.Register(ctx, user) //nolint:errcheck
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Registration failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("User registered successfully")
        }</span>
}

// Example 6: Custom Entity Implementation
type Product struct {
        *BaseEntity
        Price    float64
        Category string
        InStock  bool
}

func NewProduct(id, name string, price float64, category string) *Product <span class="cov0" title="0">{
        return &amp;Product{
                BaseEntity: NewBaseEntity(id, name),
                Price:      price,
                Category:   category,
                InStock:    true,
        }
}</span>

func (p *Product) Metadata() map[string]string <span class="cov0" title="0">{
        metadata := p.BaseEntity.Metadata()
        metadata["price"] = fmt.Sprintf("%.2f", p.Price)
        metadata["category"] = p.Category
        metadata["in_stock"] = fmt.Sprintf("%t", p.InStock)
        return metadata
}</span>

func ExampleCustomEntity() <span class="cov0" title="0">{
        registry := NewBasicRegistry()
        ctx := context.Background()

        // Register custom entities
        products := []Entity{
                NewProduct("prod-1", "Laptop", 999.99, "Electronics"),
                NewProduct("prod-2", "Book", 19.99, "Books"),
                NewProduct("prod-3", "Phone", 699.99, "Electronics"),
        }

        for _, product := range products </span><span class="cov0" title="0">{
                registry.Register(ctx, product) //nolint:errcheck
        }</span>

        // Search by category
        <span class="cov0" title="0">electronics, _ := registry.SearchByMetadata(ctx, map[string]string{"category": "Electronics"})
        fmt.Printf("Found %d electronics products\n", len(electronics))

        // List all products
        allProducts, _ := registry.List(ctx)
        for _, product := range allProducts </span><span class="cov0" title="0">{
                metadata := product.Metadata()
                fmt.Printf("%s: %s - $%s (%s)\n",
                        product.ID(),
                        product.Name(),
                        metadata["price"],
                        metadata["category"])
        }</span>
}

// Example 7: Event-Driven Registry
func ExampleEventDrivenRegistry() <span class="cov0" title="0">{
        // Create registry with events
        registry := NewBasicRegistry()
        ctx := context.Background()

        // Create event observer
        observer := &amp;UserActivityLogger{}

        // Subscribe to events (in a real implementation, you'd get the event bus from the registry)
        fmt.Println("Event-driven registry example:")
        fmt.Println("(In a real implementation, events would be automatically triggered)")

        // Register users (would trigger events)
        users := []Entity{
                NewBaseEntity("user-1", "Alice"),
                NewBaseEntity("user-2", "Bob"),
        }

        for _, user := range users </span><span class="cov0" title="0">{
                registry.Register(ctx, user) //nolint:errcheck
                // Simulate event notification
                observer.OnEntityRegistered(ctx, user)
        }</span>

        // Unregister a user (would trigger events)
        <span class="cov0" title="0">registry.Unregister(ctx, "user-1") //nolint:errcheck
        observer.OnEntityUnregistered(ctx, "user-1")</span>
}

// UserActivityLogger implements RegistryObserver
type UserActivityLogger struct{}

func (l *UserActivityLogger) OnEntityRegistered(ctx context.Context, entity Entity) <span class="cov0" title="0">{
        fmt.Printf("USER REGISTERED: %s (%s)\n", entity.Name(), entity.ID())
}</span>

func (l *UserActivityLogger) OnEntityUnregistered(ctx context.Context, id string) <span class="cov0" title="0">{
        fmt.Printf("USER UNREGISTERED: %s\n", id)
}</span>

func (l *UserActivityLogger) OnEntityUpdated(ctx context.Context, entity Entity) <span class="cov0" title="0">{
        fmt.Printf("USER UPDATED: %s (%s)\n", entity.Name(), entity.ID())
}</span>

func (l *UserActivityLogger) OnEntityActivated(ctx context.Context, id string) <span class="cov0" title="0">{
        fmt.Printf("USER ACTIVATED: %s\n", id)
}</span>

func (l *UserActivityLogger) OnEntityDeactivated(ctx context.Context, id string) <span class="cov0" title="0">{
        fmt.Printf("USER DEACTIVATED: %s\n", id)
}</span>

// Example 8: Registry with Custom Validation
func ExampleCustomValidation() <span class="cov0" title="0">{
        // Create validator with custom rules
        validator := NewSimpleValidator().
                WithRequiredMetadata([]string{"email", "age"}).
                WithForbiddenMetadata([]string{"password", "ssn"}).
                WithValidator("email", validateEmail).
                WithValidator("age", validateAge)

        // Create registry with custom validator
        config := RegistryConfig{
                Name:             "validated-registry",
                EnableValidation: true,
        }
        registry := NewEnhancedRegistry(config).WithValidator(validator)
        ctx := context.Background()

        // Test valid user
        validUser := NewBaseEntity("user-1", "John Doe")
        validUser.Metadata()["email"] = "john@example.com"
        validUser.Metadata()["age"] = "25"

        err := registry.Register(ctx, validUser) //nolint:errcheck
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Valid user registration failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Valid user registered successfully")
        }</span>

        // Test invalid user (missing required metadata)
        <span class="cov0" title="0">invalidUser := NewBaseEntity("user-2", "Jane Smith")
        invalidUser.Metadata()["email"] = "jane@example.com"
        // Missing age

        err = registry.Register(ctx, invalidUser) //nolint:errcheck
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Invalid user correctly rejected: %v\n", err)
        }</span>

        // Test user with forbidden metadata
        <span class="cov0" title="0">forbiddenUser := NewBaseEntity("user-3", "Bob Wilson")
        forbiddenUser.Metadata()["email"] = "bob@example.com"
        forbiddenUser.Metadata()["age"] = "30"
        forbiddenUser.Metadata()["password"] = "secret123" // Forbidden

        err = registry.Register(ctx, forbiddenUser) //nolint:errcheck
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("User with forbidden metadata correctly rejected: %v\n", err)
        }</span>
}

// Validation functions
func validateEmail(email string) error <span class="cov0" title="0">{
        if len(email) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("email cannot be empty")
        }</span>
        <span class="cov0" title="0">if len(email) &lt; 5 </span><span class="cov0" title="0">{
                return fmt.Errorf("email too short")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateAge(age string) error <span class="cov0" title="0">{
        if len(age) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("age cannot be empty")
        }</span>
        // In a real implementation, you'd parse and validate the age
        <span class="cov0" title="0">return nil</span>
}

// Example 9: Registry Factory Patterns
func ExampleRegistryFactory() <span class="cov0" title="0">{
        ctx := context.Background()
        factory := NewRegistryFactory()

        // Production registry
        prodConfig := RegistryConfig{
                Name:              "production-users",
                MaxEntities:       10000,
                EnableEvents:      true,
                EnableValidation:  true,
                CacheSize:         1000,
                CacheTTL:          5 * time.Minute,
                EnablePersistence: true,
                PersistencePath:   "/data/users.json",
                AutoSaveInterval:  30 * time.Second,
        }
        prodRegistry, err := factory.Create(ctx, prodConfig) //nolint:errcheck
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">fmt.Println("Production registry created with persistence and monitoring")

        // Development registry
        devConfig := RegistryConfig{
                Name:             "development-users",
                MaxEntities:      1000,
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }
        devRegistry, err := factory.Create(ctx, devConfig) //nolint:errcheck
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">fmt.Println("Development registry created with metrics and events")

        // Test registry
        testConfig := RegistryConfig{
                Name:             "test-users",
                MaxEntities:      1000,
                EnableEvents:     false,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }
        testRegistry, err := factory.Create(ctx, testConfig) //nolint:errcheck
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">fmt.Println("Test registry created with minimal features")

        // Use the registries
        user := NewBaseEntity("test-user", "Test User")
        prodRegistry.Register(ctx, user) //nolint:errcheck
        devRegistry.Register(ctx, user)  //nolint:errcheck
        testRegistry.Register(ctx, user) //nolint:errcheck

        fmt.Println("User registered in all three registry types")</span>
}

// Example 10: Advanced Search and Filtering
func ExampleAdvancedSearch() <span class="cov0" title="0">{
        registry := NewBasicRegistry()
        ctx := context.Background()

        // Register users with various metadata
        users := []struct {
                id       string
                name     string
                email    string
                role     string
                location string
                active   bool
        }{
                {"user-1", "Alice Johnson", "alice@company.com", "admin", "NYC", true},
                {"user-2", "Bob Smith", "bob@company.com", "user", "LA", true},
                {"user-3", "Carol Davis", "carol@company.com", "manager", "NYC", false},
                {"user-4", "David Wilson", "david@company.com", "user", "Chicago", true},
                {"user-5", "Eve Brown", "eve@company.com", "admin", "LA", true},
        }

        for _, u := range users </span><span class="cov0" title="0">{
                user := NewBaseEntity(u.id, u.name)
                user.Metadata()["email"] = u.email
                user.Metadata()["role"] = u.role
                user.Metadata()["location"] = u.location
                if !u.active </span><span class="cov0" title="0">{
                        user.Metadata()["active"] = "false"
                }</span>
                <span class="cov0" title="0">registry.Register(ctx, user)</span> //nolint:errcheck
        }

        // Search by name
        <span class="cov0" title="0">aliceResults, _ := registry.Search(ctx, "Alice")
        fmt.Printf("Found %d users with 'Alice' in name\n", len(aliceResults))

        // Search by role
        admins, _ := registry.SearchByMetadata(ctx, map[string]string{"role": "admin"})
        fmt.Printf("Found %d admin users\n", len(admins))

        // Search by location
        nycUsers, _ := registry.SearchByMetadata(ctx, map[string]string{"location": "NYC"})
        fmt.Printf("Found %d users in NYC\n", len(nycUsers))

        // List active users
        activeUsers, _ := registry.ListActive(ctx)
        fmt.Printf("Found %d active users\n", len(activeUsers))

        // Count total users
        totalCount, _ := registry.Count(ctx)
        fmt.Printf("Total users: %d\n", totalCount)</span>
}

// Example 11: Registry with Health Monitoring
func ExampleHealthMonitoring() <span class="cov0" title="0">{
        // Create registry with health monitoring
        config := RegistryConfig{
                Name:             "health-monitored-registry",
                EnableEvents:     true,
                EnableValidation: true,
        }

        registry := NewEnhancedRegistry(config)
        health := NewSimpleHealth()
        registry.WithHealth(health)

        ctx := context.Background()

        // Check health status
        if health.IsHealthy(ctx) </span><span class="cov0" title="0">{
                fmt.Println("Registry is healthy")
        }</span>

        // Simulate an error
        <span class="cov0" title="0">health.SetError(fmt.Errorf("simulated error"))

        if !health.IsHealthy(ctx) </span><span class="cov0" title="0">{
                fmt.Println("Registry is unhealthy")
                status := health.GetHealthStatus(ctx)
                fmt.Printf("Health status: %+v\n", status)
        }</span>

        // Clear error
        <span class="cov0" title="0">health.ClearError()
        if health.IsHealthy(ctx) </span><span class="cov0" title="0">{
                fmt.Println("Registry is healthy again")
        }</span>
}

// Example 12: Registry Performance Benchmark
func ExamplePerformanceBenchmark() <span class="cov0" title="0">{
        // Create different registry configurations for comparison
        configs := []struct {
                name   string
                config RegistryConfig
        }{
                {
                        name: "Basic Registry",
                        config: RegistryConfig{
                                Name:             "basic",
                                EnableEvents:     false,
                                EnableValidation: false,
                        },
                },
                {
                        name: "Cached Registry",
                        config: RegistryConfig{
                                Name:             "cached",
                                EnableEvents:     false,
                                EnableValidation: false,
                                CacheSize:        1000,
                                CacheTTL:         time.Minute,
                        },
                },
                {
                        name: "Full Featured Registry",
                        config: RegistryConfig{
                                Name:             "full",
                                EnableEvents:     true,
                                EnableValidation: true,
                                CacheSize:        1000,
                                CacheTTL:         time.Minute,
                        },
                },
        }

        ctx := context.Background()

        for _, cfg := range configs </span><span class="cov0" title="0">{
                registry := NewEnhancedRegistry(cfg.config)

                // Add cache if configured
                if cfg.config.CacheSize &gt; 0 </span><span class="cov0" title="0">{
                        registry.WithCache(NewMemoryCache(cfg.config.CacheTTL))
                }</span>

                // Benchmark registration
                <span class="cov0" title="0">start := time.Now()
                for i := 1; i &lt;= 1000; i++ </span><span class="cov0" title="0">{
                        user := NewBaseEntity(fmt.Sprintf("user-%d", i), fmt.Sprintf("User %d", i))
                        registry.Register(ctx, user) //nolint:errcheck
                }</span>
                <span class="cov0" title="0">registerTime := time.Since(start)

                // Benchmark lookups
                start = time.Now()
                for i := 1; i &lt;= 1000; i++ </span><span class="cov0" title="0">{
                        registry.Get(ctx, fmt.Sprintf("user-%d", i)) //nolint:errcheck
                }</span>
                <span class="cov0" title="0">lookupTime := time.Since(start)

                fmt.Printf("%s:\n", cfg.name)
                fmt.Printf("  1000 registrations: %v\n", registerTime)
                fmt.Printf("  1000 lookups: %v\n", lookupTime)
                fmt.Printf("  Average registration: %v\n", registerTime/1000)
                fmt.Printf("  Average lookup: %v\n", lookupTime/1000)
                fmt.Println()</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package registry

import (
        "context"
        "fmt"
        "time"
)

// RegistryFactoryImpl implements RegistryFactory
type RegistryFactoryImpl struct{}

// NewRegistryFactory creates a new registry factory
func NewRegistryFactory() RegistryFactory <span class="cov8" title="1">{
        return &amp;RegistryFactoryImpl{}
}</span>

// Create creates a basic registry with the given configuration
func (f *RegistryFactoryImpl) Create(ctx context.Context, config RegistryConfig) (RegistryProvider, error) <span class="cov8" title="1">{
        registry := NewEnhancedRegistry(config)

        // Add default implementations if not provided
        if config.EnableValidation </span><span class="cov8" title="1">{
                registry.WithValidator(NewSimpleValidator())
        }</span>

        <span class="cov8" title="1">if config.CacheSize &gt; 0 </span><span class="cov8" title="1">{
                registry.WithCache(NewMemoryCache(config.CacheTTL))
        }</span>

        <span class="cov8" title="1">if config.EnableEvents </span><span class="cov8" title="1">{
                registry.WithEventBus(NewSimpleEventBus())
        }</span>

        <span class="cov8" title="1">return registry, nil</span>
}

// CreateWithPersistence creates a registry with persistence
func (f *RegistryFactoryImpl) CreateWithPersistence(ctx context.Context, config RegistryConfig, persistence RegistryPersistence) (RegistryProvider, error) <span class="cov0" title="0">{
        registry := NewEnhancedRegistry(config)

        // Add persistence
        registry.WithPersistence(persistence)

        // Load existing entities
        if entities, err := persistence.Load(ctx); err == nil </span><span class="cov0" title="0">{
                for _, entity := range entities </span><span class="cov0" title="0">{
                        if err := registry.Register(ctx, entity); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to load entity %s: %w", entity.ID(), err)
                        }</span>
                }
        }

        // Add other default implementations
        <span class="cov0" title="0">if config.EnableValidation </span><span class="cov0" title="0">{
                registry.WithValidator(NewSimpleValidator())
        }</span>

        <span class="cov0" title="0">if config.CacheSize &gt; 0 </span><span class="cov0" title="0">{
                registry.WithCache(NewMemoryCache(config.CacheTTL))
        }</span>

        <span class="cov0" title="0">if config.EnableEvents </span><span class="cov0" title="0">{
                registry.WithEventBus(NewSimpleEventBus())
        }</span>

        <span class="cov0" title="0">return registry, nil</span>
}

// CreateWithCache creates a registry with custom cache
func (f *RegistryFactoryImpl) CreateWithCache(ctx context.Context, config RegistryConfig, cache RegistryCache) (RegistryProvider, error) <span class="cov0" title="0">{
        registry := NewEnhancedRegistry(config)

        // Add custom cache
        registry.WithCache(cache)

        // Add other default implementations
        if config.EnableValidation </span><span class="cov0" title="0">{
                registry.WithValidator(NewSimpleValidator())
        }</span>

        <span class="cov0" title="0">if config.EnableEvents </span><span class="cov0" title="0">{
                registry.WithEventBus(NewSimpleEventBus())
        }</span>

        <span class="cov0" title="0">return registry, nil</span>
}

// CreateWithMetrics creates a registry with metrics
func (f *RegistryFactoryImpl) CreateWithMetrics(ctx context.Context, config RegistryConfig, metrics RegistryMetrics) (RegistryProvider, error) <span class="cov8" title="1">{
        registry := NewEnhancedRegistry(config)

        // Add metrics
        registry.WithMetrics(metrics)

        // Add other default implementations
        if config.EnableValidation </span><span class="cov8" title="1">{
                registry.WithValidator(NewSimpleValidator())
        }</span>

        <span class="cov8" title="1">if config.CacheSize &gt; 0 </span><span class="cov8" title="1">{
                registry.WithCache(NewMemoryCache(config.CacheTTL))
        }</span>

        <span class="cov8" title="1">if config.EnableEvents </span><span class="cov8" title="1">{
                registry.WithEventBus(NewSimpleEventBus())
        }</span>

        <span class="cov8" title="1">return registry, nil</span>
}

// CreateFullFeatured creates a registry with all features enabled
func (f *RegistryFactoryImpl) CreateFullFeatured(ctx context.Context, config RegistryConfig) (RegistryProvider, error) <span class="cov0" title="0">{
        registry := NewEnhancedRegistry(config)

        // Add all implementations
        registry.WithValidator(NewSimpleValidator())
        registry.WithCache(NewMemoryCache(config.CacheTTL))
        registry.WithMetrics(NewSimpleMetrics())
        registry.WithHealth(NewSimpleHealth())
        registry.WithEventBus(NewSimpleEventBus())

        // Add persistence if enabled
        if config.EnablePersistence </span><span class="cov0" title="0">{
                persistence := NewFilePersistence(config.PersistencePath)
                registry.WithPersistence(persistence)

                // Load existing entities
                if entities, err := persistence.Load(ctx); err == nil </span><span class="cov0" title="0">{
                        for _, entity := range entities </span><span class="cov0" title="0">{
                                if err := registry.Register(ctx, entity); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to load entity %s: %w", entity.ID(), err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return registry, nil</span>
}

// CreateForTesting creates a registry optimized for testing
func (f *RegistryFactoryImpl) CreateForTesting(ctx context.Context) (RegistryProvider, error) <span class="cov0" title="0">{
        config := RegistryConfig{
                Name:             "test-registry",
                MaxEntities:      1000,
                EnableEvents:     false,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }

        registry := NewEnhancedRegistry(config)
        registry.WithValidator(NewSimpleValidator())

        return registry, nil
}</span>

// CreateForProduction creates a registry optimized for production use
func (f *RegistryFactoryImpl) CreateForProduction(ctx context.Context, name string, persistencePath string) (RegistryProvider, error) <span class="cov0" title="0">{
        config := RegistryConfig{
                Name:              name,
                MaxEntities:       10000,
                EnableEvents:      true,
                EnableValidation:  true,
                CacheSize:         1000,
                CacheTTL:          5 * time.Minute,
                EnablePersistence: true,
                PersistencePath:   persistencePath,
                AutoSaveInterval:  30 * time.Second,
        }

        return f.CreateFullFeatured(ctx, config)
}</span>

// CreateForDevelopment creates a registry optimized for development
func (f *RegistryFactoryImpl) CreateForDevelopment(ctx context.Context, name string) (RegistryProvider, error) <span class="cov0" title="0">{
        config := RegistryConfig{
                Name:             name,
                MaxEntities:      1000,
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }

        registry := NewEnhancedRegistry(config)
        registry.WithValidator(NewSimpleValidator())
        registry.WithMetrics(NewSimpleMetrics())
        registry.WithEventBus(NewSimpleEventBus())

        return registry, nil
}</span>

// Convenience functions for common registry creation patterns

// NewBasicRegistry creates a basic registry with default settings
func NewBasicRegistry() RegistryProvider <span class="cov8" title="1">{
        factory := NewRegistryFactory()
        config := RegistryConfig{
                Name:             "basic-registry",
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }

        registry, _ := factory.Create(context.Background(), config)
        return registry
}</span>

// NewPersistentRegistry creates a registry with file persistence
func NewPersistentRegistry(filePath string) (RegistryProvider, error) <span class="cov0" title="0">{
        factory := NewRegistryFactory()
        config := RegistryConfig{
                Name:              "persistent-registry",
                EnableEvents:      true,
                EnableValidation:  true,
                CacheSize:         100,
                CacheTTL:          time.Minute,
                EnablePersistence: true,
                PersistencePath:   filePath,
                AutoSaveInterval:  time.Minute,
        }

        persistence := NewFilePersistence(filePath)
        return factory.CreateWithPersistence(context.Background(), config, persistence)
}</span>

// NewCachedRegistry creates a registry with enhanced caching
func NewCachedRegistry(cacheSize int, cacheTTL time.Duration) RegistryProvider <span class="cov0" title="0">{
        factory := NewRegistryFactory()
        config := RegistryConfig{
                Name:             "cached-registry",
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        cacheSize,
                CacheTTL:         cacheTTL,
        }

        registry, _ := factory.Create(context.Background(), config)
        return registry
}</span>

// NewMonitoredRegistry creates a registry with metrics and monitoring
func NewMonitoredRegistry(name string) RegistryProvider <span class="cov8" title="1">{
        factory := NewRegistryFactory()
        config := RegistryConfig{
                Name:             name,
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }

        metrics := NewSimpleMetrics()
        registry, _ := factory.CreateWithMetrics(context.Background(), config, metrics)
        return registry
}</span>

// BuildRegistry creates a registry with the built configuration
func (b *RegistryBuilder) BuildRegistry() (RegistryProvider, error) <span class="cov8" title="1">{
        factory := NewRegistryFactory()
        return factory.Create(context.Background(), b.Build())
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package registry

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "sync"
        "time"
)

// MemoryCache implements RegistryCache using in-memory storage
type MemoryCache struct {
        cache map[string]cacheEntry
        mu    sync.RWMutex
        ttl   time.Duration
}

type cacheEntry struct {
        entity    Entity
        expiresAt time.Time
}

// NewMemoryCache creates a new memory cache
func NewMemoryCache(ttl time.Duration) *MemoryCache <span class="cov8" title="1">{
        cache := &amp;MemoryCache{
                cache: make(map[string]cacheEntry),
                ttl:   ttl,
        }

        // Start cleanup goroutine
        go cache.cleanup()

        return cache
}</span>

// Get retrieves an entity from cache
func (c *MemoryCache) Get(ctx context.Context, id string) (Entity, bool) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        entry, exists := c.cache[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Check if expired
        <span class="cov8" title="1">if time.Now().After(entry.expiresAt) </span><span class="cov8" title="1">{
                delete(c.cache, id)
                return nil, false
        }</span>

        <span class="cov8" title="1">return entry.entity, true</span>
}

// Set stores an entity in cache
func (c *MemoryCache) Set(ctx context.Context, entity Entity) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.cache[entity.ID()] = cacheEntry{
                entity:    entity,
                expiresAt: time.Now().Add(c.ttl),
        }

        return nil
}</span>

// Delete removes an entity from cache
func (c *MemoryCache) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.cache, id)
        return nil
}</span>

// Clear removes all entities from cache
func (c *MemoryCache) Clear(ctx context.Context) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.cache = make(map[string]cacheEntry)
        return nil
}</span>

// Size returns the number of cached entities
func (c *MemoryCache) Size() int <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        return len(c.cache)
}</span>

// cleanup removes expired entries
func (c *MemoryCache) cleanup() <span class="cov8" title="1">{
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                c.mu.Lock()
                now := time.Now()
                for id, entry := range c.cache </span><span class="cov0" title="0">{
                        if now.After(entry.expiresAt) </span><span class="cov0" title="0">{
                                delete(c.cache, id)
                        }</span>
                }
                <span class="cov0" title="0">c.mu.Unlock()</span>
        }
}

// FilePersistence implements RegistryPersistence using file storage
type FilePersistence struct {
        filePath string
        mu       sync.Mutex
}

// NewFilePersistence creates a new file persistence layer
func NewFilePersistence(filePath string) *FilePersistence <span class="cov8" title="1">{
        return &amp;FilePersistence{
                filePath: filePath,
        }
}</span>

// Save persists entities to file
func (p *FilePersistence) Save(ctx context.Context, entities []Entity) error <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Convert entities to serializable format
        data := make([]map[string]interface{}, len(entities))
        for i, entity := range entities </span><span class="cov8" title="1">{
                data[i] = map[string]interface{}{
                        "id":         entity.ID(),
                        "name":       entity.Name(),
                        "active":     entity.Active(),
                        "metadata":   entity.Metadata(),
                        "created_at": entity.CreatedAt(),
                        "updated_at": entity.UpdatedAt(),
                }
        }</span>

        // Marshal to JSON
        <span class="cov8" title="1">jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal entities: %w", err)
        }</span>

        // Write to file
        <span class="cov8" title="1">if err := os.WriteFile(p.filePath, jsonData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Load loads entities from file
func (p *FilePersistence) Load(ctx context.Context) ([]Entity, error) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Check if file exists
        if _, err := os.Stat(p.filePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return []Entity{}, nil
        }</span>

        // Read file
        <span class="cov8" title="1">data, err := os.ReadFile(p.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        // Unmarshal JSON
        <span class="cov8" title="1">var rawData []map[string]interface{}
        if err := json.Unmarshal(data, &amp;rawData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal data: %w", err)
        }</span>

        // Convert to entities
        <span class="cov8" title="1">entities := make([]Entity, len(rawData))
        for i, raw := range rawData </span><span class="cov8" title="1">{
                // Parse timestamps
                createdAt, _ := time.Parse(time.RFC3339, raw["created_at"].(string))
                updatedAt, _ := time.Parse(time.RFC3339, raw["updated_at"].(string))

                // Parse metadata
                metadata := make(map[string]string)
                if rawMetadata, ok := raw["metadata"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        for k, v := range rawMetadata </span><span class="cov0" title="0">{
                                if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                                        metadata[k] = str
                                }</span>
                        }
                }

                <span class="cov8" title="1">entities[i] = &amp;BaseEntity{
                        BEId:        raw["id"].(string),
                        BEName:      raw["name"].(string),
                        BEActive:    raw["active"].(bool),
                        BEMetadata:  metadata,
                        BECreatedAt: createdAt,
                        BEUpdatedAt: updatedAt,
                }</span>
        }

        <span class="cov8" title="1">return entities, nil</span>
}

// Delete removes the persistence file
func (p *FilePersistence) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        // For file persistence, we don't delete individual entities
        // The entire file is rewritten on save
        return nil
}</span>

// Clear removes the persistence file
func (p *FilePersistence) Clear(ctx context.Context) error <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        return os.Remove(p.filePath)
}</span>

// SimpleMetrics implements RegistryMetrics using simple counters
type SimpleMetrics struct {
        registrations   int64
        unregistrations int64
        lookups         int64
        errors          int64
        entityCount     int
        activeCount     int
        latencies       map[string][]time.Duration
        mu              sync.RWMutex
}

// NewSimpleMetrics creates a new simple metrics collector
func NewSimpleMetrics() *SimpleMetrics <span class="cov8" title="1">{
        return &amp;SimpleMetrics{
                latencies: make(map[string][]time.Duration),
        }
}</span>

// IncrementRegistration increments the registration counter
func (m *SimpleMetrics) IncrementRegistration() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.registrations++
}</span>

// IncrementUnregistration increments the unregistration counter
func (m *SimpleMetrics) IncrementUnregistration() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.unregistrations++
}</span>

// IncrementLookup increments the lookup counter
func (m *SimpleMetrics) IncrementLookup() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.lookups++
}</span>

// IncrementError increments the error counter
func (m *SimpleMetrics) IncrementError() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.errors++
}</span>

// SetEntityCount sets the entity count
func (m *SimpleMetrics) SetEntityCount(count int) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.entityCount = count
}</span>

// SetActiveCount sets the active entity count
func (m *SimpleMetrics) SetActiveCount(count int) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.activeCount = count
}</span>

// RecordLatency records operation latency
func (m *SimpleMetrics) RecordLatency(operation string, duration time.Duration) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.latencies[operation] == nil </span><span class="cov8" title="1">{
                m.latencies[operation] = make([]time.Duration, 0)
        }</span>
        <span class="cov8" title="1">m.latencies[operation] = append(m.latencies[operation], duration)

        // Keep only last 100 latencies per operation
        if len(m.latencies[operation]) &gt; 100 </span><span class="cov0" title="0">{
                m.latencies[operation] = m.latencies[operation][len(m.latencies[operation])-100:]
        }</span>
}

// GetStats returns current metrics statistics
func (m *SimpleMetrics) GetStats() map[string]interface{} <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        stats := map[string]interface{}{
                "registrations":   m.registrations,
                "unregistrations": m.unregistrations,
                "lookups":         m.lookups,
                "errors":          m.errors,
                "entity_count":    m.entityCount,
                "active_count":    m.activeCount,
                "latencies":       m.latencies,
        }

        return stats
}</span>

// SimpleEventBus implements RegistryEventBus using in-memory event handling
type SimpleEventBus struct {
        observers []RegistryObserver
        mu        sync.RWMutex
}

// NewSimpleEventBus creates a new simple event bus
func NewSimpleEventBus() *SimpleEventBus <span class="cov8" title="1">{
        return &amp;SimpleEventBus{
                observers: make([]RegistryObserver, 0),
        }
}</span>

// Subscribe adds an observer to the event bus
func (b *SimpleEventBus) Subscribe(observer RegistryObserver) error <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        b.observers = append(b.observers, observer)
        return nil
}</span>

// Unsubscribe removes an observer from the event bus
func (b *SimpleEventBus) Unsubscribe(observer RegistryObserver) error <span class="cov0" title="0">{
        b.mu.Lock()
        defer b.mu.Unlock()

        for i, obs := range b.observers </span><span class="cov0" title="0">{
                if obs == observer </span><span class="cov0" title="0">{
                        b.observers = append(b.observers[:i], b.observers[i+1:]...)
                        break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Publish publishes an event to all observers
func (b *SimpleEventBus) Publish(ctx context.Context, event RegistryEvent) error <span class="cov8" title="1">{
        b.mu.RLock()
        observers := make([]RegistryObserver, len(b.observers))
        copy(observers, b.observers)
        b.mu.RUnlock()

        for _, observer := range observers </span><span class="cov8" title="1">{
                switch event.Type </span>{
                case EventEntityRegistered:<span class="cov8" title="1">
                        observer.OnEntityRegistered(ctx, event.Entity)</span>
                case EventEntityUnregistered:<span class="cov8" title="1">
                        observer.OnEntityUnregistered(ctx, event.EntityID)</span>
                case EventEntityUpdated:<span class="cov0" title="0">
                        observer.OnEntityUpdated(ctx, event.Entity)</span>
                case EventEntityActivated:<span class="cov0" title="0">
                        observer.OnEntityActivated(ctx, event.EntityID)</span>
                case EventEntityDeactivated:<span class="cov0" title="0">
                        observer.OnEntityDeactivated(ctx, event.EntityID)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// SimpleValidator implements RegistryValidator with basic validation
type SimpleValidator struct {
        requiredMetadata  []string
        forbiddenMetadata []string
        validators        map[string]func(string) error
}

// NewSimpleValidator creates a new simple validator
func NewSimpleValidator() *SimpleValidator <span class="cov8" title="1">{
        return &amp;SimpleValidator{
                requiredMetadata:  make([]string, 0),
                forbiddenMetadata: make([]string, 0),
                validators:        make(map[string]func(string) error),
        }
}</span>

// WithRequiredMetadata sets required metadata fields
func (v *SimpleValidator) WithRequiredMetadata(fields []string) *SimpleValidator <span class="cov0" title="0">{
        v.requiredMetadata = fields
        return v
}</span>

// WithForbiddenMetadata sets forbidden metadata fields
func (v *SimpleValidator) WithForbiddenMetadata(fields []string) *SimpleValidator <span class="cov0" title="0">{
        v.forbiddenMetadata = fields
        return v
}</span>

// WithValidator adds a custom validator for a metadata field
func (v *SimpleValidator) WithValidator(field string, validator func(string) error) *SimpleValidator <span class="cov0" title="0">{
        v.validators[field] = validator
        return v
}</span>

// Validate validates an entity
func (v *SimpleValidator) Validate(ctx context.Context, entity Entity) error <span class="cov8" title="1">{
        // Validate required fields
        if entity.ID() == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("entity ID cannot be empty")
        }</span>
        <span class="cov8" title="1">if entity.Name() == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("entity name cannot be empty")
        }</span>

        // Validate metadata
        <span class="cov8" title="1">return v.ValidateMetadata(ctx, entity.Metadata())</span>
}

// ValidateMetadata validates entity metadata
func (v *SimpleValidator) ValidateMetadata(ctx context.Context, metadata map[string]string) error <span class="cov8" title="1">{
        // Check required metadata
        for _, required := range v.requiredMetadata </span><span class="cov0" title="0">{
                if _, exists := metadata[required]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("required metadata field missing: %s", required)
                }</span>
        }

        // Check forbidden metadata
        <span class="cov8" title="1">for _, forbidden := range v.forbiddenMetadata </span><span class="cov0" title="0">{
                if _, exists := metadata[forbidden]; exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("forbidden metadata field present: %s", forbidden)
                }</span>
        }

        // Run custom validators
        <span class="cov8" title="1">for field, validator := range v.validators </span><span class="cov0" title="0">{
                if value, exists := metadata[field]; exists </span><span class="cov0" title="0">{
                        if err := validator(value); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("validation failed for field %s: %w", field, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// SimpleHealth implements RegistryHealth with basic health checking
type SimpleHealth struct {
        lastError error
        mu        sync.RWMutex
}

// NewSimpleHealth creates a new simple health checker
func NewSimpleHealth() *SimpleHealth <span class="cov0" title="0">{
        return &amp;SimpleHealth{}
}</span>

// IsHealthy checks if the registry is healthy
func (h *SimpleHealth) IsHealthy(ctx context.Context) bool <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        return h.lastError == nil
}</span>

// GetHealthStatus returns the health status
func (h *SimpleHealth) GetHealthStatus(ctx context.Context) map[string]interface{} <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        status := map[string]interface{}{
                "healthy":   h.lastError == nil,
                "timestamp": time.Now(),
        }

        if h.lastError != nil </span><span class="cov0" title="0">{
                status["last_error"] = h.lastError.Error()
        }</span>

        <span class="cov0" title="0">return status</span>
}

// GetLastError returns the last error
func (h *SimpleHealth) GetLastError() error <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        return h.lastError
}</span>

// SetError sets the last error
func (h *SimpleHealth) SetError(err error) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        h.lastError = err
}</span>

// ClearError clears the last error
func (h *SimpleHealth) ClearError() <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        h.lastError = nil
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package registry

import (
        "context"
        "time"
)

// Entity represents any entity that can be registered
type Entity interface {
        ID() string
        Name() string
        Active() bool
        Metadata() map[string]string
        CreatedAt() time.Time
        UpdatedAt() time.Time
}

// RegistryProvider defines the interface for registry implementations
type RegistryProvider interface {
        // Core operations
        Register(ctx context.Context, entity Entity) error
        Get(ctx context.Context, id string) (Entity, error)
        Unregister(ctx context.Context, id string) error
        IsRegistered(ctx context.Context, id string) bool

        // Listing operations
        List(ctx context.Context) ([]Entity, error)
        ListActive(ctx context.Context) ([]Entity, error)
        ListByMetadata(ctx context.Context, key, value string) ([]Entity, error)

        // Counting operations
        Count(ctx context.Context) (int, error)
        CountActive(ctx context.Context) (int, error)

        // Metadata operations
        GetMetadata(ctx context.Context, id, key string) (string, error)
        SetMetadata(ctx context.Context, id, key, value string) error
        RemoveMetadata(ctx context.Context, id, key string) error

        // Lifecycle operations
        Activate(ctx context.Context, id string) error
        Deactivate(ctx context.Context, id string) error

        // Search operations
        Search(ctx context.Context, query string) ([]Entity, error)
        SearchByMetadata(ctx context.Context, metadata map[string]string) ([]Entity, error)
}

// RegistryObserver defines the interface for registry event observers
type RegistryObserver interface {
        OnEntityRegistered(ctx context.Context, entity Entity)
        OnEntityUnregistered(ctx context.Context, id string)
        OnEntityUpdated(ctx context.Context, entity Entity)
        OnEntityActivated(ctx context.Context, id string)
        OnEntityDeactivated(ctx context.Context, id string)
}

// RegistryEvent represents a registry event
type RegistryEvent struct {
        Type      string                 `json:"type"`
        EntityID  string                 `json:"entity_id"`
        Entity    Entity                 `json:"entity,omitempty"`
        Timestamp time.Time              `json:"timestamp"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// RegistryEventType constants
const (
        EventEntityRegistered   = "entity_registered"
        EventEntityUnregistered = "entity_unregistered"
        EventEntityUpdated      = "entity_updated"
        EventEntityActivated    = "entity_activated"
        EventEntityDeactivated  = "entity_deactivated"
)

// RegistryEventBus defines the interface for registry event handling
type RegistryEventBus interface {
        Subscribe(observer RegistryObserver) error
        Unsubscribe(observer RegistryObserver) error
        Publish(ctx context.Context, event RegistryEvent) error
}

// RegistryConfig holds configuration for registry implementations
type RegistryConfig struct {
        // General settings
        Name             string        `json:"name"`
        MaxEntities      int           `json:"max_entities"`
        DefaultTTL       time.Duration `json:"default_ttl"`
        EnableEvents     bool          `json:"enable_events"`
        EnableValidation bool          `json:"enable_validation"`

        // Performance settings
        CacheSize         int           `json:"cache_size"`
        CacheTTL          time.Duration `json:"cache_ttl"`
        EnableCompression bool          `json:"enable_compression"`

        // Persistence settings
        EnablePersistence bool          `json:"enable_persistence"`
        PersistencePath   string        `json:"persistence_path"`
        AutoSaveInterval  time.Duration `json:"auto_save_interval"`

        // Validation settings
        RequiredMetadata   []string                      `json:"required_metadata"`
        ForbiddenMetadata  []string                      `json:"forbidden_metadata"`
        MetadataValidators map[string]func(string) error `json:"-"`
}

// RegistryValidator defines the interface for entity validation
type RegistryValidator interface {
        Validate(ctx context.Context, entity Entity) error
        ValidateMetadata(ctx context.Context, metadata map[string]string) error
}

// RegistryPersistence defines the interface for registry persistence
type RegistryPersistence interface {
        Save(ctx context.Context, entities []Entity) error
        Load(ctx context.Context) ([]Entity, error)
        Delete(ctx context.Context, id string) error
        Clear(ctx context.Context) error
}

// RegistryCache defines the interface for registry caching
type RegistryCache interface {
        Get(ctx context.Context, id string) (Entity, bool)
        Set(ctx context.Context, entity Entity) error
        Delete(ctx context.Context, id string) error
        Clear(ctx context.Context) error
        Size() int
}

// RegistryMetrics defines the interface for registry metrics
type RegistryMetrics interface {
        IncrementRegistration()
        IncrementUnregistration()
        IncrementLookup()
        IncrementError()
        SetEntityCount(count int)
        SetActiveCount(count int)
        RecordLatency(operation string, duration time.Duration)
}

// RegistryHealth defines the interface for registry health checks
type RegistryHealth interface {
        IsHealthy(ctx context.Context) bool
        GetHealthStatus(ctx context.Context) map[string]interface{}
        GetLastError() error
}

// RegistryFactory defines the interface for creating registry instances
type RegistryFactory interface {
        Create(ctx context.Context, config RegistryConfig) (RegistryProvider, error)
        CreateWithPersistence(ctx context.Context, config RegistryConfig, persistence RegistryPersistence) (RegistryProvider, error)
        CreateWithCache(ctx context.Context, config RegistryConfig, cache RegistryCache) (RegistryProvider, error)
        CreateWithMetrics(ctx context.Context, config RegistryConfig, metrics RegistryMetrics) (RegistryProvider, error)
}

// BaseEntity provides a default implementation of the Entity interface
type BaseEntity struct {
        BEId        string            `json:"id"`
        BEName      string            `json:"name"`
        BEActive    bool              `json:"active"`
        BEMetadata  map[string]string `json:"metadata,omitempty"`
        BECreatedAt time.Time         `json:"created_at"`
        BEUpdatedAt time.Time         `json:"updated_at"`
}

// Property-style getter methods to implement Entity interface
func (e *BaseEntity) ID() string   <span class="cov8" title="1">{ return e.BEId }</span>
func (e *BaseEntity) Name() string <span class="cov8" title="1">{ return e.BEName }</span>
func (e *BaseEntity) Active() bool <span class="cov8" title="1">{ return e.BEActive }</span>
func (e *BaseEntity) Metadata() map[string]string <span class="cov8" title="1">{
        if e.BEMetadata == nil </span><span class="cov0" title="0">{
                e.BEMetadata = make(map[string]string)
        }</span>
        <span class="cov8" title="1">return e.BEMetadata</span>
}
func (e *BaseEntity) CreatedAt() time.Time <span class="cov8" title="1">{ return e.BECreatedAt }</span>
func (e *BaseEntity) UpdatedAt() time.Time <span class="cov8" title="1">{ return e.BEUpdatedAt }</span>

// Add a compile-time check to ensure BaseEntity implements the Entity interface.
var _ Entity = (*BaseEntity)(nil)

// NewBaseEntity creates a new base entity
func NewBaseEntity(id, name string) *BaseEntity <span class="cov8" title="1">{
        now := time.Now()
        return &amp;BaseEntity{
                BEId:        id,
                BEName:      name,
                BEActive:    true,
                BEMetadata:  make(map[string]string),
                BECreatedAt: now,
                BEUpdatedAt: now,
        }
}</span>

// RegistryBuilder provides a fluent interface for building registry configurations
type RegistryBuilder struct {
        config RegistryConfig
}

// NewRegistryBuilder creates a new registry builder
func NewRegistryBuilder() *RegistryBuilder <span class="cov8" title="1">{
        return &amp;RegistryBuilder{
                config: RegistryConfig{
                        EnableEvents:     true,
                        EnableValidation: true,
                        CacheSize:        1000,
                        CacheTTL:         5 * time.Minute,
                },
        }
}</span>

// WithName sets the registry name
func (b *RegistryBuilder) WithName(name string) *RegistryBuilder <span class="cov8" title="1">{
        b.config.Name = name
        return b
}</span>

// WithMaxEntities sets the maximum number of entities
func (b *RegistryBuilder) WithMaxEntities(max int) *RegistryBuilder <span class="cov8" title="1">{
        b.config.MaxEntities = max
        return b
}</span>

// WithDefaultTTL sets the default TTL for entities
func (b *RegistryBuilder) WithDefaultTTL(ttl time.Duration) *RegistryBuilder <span class="cov0" title="0">{
        b.config.DefaultTTL = ttl
        return b
}</span>

// WithCache sets cache configuration
func (b *RegistryBuilder) WithCache(size int, ttl time.Duration) *RegistryBuilder <span class="cov8" title="1">{
        b.config.CacheSize = size
        b.config.CacheTTL = ttl
        return b
}</span>

// WithPersistence enables persistence with the given path
func (b *RegistryBuilder) WithPersistence(path string, interval time.Duration) *RegistryBuilder <span class="cov8" title="1">{
        b.config.EnablePersistence = true
        b.config.PersistencePath = path
        b.config.AutoSaveInterval = interval
        return b
}</span>

// WithValidation sets validation configuration
func (b *RegistryBuilder) WithValidation(required, forbidden []string) *RegistryBuilder <span class="cov8" title="1">{
        b.config.RequiredMetadata = required
        b.config.ForbiddenMetadata = forbidden
        return b
}</span>

// Build returns the built configuration
func (b *RegistryBuilder) Build() RegistryConfig <span class="cov8" title="1">{
        return b.config
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package registry

import (
        "sync"
)

// Meta represents generic metadata that can be associated with any entity
type Meta struct {
        // Generic fields that can be used by any registry
        ID       string            `json:"id"`
        Name     string            `json:"name"`
        Active   bool              `json:"active"`
        Metadata map[string]string `json:"metadata,omitempty"`
}

// Registry is a generic, thread-safe registry for managing any type of entity
type Registry struct {
        entities map[string]Meta
        mu       sync.RWMutex
}

// NewRegistry creates a new empty registry
func NewRegistry() *Registry <span class="cov8" title="1">{
        return &amp;Registry{
                entities: make(map[string]Meta),
        }
}</span>

// Register adds or updates an entity in the registry
func (r *Registry) Register(id string, meta Meta) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        meta.ID = id // Ensure ID is set
        r.entities[id] = meta
}</span>

// Get returns entity metadata for the given ID
// Returns empty Meta if the entity is not found
func (r *Registry) Get(id string) Meta <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if meta, exists := r.entities[id]; exists </span><span class="cov8" title="1">{
                return meta
        }</span>

        // Return empty meta for unknown entities
        <span class="cov8" title="1">return Meta{ID: id, Active: false}</span>
}

// IsRegistered checks if an entity ID is registered
func (r *Registry) IsRegistered(id string) bool <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        _, exists := r.entities[id]
        return exists
}</span>

// ListRegistered returns a list of all registered entity IDs
func (r *Registry) ListRegistered() []string <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        ids := make([]string, 0, len(r.entities))
        for id := range r.entities </span><span class="cov8" title="1">{
                ids = append(ids, id)
        }</span>
        <span class="cov8" title="1">return ids</span>
}

// ListActive returns a list of all active entity IDs
func (r *Registry) ListActive() []string <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        ids := make([]string, 0)
        for id, meta := range r.entities </span><span class="cov8" title="1">{
                if meta.Active </span><span class="cov8" title="1">{
                        ids = append(ids, id)
                }</span>
        }
        <span class="cov8" title="1">return ids</span>
}

// Unregister removes an entity from the registry
func (r *Registry) Unregister(id string) bool <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.entities[id]; exists </span><span class="cov8" title="1">{
                delete(r.entities, id)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Count returns the total number of registered entities
func (r *Registry) Count() int <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return len(r.entities)
}</span>

// GetMetadata returns a specific metadata value for an entity
func (r *Registry) GetMetadata(id, key string) (string, bool) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if meta, exists := r.entities[id]; exists </span><span class="cov8" title="1">{
                if meta.Metadata != nil </span><span class="cov8" title="1">{
                        value, found := meta.Metadata[key]
                        return value, found
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

// SetMetadata sets a specific metadata value for an entity
func (r *Registry) SetMetadata(id, key, value string) bool <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if meta, exists := r.entities[id]; exists </span><span class="cov8" title="1">{
                if meta.Metadata == nil </span><span class="cov8" title="1">{
                        meta.Metadata = make(map[string]string)
                }</span>
                <span class="cov8" title="1">meta.Metadata[key] = value
                r.entities[id] = meta
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Global registry instance for convenience
var globalRegistry = NewRegistry()

// Global convenience functions
func Register(id string, meta Meta) <span class="cov8" title="1">{
        globalRegistry.Register(id, meta)
}</span>

func Get(id string) Meta <span class="cov8" title="1">{
        return globalRegistry.Get(id)
}</span>

func IsRegistered(id string) bool <span class="cov8" title="1">{
        return globalRegistry.IsRegistered(id)
}</span>

func ListRegistered() []string <span class="cov8" title="1">{
        return globalRegistry.ListRegistered()
}</span>

func ListActive() []string <span class="cov8" title="1">{
        return globalRegistry.ListActive()
}</span>

func Unregister(id string) bool <span class="cov8" title="1">{
        return globalRegistry.Unregister(id)
}</span>

func Count() int <span class="cov8" title="1">{
        return globalRegistry.Count()
}</span>

func GetMetadata(id, key string) (string, bool) <span class="cov8" title="1">{
        return globalRegistry.GetMetadata(id, key)
}</span>

func SetMetadata(id, key, value string) bool <span class="cov8" title="1">{
        return globalRegistry.SetMetadata(id, key, value)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package repository

import (
        "context"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/google/uuid"
)

// CleanGenericRepository provides type-safe CRUD operations without infrastructure coupling
type CleanGenericRepository[T any] interface {
        // Basic CRUD operations
        Create(ctx context.Context, entity *T) error
        Get(ctx context.Context, id uuid.UUID) (*T, error)
        Update(ctx context.Context, entity *T) error
        Delete(ctx context.Context, id uuid.UUID) error

        // Query operations
        List(ctx context.Context) ([]*T, error)
        FindBy(ctx context.Context, query interface{}, args ...interface{}) ([]*T, error)
        FindOneBy(ctx context.Context, query interface{}, args ...interface{}) (*T, error)
}

// CleanUnitOfWork provides transaction management without infrastructure details
type CleanUnitOfWork interface {
        // Do executes a function within a transaction boundary
        Do(ctx context.Context, fn func(CleanUnitOfWork) error) error

        // Type-safe repository access methods
        AccountRepository() CleanGenericRepository[account.Account]
        TransactionRepository() CleanGenericRepository[account.Transaction]
        UserRepository() CleanGenericRepository[user.User]
}

// CleanUnitOfWorkImpl implements CleanUnitOfWork
type CleanUnitOfWorkImpl struct {
        accountRepo     CleanGenericRepository[account.Account]
        transactionRepo CleanGenericRepository[account.Transaction]
        userRepo        CleanGenericRepository[user.User]
        transactionMgr  TransactionManager
}

// TransactionManager abstracts transaction management
type TransactionManager interface {
        // ExecuteInTransaction runs a function within a transaction
        ExecuteInTransaction(ctx context.Context, fn func() error) error
}

// NewCleanUnitOfWork creates a new clean UOW instance
func NewCleanUnitOfWork(
        accountRepo CleanGenericRepository[account.Account],
        transactionRepo CleanGenericRepository[account.Transaction],
        userRepo CleanGenericRepository[user.User],
        txMgr TransactionManager,
) CleanUnitOfWork <span class="cov0" title="0">{
        return &amp;CleanUnitOfWorkImpl{
                accountRepo:     accountRepo,
                transactionRepo: transactionRepo,
                userRepo:        userRepo,
                transactionMgr:  txMgr,
        }
}</span>

// Do executes a function within a transaction
func (uow *CleanUnitOfWorkImpl) Do(ctx context.Context, fn func(CleanUnitOfWork) error) error <span class="cov0" title="0">{
        return uow.transactionMgr.ExecuteInTransaction(ctx, func() error </span><span class="cov0" title="0">{
                return fn(uow)
        }</span>)
}

// AccountRepository returns the account repository
func (uow *CleanUnitOfWorkImpl) AccountRepository() CleanGenericRepository[account.Account] <span class="cov0" title="0">{
        return uow.accountRepo
}</span>

// TransactionRepository returns the transaction repository
func (uow *CleanUnitOfWorkImpl) TransactionRepository() CleanGenericRepository[account.Transaction] <span class="cov0" title="0">{
        return uow.transactionRepo
}</span>

// UserRepository returns the user repository
func (uow *CleanUnitOfWorkImpl) UserRepository() CleanGenericRepository[user.User] <span class="cov0" title="0">{
        return uow.userRepo
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package repository

import (
        "context"

        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

// GenericRepository provides type-safe CRUD operations for any entity
type GenericRepository[T any] interface {
        // Basic CRUD operations
        Create(ctx context.Context, entity *T) error
        Get(ctx context.Context, id uuid.UUID) (*T, error)
        Update(ctx context.Context, entity *T) error
        Delete(ctx context.Context, id uuid.UUID) error

        // Query operations
        List(ctx context.Context) ([]*T, error)
        FindBy(ctx context.Context, query interface{}, args ...interface{}) ([]*T, error)
        FindOneBy(ctx context.Context, query interface{}, args ...interface{}) (*T, error)

        // Transaction support
        WithTransaction(tx *gorm.DB) GenericRepository[T]
}

// GenericRepositoryImpl implements GenericRepository for any entity type
type GenericRepositoryImpl[T any] struct {
        db *gorm.DB
}

// NewGenericRepository creates a new generic repository
func NewGenericRepository[T any](db *gorm.DB) GenericRepository[T] <span class="cov0" title="0">{
        return &amp;GenericRepositoryImpl[T]{
                db: db,
        }
}</span>

// Create saves a new entity to the database
func (r *GenericRepositoryImpl[T]) Create(ctx context.Context, entity *T) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(entity).Error
}</span>

// Get retrieves an entity by ID
func (r *GenericRepositoryImpl[T]) Get(ctx context.Context, id uuid.UUID) (*T, error) <span class="cov0" title="0">{
        var entity T
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;entity).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;entity, nil</span>
}

// Update modifies an existing entity
func (r *GenericRepositoryImpl[T]) Update(ctx context.Context, entity *T) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(entity).Error
}</span>

// Delete removes an entity by ID
func (r *GenericRepositoryImpl[T]) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Where("id = ?", id).Delete(new(T)).Error
}</span>

// List retrieves all entities
func (r *GenericRepositoryImpl[T]) List(ctx context.Context) ([]*T, error) <span class="cov0" title="0">{
        var entities []*T
        err := r.db.WithContext(ctx).Find(&amp;entities).Error
        return entities, err
}</span>

// FindBy retrieves entities matching the query
func (r *GenericRepositoryImpl[T]) FindBy(ctx context.Context, query interface{}, args ...interface{}) ([]*T, error) <span class="cov0" title="0">{
        var entities []*T
        err := r.db.WithContext(ctx).Where(query, args...).Find(&amp;entities).Error
        return entities, err
}</span>

// FindOneBy retrieves a single entity matching the query
func (r *GenericRepositoryImpl[T]) FindOneBy(ctx context.Context, query interface{}, args ...interface{}) (*T, error) <span class="cov0" title="0">{
        var entity T
        err := r.db.WithContext(ctx).Where(query, args...).First(&amp;entity).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;entity, nil</span>
}

// WithTransaction returns a new repository instance using the provided transaction
func (r *GenericRepositoryImpl[T]) WithTransaction(tx *gorm.DB) GenericRepository[T] <span class="cov0" title="0">{
        return &amp;GenericRepositoryImpl[T]{
                db: tx,
        }
}</span>

// GenericUnitOfWorkWithGenerics provides type-safe repository access using generics
type GenericUnitOfWorkWithGenerics interface {
        // Transaction management
        Do(ctx context.Context, fn func(GenericUnitOfWorkWithGenerics) error) error
}

// GenericUnitOfWorkWithGenericsImpl implements the generic UOW interface
type GenericUnitOfWorkWithGenericsImpl struct {
        db *gorm.DB
        tx *gorm.DB
}

// NewGenericUnitOfWorkWithGenerics creates a new generic UOW instance
func NewGenericUnitOfWorkWithGenerics(db *gorm.DB) GenericUnitOfWorkWithGenerics <span class="cov0" title="0">{
        return &amp;GenericUnitOfWorkWithGenericsImpl{
                db: db,
        }
}</span>

// Do executes a function within a transaction
func (uow *GenericUnitOfWorkWithGenericsImpl) Do(ctx context.Context, fn func(GenericUnitOfWorkWithGenerics) error) error <span class="cov0" title="0">{
        return uow.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                txnUow := &amp;GenericUnitOfWorkWithGenericsImpl{
                        db: uow.db,
                        tx: tx,
                }
                return fn(txnUow)
        }</span>)
}

// Repository returns a generic repository for the specified entity type
func (uow *GenericUnitOfWorkWithGenericsImpl) Repository(entityType interface{}) interface{} <span class="cov0" title="0">{
        db := uow.db
        if uow.tx != nil </span><span class="cov0" title="0">{
                db = uow.tx
        }</span>

        // This is a simplified version - in practice you'd want type-safe access
        <span class="cov0" title="0">switch entityType.(type) </span>{
        case *domain.Account:<span class="cov0" title="0">
                return NewGenericRepository[domain.Account](db)</span>
        case *domain.Transaction:<span class="cov0" title="0">
                return NewGenericRepository[domain.Transaction](db)</span>
        case *domain.User:<span class="cov0" title="0">
                return NewGenericRepository[domain.User](db)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package repository

import (
        "context"
        "fmt"
)

// GenericUnitOfWork provides type-safe repository access using generics
type GenericUnitOfWork interface {
        // Transaction management
        Do(ctx context.Context, fn func(GenericUnitOfWork) error) error
}

// GenericUnitOfWorkImpl implements the generic UOW interface
type GenericUnitOfWorkImpl struct {
        repositories map[string]any
}

// NewGenericUnitOfWork creates a new generic UOW instance
func NewGenericUnitOfWork() *GenericUnitOfWorkImpl <span class="cov0" title="0">{
        return &amp;GenericUnitOfWorkImpl{
                repositories: make(map[string]any),
        }
}</span>

// RegisterRepository registers a repository with a type key
func (uow *GenericUnitOfWorkImpl) RegisterRepository(repo any) <span class="cov0" title="0">{
        typeName := fmt.Sprintf("%T", repo)
        uow.repositories[typeName] = repo
}</span>

// GetRepository retrieves a repository by type
func (uow *GenericUnitOfWorkImpl) GetRepository(repoType interface{}) (interface{}, error) <span class="cov0" title="0">{
        typeName := fmt.Sprintf("%T", repoType)

        repo, exists := uow.repositories[typeName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("repository not found for type: %s", typeName)
        }</span>

        <span class="cov0" title="0">return repo, nil</span>
}

// Do executes a function within a transaction
func (uow *GenericUnitOfWorkImpl) Do(ctx context.Context, fn func(GenericUnitOfWork) error) error <span class="cov0" title="0">{
        // Transaction logic here
        return fn(uow)
}</span>

// Type-safe helper methods for common repositories
func (uow *GenericUnitOfWorkImpl) GetAccountRepository() (AccountRepository, error) <span class="cov0" title="0">{
        repo, err := uow.GetRepository((*AccountRepository)(nil))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if accountRepo, ok := repo.(AccountRepository); ok </span><span class="cov0" title="0">{
                return accountRepo, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("repository is not AccountRepository")</span>
}

func (uow *GenericUnitOfWorkImpl) GetTransactionRepository() (TransactionRepository, error) <span class="cov0" title="0">{
        repo, err := uow.GetRepository((*TransactionRepository)(nil))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if txRepo, ok := repo.(TransactionRepository); ok </span><span class="cov0" title="0">{
                return txRepo, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("repository is not TransactionRepository")</span>
}

func (uow *GenericUnitOfWorkImpl) GetUserRepository() (UserRepository, error) <span class="cov0" title="0">{
        repo, err := uow.GetRepository((*UserRepository)(nil))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if userRepo, ok := repo.(UserRepository); ok </span><span class="cov0" title="0">{
                return userRepo, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("repository is not UserRepository")</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package repository

import (
        "context"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "gorm.io/gorm"
)

// CompleteGenericUnitOfWork provides type-safe repository access using generics
type CompleteGenericUnitOfWork interface {
        // Transaction management
        Do(ctx context.Context, fn func(CompleteGenericUnitOfWork) error) error

        // Type-safe repository access methods
        AccountRepository() GenericRepository[account.Account]
        TransactionRepository() GenericRepository[account.Transaction]
        UserRepository() GenericRepository[user.User]
}

// CompleteGenericUnitOfWorkImpl implements the complete generic UOW interface
type CompleteGenericUnitOfWorkImpl struct {
        db              *gorm.DB
        tx              *gorm.DB
        accountRepo     GenericRepository[account.Account]
        transactionRepo GenericRepository[account.Transaction]
        userRepo        GenericRepository[user.User]
}

// NewCompleteGenericUnitOfWork creates a new complete generic UOW instance
func NewCompleteGenericUnitOfWork(db *gorm.DB) CompleteGenericUnitOfWork <span class="cov0" title="0">{
        return &amp;CompleteGenericUnitOfWorkImpl{
                db:              db,
                accountRepo:     NewGenericRepository[account.Account](db),
                transactionRepo: NewGenericRepository[account.Transaction](db),
                userRepo:        NewGenericRepository[user.User](db),
        }
}</span>

// Do executes a function within a transaction
func (uow *CompleteGenericUnitOfWorkImpl) Do(ctx context.Context, fn func(CompleteGenericUnitOfWork) error) error <span class="cov0" title="0">{
        return uow.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                txnUow := &amp;CompleteGenericUnitOfWorkImpl{
                        db:              uow.db,
                        tx:              tx,
                        accountRepo:     NewGenericRepository[account.Account](tx),
                        transactionRepo: NewGenericRepository[account.Transaction](tx),
                        userRepo:        NewGenericRepository[user.User](tx),
                }
                return fn(txnUow)
        }</span>)
}

// AccountRepository returns the account repository
func (uow *CompleteGenericUnitOfWorkImpl) AccountRepository() GenericRepository[account.Account] <span class="cov0" title="0">{
        return uow.accountRepo
}</span>

// TransactionRepository returns the transaction repository
func (uow *CompleteGenericUnitOfWorkImpl) TransactionRepository() GenericRepository[account.Transaction] <span class="cov0" title="0">{
        return uow.transactionRepo
}</span>

// UserRepository returns the user repository
func (uow *CompleteGenericUnitOfWorkImpl) UserRepository() GenericRepository[user.User] <span class="cov0" title="0">{
        return uow.userRepo
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package repository

import (
        "context"
        "fmt"
        "reflect"
)

// HybridUnitOfWork combines the current reflect-based approach with type-safe alternatives
type HybridUnitOfWork interface {
        // Current interface (for backward compatibility)
        Do(ctx context.Context, fn func(uow HybridUnitOfWork) error) error
        GetRepository(repoType reflect.Type) (any, error)

        // Type-safe alternatives (preferred)
        AccountRepository() AccountRepository
        TransactionRepository() TransactionRepository
        UserRepository() UserRepository
}

// HybridUnitOfWorkImpl implements the hybrid UOW interface
type HybridUnitOfWorkImpl struct {
        // For backward compatibility
        repoRegistry map[reflect.Type]func() interface{}

        // Direct repository access
        accountRepo     AccountRepository
        transactionRepo TransactionRepository
        userRepo        UserRepository
}

// NewHybridUnitOfWork creates a new hybrid UOW instance
func NewHybridUnitOfWork(
        accountRepo AccountRepository,
        transactionRepo TransactionRepository,
        userRepo UserRepository,
) HybridUnitOfWork <span class="cov0" title="0">{
        return &amp;HybridUnitOfWorkImpl{
                accountRepo:     accountRepo,
                transactionRepo: transactionRepo,
                userRepo:        userRepo,
                repoRegistry: map[reflect.Type]func() interface{}{
                        reflect.TypeOf((*AccountRepository)(nil)).Elem():     func() interface{} </span><span class="cov0" title="0">{ return accountRepo }</span>,
                        reflect.TypeOf((*TransactionRepository)(nil)).Elem(): func() interface{} <span class="cov0" title="0">{ return transactionRepo }</span>,
                        reflect.TypeOf((*UserRepository)(nil)).Elem():        func() interface{} <span class="cov0" title="0">{ return userRepo }</span>,
                },
        }
}

// Do executes a function within a transaction
func (uow *HybridUnitOfWorkImpl) Do(ctx context.Context, fn func(HybridUnitOfWork) error) error <span class="cov0" title="0">{
        // Transaction logic here
        return fn(uow)
}</span>

// GetRepository provides backward compatibility with reflect-based access
func (uow *HybridUnitOfWorkImpl) GetRepository(repoType reflect.Type) (any, error) <span class="cov0" title="0">{
        constructor, ok := uow.repoRegistry[repoType]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported repository type: %v", repoType)
        }</span>
        <span class="cov0" title="0">return constructor(), nil</span>
}

// Type-safe repository access methods (preferred)
func (uow *HybridUnitOfWorkImpl) AccountRepository() AccountRepository <span class="cov0" title="0">{
        return uow.accountRepo
}</span>

func (uow *HybridUnitOfWorkImpl) TransactionRepository() TransactionRepository <span class="cov0" title="0">{
        return uow.transactionRepo
}</span>

func (uow *HybridUnitOfWorkImpl) UserRepository() UserRepository <span class="cov0" title="0">{
        return uow.userRepo
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package repository

import (
        "context"
)

// ImprovedUnitOfWork provides type-safe repository access without reflect
type ImprovedUnitOfWork interface {
        // Transaction management
        Do(ctx context.Context, fn func(ImprovedUnitOfWork) error) error

        // Type-safe repository access methods
        AccountRepository() AccountRepository
        TransactionRepository() TransactionRepository
        UserRepository() UserRepository
}

// ImprovedUnitOfWorkImpl implements the improved UOW interface
type ImprovedUnitOfWorkImpl struct {
        accountRepo     AccountRepository
        transactionRepo TransactionRepository
        userRepo        UserRepository
}

// NewImprovedUnitOfWork creates a new improved UOW instance
func NewImprovedUnitOfWork(
        accountRepo AccountRepository,
        transactionRepo TransactionRepository,
        userRepo UserRepository,
) ImprovedUnitOfWork <span class="cov0" title="0">{
        return &amp;ImprovedUnitOfWorkImpl{
                accountRepo:     accountRepo,
                transactionRepo: transactionRepo,
                userRepo:        userRepo,
        }
}</span>

// Do executes a function within a transaction
func (uow *ImprovedUnitOfWorkImpl) Do(ctx context.Context, fn func(ImprovedUnitOfWork) error) error <span class="cov0" title="0">{
        // Transaction logic here - this would be implemented by the concrete UOW
        return fn(uow)
}</span>

// AccountRepository returns the account repository
func (uow *ImprovedUnitOfWorkImpl) AccountRepository() AccountRepository <span class="cov0" title="0">{
        return uow.accountRepo
}</span>

// TransactionRepository returns the transaction repository
func (uow *ImprovedUnitOfWorkImpl) TransactionRepository() TransactionRepository <span class="cov0" title="0">{
        return uow.transactionRepo
}</span>

// UserRepository returns the user repository
func (uow *ImprovedUnitOfWorkImpl) UserRepository() UserRepository <span class="cov0" title="0">{
        return uow.userRepo
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package service provides business logic for interacting with domain entities such as accounts and transactions.
// It defines the AccountService struct and its methods for creating accounts, depositing and withdrawing funds,
// retrieving account details, listing transactions, and checking account balances.
//
// The service layer follows clean architecture principles and uses the decorator pattern for transaction management.
// All business operations are wrapped with automatic transaction management, error recovery, and structured logging.
package account

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/common"
        mon "github.com/amirasaad/fintech/pkg/domain/money"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// AccountService provides business logic for account operations including creation, deposits, withdrawals, and balance inquiries.
type AccountService struct {
        uow       repository.UnitOfWork
        converter mon.CurrencyConverter
        logger    *slog.Logger
        chain     OperationHandler
}

// NewAccountService creates a new AccountService with a UnitOfWork, CurrencyConverter, and logger.
func NewAccountService(
        uow repository.UnitOfWork,
        converter mon.CurrencyConverter,
        logger *slog.Logger,
) *AccountService <span class="cov8" title="1">{
        logger.Info("NewAccountService: creating service", "converter_nil", converter == nil)
        builder := NewChainBuilder(uow, converter, logger)
        chain := builder.BuildOperationChain()
        logger.Info("NewAccountService: chain built", "chain_nil", chain == nil)
        return &amp;AccountService{
                uow:       uow,
                converter: converter,
                logger:    logger,
                chain:     chain,
        }
}</span>

// CreateAccount creates a new account for the specified user in a transaction.
func (s *AccountService) CreateAccount(ctx context.Context, userID uuid.UUID) (a *account.Account, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">a, err = account.New().WithUserID(userID).Build()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return repo.Create(a)</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                a = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// CreateAccountWithCurrency creates a new account for the specified user with a specific currency.
// This method allows creating accounts in different currencies, which is useful for multi-currency
// applications where users may need accounts in various currencies.
//
// The operation is wrapped with automatic transaction management and includes comprehensive
// error handling and logging.
//
// Parameters:
//   - userID: The UUID of the user who will own the account
//   - currencyCode: The ISO 4217 currency code for the account (e.g., "USD", "EUR", "JPY")
//
// Returns:
//   - A pointer to the created account with the specified currency
//   - An error if the operation fails (e.g., invalid currency, user not found, database error)
//
// The method validates the currency code and ensures it's supported by the system.
// If the currency is not supported, an appropriate domain error is returned.
//
// Example:
//
//        account, err := service.CreateAccountWithCurrency(userID, currency.Code("EUR"))
//        if err != nil {
//            log.Error("Failed to create EUR account", "error", err)
//            return
//        }
//        log.Info("EUR account created", "accountID", account.ID, "currency", account.Currency)
func (s *AccountService) CreateAccountWithCurrency(
        userID uuid.UUID,
        currencyCode currency.Code,
) (acct *account.Account, err error) <span class="cov0" title="0">{
        logger := s.logger.With("userID", userID, "currency", currencyCode)
        logger.Info("CreateAccountWithCurrency started")
        err = s.uow.Do(context.Background(), func(uow repository.UnitOfWork) error </span><span class="cov0" title="0">{
                repo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("CreateAccountWithCurrency failed: AccountRepository error", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">acct, err = account.New().
                        WithUserID(userID).
                        WithCurrency(currencyCode).
                        Build()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("CreateAccountWithCurrency failed: domain error", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">if err = repo.Create(acct); err != nil </span><span class="cov0" title="0">{
                        logger.Error("CreateAccountWithCurrency failed: repo create error", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                acct = nil
                logger.Error("CreateAccountWithCurrency failed: transaction error", "error", err)
                return
        }</span>
        <span class="cov0" title="0">logger.Info("CreateAccountWithCurrency successful", "accountID", acct.ID)
        return</span>
}

// Deposit adds funds to the specified account and creates a transaction record.
// The method supports multi-currency deposits with automatic currency conversion
// when the deposit currency differs from the account currency.
//
// The operation is wrapped with automatic transaction management and includes
// comprehensive validation, error handling, and logging.
//
// Key Features:
// - Multi-currency support with real-time conversion
// - Automatic transaction record creation
// - Comprehensive validation (positive amounts, valid currencies)
// - User authorization checks
// - Detailed logging for observability
//
// Parameters:
//   - userID: The UUID of the user making the deposit (must own the account)
//   - accountID: The UUID of the account to deposit into
//   - amount: The amount to deposit (must be positive)
//   - currencyCode: The ISO 4217 currency code of the deposit amount
//
// Returns:
//   - A pointer to the created transaction record
//   - A pointer to conversion information (if currency conversion occurred)
//   - An error if the operation fails
//
// Currency Conversion:
// If the deposit currency differs from the account currency, the system will:
// 1. Fetch real-time exchange rates from the configured provider
// 2. Convert the amount to the account's currency
// 3. Store conversion details for audit purposes
// 4. Update the account balance with the converted amount
//
// Error Scenarios:
// - Account not found: Returns domain.ErrAccountNotFound
// - User not authorized: Returns domain.ErrUserUnauthorized
// - Invalid amount: Returns domain.ErrTransactionAmountMustBePositive
// - Invalid currency: Returns domain.ErrInvalidCurrencyCode
// - Insufficient funds: Returns domain.ErrInsufficientFunds
// - Conversion failure: Returns conversion service error
//
// Example:
//
//        tx, convInfo, err := service.Deposit(userID, accountID, 100.0, currency.Code("EUR"))
//        if err != nil {
//            log.Error("Deposit failed", "error", err)
//            return
//        }
//        if convInfo != nil {
//            log.Info("Currency conversion applied",
//                "originalAmount", convInfo.OriginalAmount,
//                "convertedAmount", convInfo.ConvertedAmount,
//                "rate", convInfo.ConversionRate)
//        }
func (s *AccountService) Deposit(
        userID, accountID uuid.UUID,
        amount float64,
        currencyCode currency.Code,
) (tx *account.Transaction, convInfo *common.ConversionInfo, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.logger.Error("PANIC in AccountService.Deposit", "recover", r)
                        err = fmt.Errorf("panic: %v", r)
                }</span>
        }()

        <span class="cov8" title="1">s.logger.Info("Deposit: starting", "userID", userID, "accountID", accountID, "amount", amount, "currency", currencyCode, "chain_nil", s.chain == nil)

        req := &amp;OperationRequest{
                UserID:       userID,
                AccountID:    accountID,
                Amount:       amount,
                CurrencyCode: currencyCode,
                Operation:    OperationDeposit,
        }

        resp, err := s.chain.Handle(context.Background(), req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">if resp.Error != nil </span><span class="cov8" title="1">{
                return nil, nil, resp.Error
        }</span>

        <span class="cov8" title="1">return resp.Transaction, resp.ConvInfo, nil</span>
}

// Withdraw removes funds from the specified account and creates a transaction record.
// The method supports multi-currency withdrawals with automatic currency conversion
// when the withdrawal currency differs from the account currency.
//
// The operation is wrapped with automatic transaction management and includes
// comprehensive validation, error handling, and logging.
//
// Key Features:
// - Multi-currency support with real-time conversion
// - Automatic transaction record creation
// - Comprehensive validation (positive amounts, valid currencies)
// - User authorization checks
// - Insufficient funds validation
// - Detailed logging for observability
//
// Parameters:
//   - userID: The UUID of the user making the withdrawal (must own the account)
//   - accountID: The UUID of the account to withdraw from
//   - amount: The amount to withdraw (must be positive)
//   - currencyCode: The ISO 4217 currency code of the withdrawal amount
//
// Returns:
//   - A pointer to the created transaction record
//   - A pointer to conversion information (if currency conversion occurred)
//   - An error if the operation fails
//
// Currency Conversion:
// If the withdrawal currency differs from the account currency, the system will:
// 1. Fetch real-time exchange rates from the configured provider
// 2. Convert the amount to the account's currency
// 3. Store conversion details for audit purposes
// 4. Update the account balance with the converted amount
//
// Error Scenarios:
// - Account not found: Returns domain.ErrAccountNotFound
// - User not authorized: Returns domain.ErrUserUnauthorized
// - Invalid amount: Returns domain.ErrTransactionAmountMustBePositive
// - Invalid currency: Returns domain.ErrInvalidCurrencyCode
// - Insufficient funds: Returns domain.ErrInsufficientFunds
// - Conversion failure: Returns conversion service error
//
// Example:
//
//        tx, convInfo, err := service.Withdraw(userID, accountID, 50.0, currency.Code("USD"))
//        if err != nil {
//            log.Error("Withdraw failed", "error", err)
//            return
//        }
//        if convInfo != nil {
//            log.Info("Currency conversion applied",
//                "originalAmount", convInfo.OriginalAmount,
//                "convertedAmount", convInfo.ConvertedAmount,
//                "rate", convInfo.ConversionRate)
//        }
func (s *AccountService) Withdraw(
        userID, accountID uuid.UUID,
        amount float64,
        currencyCode currency.Code,
) (
        tx *account.Transaction,
        convInfo *common.ConversionInfo,
        err error,
) <span class="cov8" title="1">{
        req := &amp;OperationRequest{
                UserID:       userID,
                AccountID:    accountID,
                Amount:       amount,
                CurrencyCode: currencyCode,
                Operation:    OperationWithdraw,
        }

        resp, err := s.chain.Handle(context.Background(), req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">if resp.Error != nil </span><span class="cov8" title="1">{
                return nil, nil, resp.Error
        }</span>

        <span class="cov8" title="1">return resp.Transaction, resp.ConvInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package account

import (
        "context"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/common"
        mon "github.com/amirasaad/fintech/pkg/domain/money"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// CompleteGenericAccountService uses the complete generic UOW pattern
type CompleteGenericAccountService struct {
        uow       repository.CompleteGenericUnitOfWork
        converter mon.CurrencyConverter
        logger    *slog.Logger
}

// NewCompleteGenericAccountService creates a new service with complete generic UOW
func NewCompleteGenericAccountService(
        uow repository.CompleteGenericUnitOfWork,
        converter mon.CurrencyConverter,
        logger *slog.Logger,
) *CompleteGenericAccountService <span class="cov0" title="0">{
        return &amp;CompleteGenericAccountService{
                uow:       uow,
                converter: converter,
                logger:    logger,
        }
}</span>

// Deposit adds funds to the specified account using complete generic UOW
func (s *CompleteGenericAccountService) Deposit(
        userID, accountID uuid.UUID,
        amount float64,
        currencyCode currency.Code,
) (tx *account.Transaction, convInfo *common.ConversionInfo, err error) <span class="cov0" title="0">{
        logger := s.logger.With("userID", userID, "accountID", accountID, "amount", amount, "currency", currencyCode)
        logger.Info("Deposit started")

        err = s.uow.Do(context.Background(), func(uow repository.CompleteGenericUnitOfWork) error </span><span class="cov0" title="0">{
                // Type-safe repository access using generics - no reflect needed!
                accountRepo := uow.AccountRepository()
                transactionRepo := uow.TransactionRepository()

                // Get account using generic repository
                acc, err := accountRepo.Get(context.Background(), accountID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: account not found", "error", err)
                        return account.ErrAccountNotFound
                }</span>

                // Create money
                <span class="cov0" title="0">money, err := mon.NewMoney(amount, currencyCode)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: invalid money", "error", err)
                        return err
                }</span>

                // Handle currency conversion
                <span class="cov0" title="0">convertedMoney, convInfo, err := s.handleCurrencyConversion(money, acc.Currency, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Execute deposit
                <span class="cov0" title="0">tx, err = acc.Deposit(userID, convertedMoney)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: domain deposit error", "error", err)
                        return err
                }</span>

                // Store conversion info
                <span class="cov0" title="0">if convInfo != nil </span><span class="cov0" title="0">{
                        tx.OriginalAmount = &amp;convInfo.OriginalAmount
                        tx.OriginalCurrency = &amp;convInfo.OriginalCurrency
                        tx.ConversionRate = &amp;convInfo.ConversionRate
                }</span>

                // Update account and create transaction using generic repositories
                <span class="cov0" title="0">if err = accountRepo.Update(context.Background(), acc); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: repo update error", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">if err = transactionRepo.Create(context.Background(), tx); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: transaction create error", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">logger.Info("Deposit successful", "transactionID", tx.ID)
        return tx, convInfo, nil</span>
}

// GetAccountTransactions retrieves transactions for an account using generic repository
func (s *CompleteGenericAccountService) GetAccountTransactions(accountID uuid.UUID) ([]*account.Transaction, error) <span class="cov0" title="0">{
        var transactions []*account.Transaction

        err := s.uow.Do(context.Background(), func(uow repository.CompleteGenericUnitOfWork) error </span><span class="cov0" title="0">{
                transactionRepo := uow.TransactionRepository()

                // Use generic repository's FindBy method
                txs, err := transactionRepo.FindBy(context.Background(), "account_id = ?", accountID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">transactions = txs
                return nil</span>
        })

        <span class="cov0" title="0">return transactions, err</span>
}

// GetAccountsByUser retrieves all accounts for a user using generic repository
func (s *CompleteGenericAccountService) GetAccountsByUser(userID uuid.UUID) ([]*account.Account, error) <span class="cov0" title="0">{
        var accounts []*account.Account

        err := s.uow.Do(context.Background(), func(uow repository.CompleteGenericUnitOfWork) error </span><span class="cov0" title="0">{
                accountRepo := uow.AccountRepository()

                // Use generic repository's FindBy method
                accs, err := accountRepo.FindBy(context.Background(), "user_id = ?", userID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">accounts = accs
                return nil</span>
        })

        <span class="cov0" title="0">return accounts, err</span>
}

// handleCurrencyConversion handles currency conversion if needed
func (s *CompleteGenericAccountService) handleCurrencyConversion(
        money mon.Money,
        accountCurrency currency.Code,
        logger *slog.Logger,
) (mon.Money, *common.ConversionInfo, error) <span class="cov0" title="0">{
        if money.Currency() == accountCurrency </span><span class="cov0" title="0">{
                return money, nil, nil
        }</span>

        <span class="cov0" title="0">convInfo, err := s.converter.Convert(money.AmountFloat(), string(money.Currency()), string(accountCurrency))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Currency conversion failed", "error", err)
                return mon.Money{}, nil, err
        }</span>

        <span class="cov0" title="0">convertedMoney, err := mon.NewMoney(convInfo.ConvertedAmount, accountCurrency)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Converted money creation failed", "error", err)
                return mon.Money{}, nil, err
        }</span>

        <span class="cov0" title="0">return convertedMoney, convInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package account

import (
        "log/slog"

        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/common"
        mon "github.com/amirasaad/fintech/pkg/domain/money"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// DirectAccountService uses direct repository injection instead of UOW with reflect
type DirectAccountService struct {
        accountRepo     repository.AccountRepository
        transactionRepo repository.TransactionRepository
        converter       mon.CurrencyConverter
        logger          *slog.Logger
}

// NewDirectAccountService creates a new service with direct repository injection
func NewDirectAccountService(
        accountRepo repository.AccountRepository,
        transactionRepo repository.TransactionRepository,
        converter mon.CurrencyConverter,
        logger *slog.Logger,
) *DirectAccountService <span class="cov0" title="0">{
        return &amp;DirectAccountService{
                accountRepo:     accountRepo,
                transactionRepo: transactionRepo,
                converter:       converter,
                logger:          logger,
        }
}</span>

// Deposit adds funds to the specified account without using reflect
func (s *DirectAccountService) Deposit(
        userID, accountID uuid.UUID,
        amount float64,
        currencyCode currency.Code,
) (tx *account.Transaction, convInfo *common.ConversionInfo, err error) <span class="cov0" title="0">{
        logger := s.logger.With("userID", userID, "accountID", accountID, "amount", amount, "currency", currencyCode)
        logger.Info("Deposit started")

        // Get account directly - no reflect needed
        acc, err := s.accountRepo.Get(accountID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Deposit failed: account not found", "error", err)
                return nil, nil, account.ErrAccountNotFound
        }</span>

        // Create money
        <span class="cov0" title="0">money, err := mon.NewMoney(amount, currencyCode)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Deposit failed: invalid money", "error", err)
                return nil, nil, err
        }</span>

        // Handle currency conversion
        <span class="cov0" title="0">convertedMoney, convInfo, err := s.handleCurrencyConversion(money, acc.Currency, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Execute deposit
        <span class="cov0" title="0">tx, err = acc.Deposit(userID, convertedMoney)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Deposit failed: domain deposit error", "error", err)
                return nil, nil, err
        }</span>

        // Store conversion info
        <span class="cov0" title="0">if convInfo != nil </span><span class="cov0" title="0">{
                tx.OriginalAmount = &amp;convInfo.OriginalAmount
                tx.OriginalCurrency = &amp;convInfo.OriginalCurrency
                tx.ConversionRate = &amp;convInfo.ConversionRate
        }</span>

        // Update account and create transaction
        <span class="cov0" title="0">if err = s.accountRepo.Update(acc); err != nil </span><span class="cov0" title="0">{
                logger.Error("Deposit failed: repo update error", "error", err)
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">if err = s.transactionRepo.Create(tx); err != nil </span><span class="cov0" title="0">{
                logger.Error("Deposit failed: transaction create error", "error", err)
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">logger.Info("Deposit successful", "transactionID", tx.ID)
        return tx, convInfo, nil</span>
}

// Withdraw removes funds from the specified account without using reflect
func (s *DirectAccountService) Withdraw(
        userID, accountID uuid.UUID,
        amount float64,
        currencyCode currency.Code,
) (tx *account.Transaction, convInfo *common.ConversionInfo, err error) <span class="cov0" title="0">{
        logger := s.logger.With("userID", userID, "accountID", accountID, "amount", amount, "currency", currencyCode)
        logger.Info("Withdraw started")

        // Get account directly - no reflect needed
        acc, err := s.accountRepo.Get(accountID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Withdraw failed: account not found", "error", err)
                return nil, nil, account.ErrAccountNotFound
        }</span>

        // Create money
        <span class="cov0" title="0">money, err := mon.NewMoney(amount, currencyCode)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Withdraw failed: invalid money", "error", err)
                return nil, nil, err
        }</span>

        // Handle currency conversion
        <span class="cov0" title="0">convertedMoney, convInfo, err := s.handleCurrencyConversion(money, acc.Currency, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Execute withdraw
        <span class="cov0" title="0">tx, err = acc.Withdraw(userID, convertedMoney)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Withdraw failed: domain withdraw error", "error", err)
                return nil, nil, err
        }</span>

        // Store conversion info
        <span class="cov0" title="0">if convInfo != nil </span><span class="cov0" title="0">{
                tx.OriginalAmount = &amp;convInfo.OriginalAmount
                tx.OriginalCurrency = &amp;convInfo.OriginalCurrency
                tx.ConversionRate = &amp;convInfo.ConversionRate
        }</span>

        // Update account and create transaction
        <span class="cov0" title="0">if err = s.accountRepo.Update(acc); err != nil </span><span class="cov0" title="0">{
                logger.Error("Withdraw failed: repo update error", "error", err)
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">if err = s.transactionRepo.Create(tx); err != nil </span><span class="cov0" title="0">{
                logger.Error("Withdraw failed: transaction create error", "error", err)
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">logger.Info("Withdraw successful", "transactionID", tx.ID)
        return tx, convInfo, nil</span>
}

// handleCurrencyConversion handles currency conversion if needed
func (s *DirectAccountService) handleCurrencyConversion(
        money mon.Money,
        accountCurrency currency.Code,
        logger *slog.Logger,
) (mon.Money, *common.ConversionInfo, error) <span class="cov0" title="0">{
        if money.Currency() == accountCurrency </span><span class="cov0" title="0">{
                return money, nil, nil
        }</span>

        <span class="cov0" title="0">convInfo, err := s.converter.Convert(money.AmountFloat(), string(money.Currency()), string(accountCurrency))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Currency conversion failed", "error", err)
                return mon.Money{}, nil, err
        }</span>

        <span class="cov0" title="0">convertedMoney, err := mon.NewMoney(convInfo.ConvertedAmount, accountCurrency)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Converted money creation failed", "error", err)
                return mon.Money{}, nil, err
        }</span>

        <span class="cov0" title="0">return convertedMoney, convInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package account

import (
        "context"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/common"
        mon "github.com/amirasaad/fintech/pkg/domain/money"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// GenericAccountService uses generic repositories for type-safe data access
type GenericAccountService struct {
        accountRepo     repository.GenericRepository[account.Account]
        transactionRepo repository.GenericRepository[account.Transaction]
        converter       mon.CurrencyConverter
        logger          *slog.Logger
}

// NewGenericAccountService creates a new service with generic repositories
func NewGenericAccountService(
        accountRepo repository.GenericRepository[account.Account],
        transactionRepo repository.GenericRepository[account.Transaction],
        converter mon.CurrencyConverter,
        logger *slog.Logger,
) *GenericAccountService <span class="cov0" title="0">{
        return &amp;GenericAccountService{
                accountRepo:     accountRepo,
                transactionRepo: transactionRepo,
                converter:       converter,
                logger:          logger,
        }
}</span>

// Deposit adds funds to the specified account using generic repositories
func (s *GenericAccountService) Deposit(
        userID, accountID uuid.UUID,
        amount float64,
        currencyCode currency.Code,
) (tx *account.Transaction, convInfo *common.ConversionInfo, err error) <span class="cov0" title="0">{
        logger := s.logger.With("userID", userID, "accountID", accountID, "amount", amount, "currency", currencyCode)
        logger.Info("Deposit started")

        // Get account using generic repository - type-safe!
        acc, err := s.accountRepo.Get(context.Background(), accountID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Deposit failed: account not found", "error", err)
                return nil, nil, account.ErrAccountNotFound
        }</span>

        // Create money
        <span class="cov0" title="0">money, err := mon.NewMoney(amount, currencyCode)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Deposit failed: invalid money", "error", err)
                return nil, nil, err
        }</span>

        // Handle currency conversion
        <span class="cov0" title="0">convertedMoney, convInfo, err := s.handleCurrencyConversion(money, acc.Currency, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Execute deposit
        <span class="cov0" title="0">tx, err = acc.Deposit(userID, convertedMoney)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Deposit failed: domain deposit error", "error", err)
                return nil, nil, err
        }</span>

        // Store conversion info
        <span class="cov0" title="0">if convInfo != nil </span><span class="cov0" title="0">{
                tx.OriginalAmount = &amp;convInfo.OriginalAmount
                tx.OriginalCurrency = &amp;convInfo.OriginalCurrency
                tx.ConversionRate = &amp;convInfo.ConversionRate
        }</span>

        // Update account and create transaction using generic repositories
        <span class="cov0" title="0">if err = s.accountRepo.Update(context.Background(), acc); err != nil </span><span class="cov0" title="0">{
                logger.Error("Deposit failed: repo update error", "error", err)
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">if err = s.transactionRepo.Create(context.Background(), tx); err != nil </span><span class="cov0" title="0">{
                logger.Error("Deposit failed: transaction create error", "error", err)
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">logger.Info("Deposit successful", "transactionID", tx.ID)
        return tx, convInfo, nil</span>
}

// GetAccountTransactions retrieves transactions for an account using generic repository
func (s *GenericAccountService) GetAccountTransactions(accountID uuid.UUID) ([]*account.Transaction, error) <span class="cov0" title="0">{
        // Use generic repository's FindBy method
        transactions, err := s.transactionRepo.FindBy(context.Background(), "account_id = ?", accountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return transactions, nil</span>
}

// GetAccountsByUser retrieves all accounts for a user using generic repository
func (s *GenericAccountService) GetAccountsByUser(userID uuid.UUID) ([]*account.Account, error) <span class="cov0" title="0">{
        // Use generic repository's FindBy method
        accounts, err := s.accountRepo.FindBy(context.Background(), "user_id = ?", userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return accounts, nil</span>
}

// handleCurrencyConversion handles currency conversion if needed
func (s *GenericAccountService) handleCurrencyConversion(
        money mon.Money,
        accountCurrency currency.Code,
        logger *slog.Logger,
) (mon.Money, *common.ConversionInfo, error) <span class="cov0" title="0">{
        if money.Currency() == accountCurrency </span><span class="cov0" title="0">{
                return money, nil, nil
        }</span>

        <span class="cov0" title="0">convInfo, err := s.converter.Convert(money.AmountFloat(), string(money.Currency()), string(accountCurrency))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Currency conversion failed", "error", err)
                return mon.Money{}, nil, err
        }</span>

        <span class="cov0" title="0">convertedMoney, err := mon.NewMoney(convInfo.ConvertedAmount, accountCurrency)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Converted money creation failed", "error", err)
                return mon.Money{}, nil, err
        }</span>

        <span class="cov0" title="0">return convertedMoney, convInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package account

import (
        "context"
        "log/slog"

        infraRepo "github.com/amirasaad/fintech/infra/repository"
        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/common"
        mon "github.com/amirasaad/fintech/pkg/domain/money"
        repo "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// StringBasedAccountService demonstrates the string-based UOW approach
type StringBasedAccountService struct {
        uow       infraRepo.StringBasedUnitOfWork
        converter mon.CurrencyConverter
        logger    *slog.Logger
}

// NewStringBasedAccountService creates a new service with string-based UOW
func NewStringBasedAccountService(
        uow infraRepo.StringBasedUnitOfWork,
        converter mon.CurrencyConverter,
        logger *slog.Logger,
) *StringBasedAccountService <span class="cov0" title="0">{
        return &amp;StringBasedAccountService{
                uow:       uow,
                converter: converter,
                logger:    logger,
        }
}</span>

// Deposit demonstrates string-based repository access
func (s *StringBasedAccountService) Deposit(
        userID, accountID uuid.UUID,
        amount float64,
        currencyCode currency.Code,
) (tx *account.Transaction, convInfo *common.ConversionInfo, err error) <span class="cov0" title="0">{
        logger := s.logger.With("userID", userID, "accountID", accountID, "amount", amount, "currency", currencyCode)
        logger.Info("Deposit started")

        var txLocal *account.Transaction
        var convInfoLocal *common.ConversionInfo

        err = s.uow.Do(context.Background(), func(uow infraRepo.StringBasedUnitOfWork) error </span><span class="cov0" title="0">{
                // Option 1: Use string-based access (your suggested approach)
                accountRepoAny, err := uow.GetRepository("account")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: AccountRepository error", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">accountRepo := accountRepoAny.(repo.AccountRepository)

                // Option 2: Use type-safe convenience methods (recommended)
                // accountRepo, err := uow.AccountRepository()
                // if err != nil {
                //     logger.Error("Deposit failed: AccountRepository error", "error", err)
                //     return err
                // }

                // Get account
                acc, err := accountRepo.Get(accountID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: account not found", "error", err)
                        return account.ErrAccountNotFound
                }</span>

                // Create money
                <span class="cov0" title="0">money, err := mon.NewMoney(amount, currencyCode)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: invalid money", "error", err)
                        return err
                }</span>

                // Handle currency conversion
                <span class="cov0" title="0">convertedMoney, convInfo, err := s.handleCurrencyConversion(money, acc.Currency, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">convInfoLocal = convInfo

                // Execute deposit
                txLocal, err = acc.Deposit(userID, convertedMoney)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: domain deposit error", "error", err)
                        return err
                }</span>

                // Store conversion info
                <span class="cov0" title="0">if convInfoLocal != nil </span><span class="cov0" title="0">{
                        txLocal.OriginalAmount = &amp;convInfoLocal.OriginalAmount
                        txLocal.OriginalCurrency = &amp;convInfoLocal.OriginalCurrency
                        txLocal.ConversionRate = &amp;convInfoLocal.ConversionRate
                }</span>

                // Update account
                <span class="cov0" title="0">if err = accountRepo.Update(acc); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: repo update error", "error", err)
                        return err
                }</span>

                // Get transaction repository using string
                <span class="cov0" title="0">txRepoAny, err := uow.GetRepository("transaction")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: TransactionRepository error", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">txRepo := txRepoAny.(repo.TransactionRepository)

                // Create transaction
                if err = txRepo.Create(txLocal); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: transaction create error", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">logger.Info("Deposit successful", "transactionID", txLocal.ID)
        return txLocal, convInfoLocal, nil</span>
}

// handleCurrencyConversion handles currency conversion if needed
func (s *StringBasedAccountService) handleCurrencyConversion(
        money mon.Money,
        accountCurrency currency.Code,
        logger *slog.Logger,
) (mon.Money, *common.ConversionInfo, error) <span class="cov0" title="0">{
        if money.Currency() == accountCurrency </span><span class="cov0" title="0">{
                return money, nil, nil
        }</span>

        <span class="cov0" title="0">convInfo, err := s.converter.Convert(money.AmountFloat(), string(money.Currency()), string(accountCurrency))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Currency conversion failed", "error", err)
                return mon.Money{}, nil, err
        }</span>

        <span class="cov0" title="0">convertedMoney, err := mon.NewMoney(convInfo.ConvertedAmount, accountCurrency)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Converted money creation failed", "error", err)
                return mon.Money{}, nil, err
        }</span>

        <span class="cov0" title="0">logger.Info("Currency conversion applied",
                "original", money,
                "converted", convertedMoney,
                "rate", convInfo.ConversionRate)

        return convertedMoney, convInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package account

import (
        "context"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/common"
        mon "github.com/amirasaad/fintech/pkg/domain/money"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// TypeSafeAccountService uses the improved UOW with type-safe repository access
type TypeSafeAccountService struct {
        uow       repository.ImprovedUnitOfWork
        converter mon.CurrencyConverter
        logger    *slog.Logger
}

// NewTypeSafeAccountService creates a new service with type-safe UOW
func NewTypeSafeAccountService(
        uow repository.ImprovedUnitOfWork,
        converter mon.CurrencyConverter,
        logger *slog.Logger,
) *TypeSafeAccountService <span class="cov0" title="0">{
        return &amp;TypeSafeAccountService{
                uow:       uow,
                converter: converter,
                logger:    logger,
        }
}</span>

// Deposit adds funds to the specified account using type-safe UOW
func (s *TypeSafeAccountService) Deposit(
        userID, accountID uuid.UUID,
        amount float64,
        currencyCode currency.Code,
) (tx *account.Transaction, convInfo *common.ConversionInfo, err error) <span class="cov0" title="0">{
        logger := s.logger.With("userID", userID, "accountID", accountID, "amount", amount, "currency", currencyCode)
        logger.Info("Deposit started")

        err = s.uow.Do(context.Background(), func(uow repository.ImprovedUnitOfWork) error </span><span class="cov0" title="0">{
                // Type-safe repository access - no reflect needed!
                accountRepo := uow.AccountRepository()
                transactionRepo := uow.TransactionRepository()

                // Get account
                acc, err := accountRepo.Get(accountID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: account not found", "error", err)
                        return account.ErrAccountNotFound
                }</span>

                // Create money
                <span class="cov0" title="0">money, err := mon.NewMoney(amount, currencyCode)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: invalid money", "error", err)
                        return err
                }</span>

                // Handle currency conversion
                <span class="cov0" title="0">convertedMoney, convInfo, err := s.handleCurrencyConversion(money, acc.Currency, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Execute deposit
                <span class="cov0" title="0">tx, err = acc.Deposit(userID, convertedMoney)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: domain deposit error", "error", err)
                        return err
                }</span>

                // Store conversion info
                <span class="cov0" title="0">if convInfo != nil </span><span class="cov0" title="0">{
                        tx.OriginalAmount = &amp;convInfo.OriginalAmount
                        tx.OriginalCurrency = &amp;convInfo.OriginalCurrency
                        tx.ConversionRate = &amp;convInfo.ConversionRate
                }</span>

                // Update account and create transaction
                <span class="cov0" title="0">if err = accountRepo.Update(acc); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: repo update error", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">if err = transactionRepo.Create(tx); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Deposit failed: transaction create error", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">logger.Info("Deposit successful", "transactionID", tx.ID)
        return tx, convInfo, nil</span>
}

// handleCurrencyConversion handles currency conversion if needed
func (s *TypeSafeAccountService) handleCurrencyConversion(
        money mon.Money,
        accountCurrency currency.Code,
        logger *slog.Logger,
) (mon.Money, *common.ConversionInfo, error) <span class="cov0" title="0">{
        if money.Currency() == accountCurrency </span><span class="cov0" title="0">{
                return money, nil, nil
        }</span>

        <span class="cov0" title="0">convInfo, err := s.converter.Convert(money.AmountFloat(), string(money.Currency()), string(accountCurrency))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Currency conversion failed", "error", err)
                return mon.Money{}, nil, err
        }</span>

        <span class="cov0" title="0">convertedMoney, err := mon.NewMoney(convInfo.ConvertedAmount, accountCurrency)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Converted money creation failed", "error", err)
                return mon.Money{}, nil, err
        }</span>

        <span class="cov0" title="0">return convertedMoney, convInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package account

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/common"
        mon "github.com/amirasaad/fintech/pkg/domain/money"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// OperationHandler defines the interface for handling account operations in the chain
type OperationHandler interface {
        Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error)
        SetNext(handler OperationHandler)
}

// OperationRequest contains all the data needed for account operations
type OperationRequest struct {
        UserID         uuid.UUID
        AccountID      uuid.UUID
        Amount         float64
        CurrencyCode   currency.Code
        Operation      OperationType
        Account        *account.Account
        Money          mon.Money
        ConvertedMoney mon.Money
        ConvInfo       *common.ConversionInfo
        Transaction    *account.Transaction
}

// OperationResponse contains the result of an account operation
type OperationResponse struct {
        Transaction *account.Transaction
        ConvInfo    *common.ConversionInfo
        Error       error
}

// BaseHandler provides common functionality for all handlers
type BaseHandler struct {
        next OperationHandler
}

// SetNext sets the next handler in the chain
func (h *BaseHandler) SetNext(handler OperationHandler) <span class="cov8" title="1">{
        h.next = handler
}</span>

// Handle passes the request to the next handler in the chain
func (h *BaseHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        if h.next != nil </span><span class="cov8" title="1">{
                return h.next.Handle(ctx, req)
        }</span>
        <span class="cov8" title="1">return &amp;OperationResponse{}, nil</span>
}

// AccountValidationHandler validates that the account exists and belongs to the user
type AccountValidationHandler struct {
        BaseHandler
        uow    repository.UnitOfWork
        logger *slog.Logger
}

// Handle validates the account and passes the request to the next handler
func (h *AccountValidationHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger.With("userID", req.UserID, "accountID", req.AccountID)
        logger.Info("AccountValidationHandler: starting")

        repo, err := h.uow.AccountRepository()
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("AccountValidationHandler failed: repository error", "error", err)
                return &amp;OperationResponse{Error: err}, nil
        }</span>
        <span class="cov8" title="1">logger.Info("AccountValidationHandler: got repository", "repo_nil", repo == nil)

        logger.Info("AccountValidationHandler: about to call repo.Get", "accountID", req.AccountID)
        acc, err := repo.Get(req.AccountID)
        logger.Info("AccountValidationHandler: repo.Get completed", "acc_nil", acc == nil, "err", err)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("AccountValidationHandler failed: account not found", "error", err)
                return &amp;OperationResponse{Error: account.ErrAccountNotFound}, nil
        }</span>
        <span class="cov8" title="1">logger.Info("AccountValidationHandler: got account", "account", acc)

        if acc.UserID != req.UserID </span><span class="cov0" title="0">{
                logger.Error("AccountValidationHandler failed: user unauthorized", "accountUserID", acc.UserID)
                return &amp;OperationResponse{Error: user.ErrUserUnauthorized}, nil
        }</span>

        <span class="cov8" title="1">req.Account = acc
        logger.Info("AccountValidationHandler: account validated successfully")

        return h.BaseHandler.Handle(ctx, req)</span>
}

// MoneyCreationHandler creates a Money object from the request amount and currency
type MoneyCreationHandler struct {
        BaseHandler
        logger *slog.Logger
}

// Handle creates a Money object and passes the request to the next handler
func (h *MoneyCreationHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger.With("amount", req.Amount, "currency", req.CurrencyCode)

        money, err := mon.NewMoney(req.Amount, req.CurrencyCode)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("MoneyCreationHandler failed: invalid money", "error", err)
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">req.Money = money
        logger.Info("MoneyCreationHandler: money created successfully")

        return h.BaseHandler.Handle(ctx, req)</span>
}

// CurrencyConversionHandler handles currency conversion if needed
type CurrencyConversionHandler struct {
        BaseHandler
        converter mon.CurrencyConverter
        logger    *slog.Logger
}

// Handle converts currency if needed and passes the request to the next handler
func (h *CurrencyConversionHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger.With("fromCurrency", req.Money.Currency(), "toCurrency", req.Account.Currency)

        if req.Money.Currency() == req.Account.Currency </span><span class="cov8" title="1">{
                req.ConvertedMoney = req.Money
                logger.Info("CurrencyConversionHandler: no conversion needed")
                return h.BaseHandler.Handle(ctx, req)
        }</span>

        <span class="cov8" title="1">convInfo, err := h.converter.Convert(req.Money.AmountFloat(), string(req.Money.Currency()), string(req.Account.Currency))
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("CurrencyConversionHandler failed: conversion error", "error", err)
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">convertedMoney, err := mon.NewMoney(convInfo.ConvertedAmount, req.Account.Currency)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("CurrencyConversionHandler failed: converted money creation error", "error", err)
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">req.ConvertedMoney = convertedMoney
        req.ConvInfo = convInfo
        logger.Info("CurrencyConversionHandler: conversion completed", "rate", convInfo.ConversionRate)

        return h.BaseHandler.Handle(ctx, req)</span>
}

// DomainOperationHandler executes the domain operation (deposit/withdraw)
type DomainOperationHandler struct {
        BaseHandler
        logger *slog.Logger
}

// Handle executes the domain operation and passes the request to the next handler
func (h *DomainOperationHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger.With("operation", req.Operation)

        var tx *account.Transaction
        var err error

        switch req.Operation </span>{
        case OperationDeposit:<span class="cov8" title="1">
                tx, err = req.Account.Deposit(req.UserID, req.ConvertedMoney)</span>
        case OperationWithdraw:<span class="cov8" title="1">
                tx, err = req.Account.Withdraw(req.UserID, req.ConvertedMoney)</span>
        default:<span class="cov8" title="1">
                err = fmt.Errorf("unsupported operation: %s", req.Operation)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                logger.Error("DomainOperationHandler failed: domain operation error", "error", err)
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">req.Transaction = tx
        logger.Info("DomainOperationHandler: domain operation completed", "transactionID", tx.ID)

        return h.BaseHandler.Handle(ctx, req)</span>
}

// PersistenceHandler handles the persistence of account and transaction changes
type PersistenceHandler struct {
        BaseHandler
        uow    repository.UnitOfWork
        logger *slog.Logger
}

// Handle persists the changes and returns the final response
func (h *PersistenceHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger.With("transactionID", req.Transaction.ID)

        // Store conversion info if conversion occurred
        if req.ConvInfo != nil </span><span class="cov8" title="1">{
                req.Transaction.OriginalAmount = &amp;req.ConvInfo.OriginalAmount
                req.Transaction.OriginalCurrency = &amp;req.ConvInfo.OriginalCurrency
                req.Transaction.ConversionRate = &amp;req.ConvInfo.ConversionRate
                logger.Info("PersistenceHandler: conversion info stored")
        }</span>
        <span class="cov8" title="1">if err := h.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{

                // Update account using type-safe method
                repo, err := uow.AccountRepository()

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("PersistenceHandler failed: AccountRepository error", "error", err)
                        return err
                }</span>

                <span class="cov8" title="1">if err = repo.Update(req.Account); err != nil </span><span class="cov8" title="1">{
                        logger.Error("PersistenceHandler failed: account update error", "error", err)
                        return err
                }</span>

                // Create transaction using type-safe method
                <span class="cov8" title="1">txRepo, err := uow.TransactionRepository()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("PersistenceHandler failed: TransactionRepository error", "error", err)
                        return err
                }</span>

                <span class="cov8" title="1">if err = txRepo.Create(req.Transaction); err != nil </span><span class="cov8" title="1">{
                        logger.Error("PersistenceHandler failed: transaction create error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">return err</span>
        }); err != nil <span class="cov8" title="1">{
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">logger.Info("PersistenceHandler: persistence completed successfully")

        return &amp;OperationResponse{
                Transaction: req.Transaction,
                ConvInfo:    req.ConvInfo,
        }, nil</span>

}

// ChainBuilder builds the operation chain
type ChainBuilder struct {
        uow       repository.UnitOfWork
        converter mon.CurrencyConverter
        logger    *slog.Logger
}

// NewChainBuilder creates a new chain builder
func NewChainBuilder(uow repository.UnitOfWork, converter mon.CurrencyConverter, logger *slog.Logger) *ChainBuilder <span class="cov8" title="1">{
        return &amp;ChainBuilder{
                uow:       uow,
                converter: converter,
                logger:    logger,
        }
}</span>

// BuildOperationChain builds and returns the complete operation chain
func (b *ChainBuilder) BuildOperationChain() OperationHandler <span class="cov8" title="1">{
        // Create handlers
        accountValidation := &amp;AccountValidationHandler{
                uow:    b.uow,
                logger: b.logger,
        }

        moneyCreation := &amp;MoneyCreationHandler{
                logger: b.logger,
        }

        currencyConversion := &amp;CurrencyConversionHandler{
                converter: b.converter,
                logger:    b.logger,
        }

        domainOperation := &amp;DomainOperationHandler{
                logger: b.logger,
        }

        persistence := &amp;PersistenceHandler{
                uow:    b.uow,
                logger: b.logger,
        }

        // Chain them together
        accountValidation.SetNext(moneyCreation)
        moneyCreation.SetNext(currencyConversion)
        currencyConversion.SetNext(domainOperation)
        domainOperation.SetNext(persistence)

        return accountValidation
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package account

import (
        "context"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// GetAccount retrieves an account by its ID.
// Returns the account or an error if not found.
func (s *AccountService) GetAccount(
        userID, accountID uuid.UUID,
) (a *account.Account, err error) <span class="cov8" title="1">{
        s.logger.Info("GetAccount started", "userID", userID, "accountID", accountID)
        defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Error("GetAccount failed", "userID", userID, "accountID", accountID, "error", err)
                }</span> else<span class="cov8" title="1"> {
                        s.logger.Info("GetAccount successful", "userID", userID, "accountID", accountID)
                }</span>
        }()
        <span class="cov8" title="1">logger := s.logger.With("userID", userID, "accountID", accountID)
        logger.Info("GetAccount started")
        err = s.uow.Do(context.Background(), func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("GetAccount failed: AccountRepository error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">aLocal, err := repo.Get(accountID)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("GetAccount failed: db error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">if aLocal.UserID != userID </span><span class="cov0" title="0">{
                        logger.Error("GetAccount failed: user unauthorized", "accountUserID", aLocal.UserID)
                        return user.ErrUserUnauthorized
                }</span>
                <span class="cov8" title="1">a = aLocal
                return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                a = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetTransactions retrieves all transactions for a given account ID.
// Returns a slice of transactions or an error if the operation fails.
func (s *AccountService) GetTransactions(
        userID, accountID uuid.UUID,
) (txs []*account.Transaction, err error) <span class="cov8" title="1">{
        s.logger.Info("GetTransactions started", "userID", userID, "accountID", accountID)
        defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Error("GetTransactions failed", "userID", userID, "accountID", accountID, "error", err)
                }</span> else<span class="cov8" title="1"> {
                        s.logger.Info("GetTransactions successful", "userID", userID, "accountID", accountID, "count", len(txs))
                }</span>
        }()
        <span class="cov8" title="1">logger := s.logger.With("userID", userID, "accountID", accountID)
        logger.Info("GetTransactions started")
        err = s.uow.Do(context.Background(), func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                // First, verify the account exists and belongs to the user
                repo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("GetTransactions failed: AccountRepository error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">a, err := repo.Get(accountID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("GetTransactions failed: account not found", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">if a == nil </span><span class="cov0" title="0">{
                        logger.Error("GetTransactions failed: account not found")
                        return account.ErrAccountNotFound
                }</span>
                <span class="cov8" title="1">if a.UserID != userID </span><span class="cov0" title="0">{
                        logger.Error("GetTransactions failed: user unauthorized", "accountUserID", a.UserID)
                        return user.ErrUserUnauthorized
                }</span>

                // Now get the transactions
                <span class="cov8" title="1">txRepo, err := uow.TransactionRepository()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("GetTransactions failed: TransactionRepository error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">txs, err = txRepo.List(userID, accountID)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("GetTransactions failed: repo list error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                txs = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetBalance retrieves the current balance of the specified account.
// Returns the balance as a float64 or an error if the operation fails.
func (s *AccountService) GetBalance(
        userID, accountID uuid.UUID,
) (balance float64, err error) <span class="cov8" title="1">{
        s.logger.Info("GetBalance started", "userID", userID, "accountID", accountID)
        defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Error("GetBalance failed", "userID", userID, "accountID", accountID, "error", err)
                }</span> else<span class="cov8" title="1"> {
                        s.logger.Info("GetBalance successful", "userID", userID, "accountID", accountID, "balance", balance)
                }</span>
        }()
        <span class="cov8" title="1">logger := s.logger.With("userID", userID, "accountID", accountID)
        logger.Info("GetBalance started")
        err = s.uow.Do(context.Background(), func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("GetBalance failed: AccountRepository error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">a, err := repo.Get(accountID)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("GetBalance failed: AccountRepository.Get error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">if a == nil </span><span class="cov0" title="0">{
                        err = account.ErrAccountNotFound
                        logger.Error("GetBalance failed:  ErrAccountNotFound")
                        return err
                }</span>
                <span class="cov8" title="1">balance, err = a.GetBalance(userID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("GetBalance failed: domain error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                balance = 0
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package auth

import (
        "context"
        "errors"
        "log/slog"
        "time"

        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/amirasaad/fintech/pkg/utils"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

type contextKey string

const userContextKey contextKey = "user"

type AuthStrategy interface {
        Login(ctx context.Context, identity, password string) (*domain.User, error)
        GetCurrentUserID(ctx context.Context) (uuid.UUID, error)
        GenerateToken(user *domain.User) (string, error)
}

type AuthService struct {
        uow      repository.UnitOfWork
        strategy AuthStrategy
        logger   *slog.Logger
}

func NewAuthService(
        uow repository.UnitOfWork,
        strategy AuthStrategy,
        logger *slog.Logger,
) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{uow: uow, strategy: strategy, logger: logger}
}</span>

func NewBasicAuthService(uow repository.UnitOfWork, logger *slog.Logger) *AuthService <span class="cov8" title="1">{
        return NewAuthService(uow, &amp;BasicAuthStrategy{uow: uow, logger: logger}, logger)
}</span>

func (s *AuthService) CheckPasswordHash(
        password, hash string,
) bool <span class="cov8" title="1">{
        s.logger.Info("CheckPasswordHash called")
        valid := utils.CheckPasswordHash(password, hash)
        if !valid </span><span class="cov8" title="1">{
                s.logger.Error("Password hash check failed", "valid", valid)
        }</span>
        <span class="cov8" title="1">return valid</span>
}

func (s *AuthService) ValidEmail(email string) bool <span class="cov8" title="1">{
        s.logger.Info("ValidEmail called", "email", email)
        return utils.IsEmail(email)
}</span>

func (s *AuthService) GetCurrentUserId(
        token *jwt.Token,
) (userID uuid.UUID, err error) <span class="cov8" title="1">{
        s.logger.Info("GetCurrentUserId called")
        userID, err = s.strategy.GetCurrentUserID(context.WithValue(context.TODO(), userContextKey, token))
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("GetCurrentUserId failed", "error", err)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (s *AuthService) Login(
        ctx context.Context,
        identity, password string,
) (u *domain.User, err error) <span class="cov8" title="1">{
        s.logger.Info("Login called", "identity", identity)
        u, err = s.strategy.Login(ctx, identity, password)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Login failed", "identity", identity, "error", err)
                return
        }</span>
        <span class="cov8" title="1">if u == nil </span><span class="cov8" title="1">{
                err = domain.ErrUserUnauthorized
                s.logger.Error("Login failed", "identity", identity, "error", "user is nil")
                return
        }</span>
        <span class="cov8" title="1">s.logger.Info("Login successful", "userID", u.ID)
        return</span>
}

func (s *AuthService) GenerateToken(user *domain.User) (string, error) <span class="cov0" title="0">{
        s.logger.Info("GenerateToken called", "userID", user.ID)
        token, err := s.strategy.GenerateToken(user)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("GenerateToken failed", "userID", user.ID, "error", err)
                return "", err
        }</span>
        <span class="cov0" title="0">s.logger.Info("GenerateToken successful", "userID", user.ID)
        return token, nil</span>
}

// JWTAuthStrategy implements AuthStrategy for JWT-based authentication
type JWTAuthStrategy struct {
        uow    repository.UnitOfWork
        cfg    config.JwtConfig
        logger *slog.Logger
}

func NewJWTAuthStrategy(
        uow repository.UnitOfWork,
        cfg config.JwtConfig,
        logger *slog.Logger,
) *JWTAuthStrategy <span class="cov8" title="1">{
        return &amp;JWTAuthStrategy{uow: uow, cfg: cfg, logger: logger}
}</span>
func (s *JWTAuthStrategy) GenerateToken(user *domain.User) (string, error) <span class="cov0" title="0">{
        s.logger.Info("GenerateToken called", "userID", user.ID)
        token := jwt.New(jwt.SigningMethodHS256)
        claims := token.Claims.(jwt.MapClaims)
        claims["username"] = user.Username
        claims["email"] = user.Email
        claims["user_id"] = user.ID.String()
        claims["exp"] = time.Now().Add(s.cfg.Expiry).Unix()
        tokenString, err := token.SignedString([]byte(s.cfg.Secret))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("GenerateToken failed", "userID", user.ID, "error", err)
                return "", err
        }</span>
        <span class="cov0" title="0">s.logger.Info("GenerateToken successful", "userID", user.ID)
        return tokenString, nil</span>
}

func (s *JWTAuthStrategy) Login(
        ctx context.Context,
        identity, password string,
) (
        u *domain.User,
        err error,
) <span class="cov0" title="0">{
        s.logger.Info("Login called", "identity", identity)
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov0" title="0">{
                repoAny, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">repo := repoAny.(repository.UserRepository)
                if utils.IsEmail(identity) </span><span class="cov0" title="0">{
                        u, err = repo.GetByEmail(identity)
                }</span> else<span class="cov0" title="0"> {
                        u, err = repo.GetByUsername(identity)
                }</span>
                <span class="cov0" title="0">const dummyHash = "$2a$10$7zFqzDbD3RrlkMTczbXG9OWZ0FLOXjIxXzSZ.QZxkVXjXcx7QZQiC"
                if err != nil </span><span class="cov0" title="0">{
                        return domain.ErrUserUnauthorized
                }</span>
                <span class="cov0" title="0">if u == nil </span><span class="cov0" title="0">{
                        utils.CheckPasswordHash(password, dummyHash)
                        return domain.ErrUserUnauthorized
                }</span>
                <span class="cov0" title="0">if !utils.CheckPasswordHash(password, u.Password) </span><span class="cov0" title="0">{
                        return domain.ErrUserUnauthorized
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return</span>
}

func (s *JWTAuthStrategy) GetCurrentUserID(
        ctx context.Context,
) (userID uuid.UUID, err error) <span class="cov8" title="1">{
        token, ok := ctx.Value(userContextKey).(*jwt.Token)
        if !ok || token == nil </span><span class="cov0" title="0">{
                s.logger.Error("GetCurrentUserID failed", "error", domain.ErrUserUnauthorized)
                err = domain.ErrUserUnauthorized
                return
        }</span>
        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov8" title="1">{
                s.logger.Error("GetCurrentUserID failed", "error", domain.ErrUserUnauthorized)
                err = domain.ErrUserUnauthorized
                return
        }</span>
        <span class="cov8" title="1">userIDRaw, ok := claims["user_id"].(string)
        if !ok </span><span class="cov8" title="1">{
                s.logger.Error("GetCurrentUserID failed", "error", domain.ErrUserUnauthorized)
                err = domain.ErrUserUnauthorized
                return
        }</span>
        <span class="cov0" title="0">userID, err = uuid.Parse(userIDRaw)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("GetCurrentUserID failed", "error", err)
        }</span>
        <span class="cov0" title="0">return</span>
}

// BasicAuthStrategy implements AuthStrategy for CLI (no JWT, just password check)
type BasicAuthStrategy struct {
        uow    repository.UnitOfWork
        logger *slog.Logger
}

func (s *BasicAuthStrategy) Login(
        ctx context.Context,
        identity, password string,
) (
        user *domain.User,
        err error,
) <span class="cov8" title="1">{
        s.logger.Info("Login called", "identity", identity)
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo := repoAny.(repository.UserRepository)
                if utils.IsEmail(identity) </span><span class="cov0" title="0">{
                        user, err = repo.GetByEmail(identity)
                }</span> else<span class="cov8" title="1"> {
                        user, err = repo.GetByUsername(identity)
                }</span>
                <span class="cov8" title="1">const dummyHash = "$2a$10$7zFqzDbD3RrlkMTczbXG9OWZ0FLOXjIxXzSZ.QZxkVXjXcx7QZQiC"
                if err != nil </span><span class="cov0" title="0">{
                        return domain.ErrUserUnauthorized
                }</span>
                <span class="cov8" title="1">if user == nil </span><span class="cov0" title="0">{
                        utils.CheckPasswordHash(password, dummyHash)
                        return errors.New("invalid credentials")
                }</span>
                <span class="cov8" title="1">if !utils.CheckPasswordHash(password, user.Password) </span><span class="cov0" title="0">{
                        return errors.New("invalid credentials")
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return</span>
}

func (s *BasicAuthStrategy) GetCurrentUserID(ctx context.Context) (uuid.UUID, error) <span class="cov0" title="0">{
        s.logger.Info("GetCurrentUserID called")
        return uuid.Nil, nil
}</span>

func (s *BasicAuthStrategy) GenerateToken(user *domain.User) (string, error) <span class="cov0" title="0">{
        s.logger.Info("GenerateToken called", "userID", user.ID)
        return "", nil // No token for basic auth
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package currency

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/currency"
)

// CurrencyService provides business logic for currency operations
type CurrencyService struct {
        registry *currency.CurrencyRegistry
        logger   *slog.Logger
}

// NewCurrencyService creates a new currency service
func NewCurrencyService(registry *currency.CurrencyRegistry, logger *slog.Logger) *CurrencyService <span class="cov8" title="1">{
        return &amp;CurrencyService{
                registry: registry,
                logger:   logger,
        }
}</span>

// GetCurrency retrieves currency information by code
func (s *CurrencyService) GetCurrency(ctx context.Context, code string) (currency.CurrencyMeta, error) <span class="cov8" title="1">{
        return s.registry.Get(code)
}</span>

// ListSupportedCurrencies returns all supported currency codes
func (s *CurrencyService) ListSupportedCurrencies(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        return s.registry.ListSupported()
}</span>

// ListAllCurrencies returns all registered currencies with full metadata
func (s *CurrencyService) ListAllCurrencies(ctx context.Context) ([]currency.CurrencyMeta, error) <span class="cov8" title="1">{
        return s.registry.ListAll()
}</span>

// RegisterCurrency registers a new currency
func (s *CurrencyService) RegisterCurrency(ctx context.Context, meta currency.CurrencyMeta) error <span class="cov8" title="1">{
        return s.registry.Register(meta)
}</span>

// UnregisterCurrency removes a currency from the registry
func (s *CurrencyService) UnregisterCurrency(ctx context.Context, code string) error <span class="cov8" title="1">{
        return s.registry.Unregister(code)
}</span>

// ActivateCurrency activates a currency
func (s *CurrencyService) ActivateCurrency(ctx context.Context, code string) error <span class="cov8" title="1">{
        return s.registry.Activate(code)
}</span>

// DeactivateCurrency deactivates a currency
func (s *CurrencyService) DeactivateCurrency(ctx context.Context, code string) error <span class="cov8" title="1">{
        return s.registry.Deactivate(code)
}</span>

// IsCurrencySupported checks if a currency is supported
func (s *CurrencyService) IsCurrencySupported(ctx context.Context, code string) bool <span class="cov8" title="1">{
        return s.registry.IsSupported(code)
}</span>

// SearchCurrencies searches for currencies by name
func (s *CurrencyService) SearchCurrencies(ctx context.Context, query string) ([]currency.CurrencyMeta, error) <span class="cov8" title="1">{
        return s.registry.Search(query)
}</span>

// SearchCurrenciesByRegion searches for currencies by region
func (s *CurrencyService) SearchCurrenciesByRegion(ctx context.Context, region string) ([]currency.CurrencyMeta, error) <span class="cov8" title="1">{
        return s.registry.SearchByRegion(region)
}</span>

// GetCurrencyStatistics returns currency statistics
func (s *CurrencyService) GetCurrencyStatistics(ctx context.Context) (map[string]interface{}, error) <span class="cov8" title="1">{
        total, err := s.registry.Count()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total count: %w", err)
        }</span>

        <span class="cov8" title="1">active, err := s.registry.CountActive()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active count: %w", err)
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "total_currencies":    total,
                "active_currencies":   active,
                "inactive_currencies": total - active,
        }, nil</span>
}

// ValidateCurrencyCode validates a currency code format
func (s *CurrencyService) ValidateCurrencyCode(ctx context.Context, code string) error <span class="cov8" title="1">{
        if !currency.IsValidCurrencyFormat(code) </span><span class="cov8" title="1">{
                return currency.ErrInvalidCurrencyCode
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetDefaultCurrency returns the default currency information
func (s *CurrencyService) GetDefaultCurrency(ctx context.Context) (currency.CurrencyMeta, error) <span class="cov8" title="1">{
        return s.registry.Get(currency.DefaultCurrency)
}</span>

// GetRegistry returns the underlying currency registry
func (s *CurrencyService) GetRegistry() *currency.CurrencyRegistry <span class="cov8" title="1">{
        return s.registry
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package currency

import (
        "github.com/amirasaad/fintech/pkg/domain"
)

// CurrencyConverter defines the interface for converting amounts between currencies.
type CurrencyConverter interface {
        // Convert converts an amount from one currency to another.
        // Returns the converted amount and the rate used, or an error if conversion is not possible.
        Convert(amount float64, from, to string) (*domain.ConversionInfo, error)
}

// StubCurrencyConverter is a simple implementation that returns the same amount (1:1 conversion).
type StubCurrencyConverter struct {
        rates map[string]map[string]float64
}

// NewStubCurrencyConverter creates a new StubCurrencyConverter with an empty rates map.
func NewStubCurrencyConverter() *StubCurrencyConverter <span class="cov0" title="0">{
        return &amp;StubCurrencyConverter{rates: map[string]map[string]float64{
                "USD": {
                        "EUR": 0.84,
                        "GBP": 0.76,
                        "JPY": 0.0027,
                },
                "EUR": {
                        "USD": 1.19,
                        "GBP": 0.90,
                        "JPY": 0.0024,
                },
                "GBP": {
                        "USD": 1.32,
                        "EUR": 1.11,
                        "JPY": 0.0024,
                },
                "JPY": {
                        "USD": 0.0027,
                        "EUR": 0.0024,
                        "GBP": 0.0024,
                },
        }}
}</span>

func (s *StubCurrencyConverter) Convert(amount float64, from, to string) (*domain.ConversionInfo, error) <span class="cov0" title="0">{
        rate := s.rates[from][to]
        return &amp;domain.ConversionInfo{
                OriginalAmount:    amount,
                OriginalCurrency:  from,
                ConvertedAmount:   amount * rate,
                ConvertedCurrency: to,
                ConversionRate:    rate,
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">// Package service provides business logic for user management operations.
// It uses the decorator pattern for transaction management and includes comprehensive logging.
package user

import (
        "context"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// UserService provides business logic for user operations including creation, updates, and deletion.
type UserService struct {
        uow    repository.UnitOfWork
        logger *slog.Logger
}

// NewUserService creates a new UserService with a UnitOfWork and logger.
func NewUserService(
        uow repository.UnitOfWork,
        logger *slog.Logger,
) *UserService <span class="cov8" title="1">{
        return &amp;UserService{
                uow:    uow,
                logger: logger,
        }
}</span>

// CreateUser creates a new user account in a transaction.
func (s *UserService) CreateUser(
        ctx context.Context,
        username, email, password string,
) (u *user.User, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo := repoAny.(repository.UserRepository)
                u, err = user.NewUser(username, email, password)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return repo.Create(u)</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                u = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetUser retrieves a user by ID in a transaction.
func (s *UserService) GetUser(ctx context.Context, userID string) (u *user.User, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo := repoAny.(repository.UserRepository)
                uid, parseErr := uuid.Parse(userID)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return parseErr
                }</span>
                <span class="cov8" title="1">u, err = repo.Get(uid)
                return err</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                u = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetUserByEmail retrieves a user by email in a transaction.
func (s *UserService) GetUserByEmail(ctx context.Context, email string) (u *user.User, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo := repoAny.(repository.UserRepository)
                u, err = repo.GetByEmail(email)
                return err</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                u = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetUserByUsername retrieves a user by username in a transaction.
func (s *UserService) GetUserByUsername(ctx context.Context, username string) (u *user.User, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo := repoAny.(repository.UserRepository)
                u, err = repo.GetByUsername(username)
                return err</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                u = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// UpdateUser updates user information in a transaction.
func (s *UserService) UpdateUser(ctx context.Context, userID string, updateFn func(u *user.User) error) (err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo := repoAny.(repository.UserRepository)
                uid, parseErr := uuid.Parse(userID)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return parseErr
                }</span>
                <span class="cov8" title="1">u, err := repo.Get(uid)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if u == nil </span><span class="cov0" title="0">{
                        return user.ErrUserNotFound
                }</span>
                <span class="cov8" title="1">if err = updateFn(u); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return repo.Update(u)</span>
        })
        <span class="cov8" title="1">return</span>
}

// DeleteUser deletes a user account in a transaction.
func (s *UserService) DeleteUser(ctx context.Context, userID string) (err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo := repoAny.(repository.UserRepository)
                uid, parseErr := uuid.Parse(userID)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return parseErr
                }</span>
                <span class="cov8" title="1">return repo.Delete(uid)</span>
        })
        <span class="cov8" title="1">return</span>
}

// ValidUser validates user credentials in a transaction.
func (s *UserService) ValidUser(ctx context.Context, userID string, password string) (valid bool, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo := repoAny.(repository.UserRepository)
                uid, parseErr := uuid.Parse(userID)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return parseErr
                }</span>
                <span class="cov8" title="1">valid = repo.Valid(uid, password)
                return nil</span>
        })
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package utils

import (
        "net/mail"

        "golang.org/x/crypto/bcrypt"
)

// HashPassword hashes a plain password using bcrypt with cost 14.
func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        return hashPassword(password)
}</span>

func hashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

// CheckPasswordHash compares a plain password with a bcrypt hash.
func CheckPasswordHash(password, hash string) bool <span class="cov0" title="0">{
        return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) == nil
}</span>

// IsEmail returns true if the string is a valid email address.
func IsEmail(email string) bool <span class="cov0" title="0">{
        _, err := mail.ParseAddress(email)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">// AccountRoutes registers HTTP routes for account-related operations using the Fiber web framework.
// It sets up endpoints for creating accounts, depositing and withdrawing funds, retrieving account balances,
// and listing account transactions. All routes are protected by authentication middleware and require a valid user context.
//
//        @param app The Fiber application instance to register routes on.
//        @param accountSvc A pointer to the AccountService.
//        @param authSvc A pointer to the AuthService.
//
// Routes:
//   - POST   /account                   : Create a new account for the authenticated user.
//   - POST   /account/:id/deposit       : Deposit funds into the specified account.
//   - POST   /account/:id/withdraw      : Withdraw funds from the specified account.
//   - GET    /account/:id/balance       : Retrieve the balance of the specified account.
//   - GET    /account/:id/transactions  : List transactions for the specified account.

package account

import (
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/middleware"
        accountsvc "github.com/amirasaad/fintech/pkg/service/account"
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

func AccountRoutes(app *fiber.App, accountSvc *accountsvc.AccountService, authSvc *authsvc.AuthService, cfg *config.AppConfig) <span class="cov8" title="1">{
        app.Post("/account", middleware.JwtProtected(cfg.Jwt), CreateAccount(accountSvc, authSvc))
        app.Post("/account/:id/deposit", middleware.JwtProtected(cfg.Jwt), Deposit(accountSvc, authSvc))
        app.Post("/account/:id/withdraw", middleware.JwtProtected(cfg.Jwt), Withdraw(accountSvc, authSvc))
        app.Get("/account/:id/balance", middleware.JwtProtected(cfg.Jwt), GetBalance(accountSvc, authSvc))
        app.Get("/account/:id/transactions", middleware.JwtProtected(cfg.Jwt), GetTransactions(accountSvc, authSvc))
}</span>

// CreateAccount returns a Fiber handler for creating a new account for the current user.
// It extracts the user ID from the request context, initializes the account service using the provided
// UnitOfWork factory, and attempts to create a new account. On success, it returns the created account as JSON.
// On failure, it logs the error and returns an appropriate error response.
// @Summary Create a new account
// @Description Create a new account for the authenticated user
// @Tags accounts
// @Accept json
// @Produce json
// @Success 201 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /account [post]
// @Security Bearer
func CreateAccount(
        accountSvc *accountsvc.AccountService,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                log.Infof("Creating new account")
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov8" title="1">input, err := common.BindAndValidate[CreateAccountRequest](c)
                if input == nil </span><span class="cov0" title="0">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">currencyCode := currency.USD
                if input.Currency != "" </span><span class="cov8" title="1">{
                        currencyCode = currency.Code(input.Currency)
                }</span>
                <span class="cov8" title="1">a, err := accountSvc.CreateAccountWithCurrency(userID, currencyCode)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to create account: %v", err)
                        return common.ProblemDetailsJSON(c, "Failed to create account", err)
                }</span>
                <span class="cov8" title="1">log.Infof("Account created: %+v", a)
                return common.SuccessResponseJSON(c, fiber.StatusCreated, "Account created", a)</span>
        }
}

// Deposit returns a Fiber handler for depositing an amount into a user's account.
// It expects a UnitOfWork factory function as a dependency for transactional operations.
// The handler parses the current user ID from the request context, validates the account ID from the URL,
// and parses the deposit amount from the request body. If successful, it performs the deposit operation
// using the AccountService and returns the transaction as JSON. On error, it logs the issue and returns
// an appropriate JSON error response.
// @Summary Deposit funds into an account
// @Description Deposit a specified amount into the user's account
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Param request body DepositRequest true "Deposit request with amount"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /account/{id}/deposit [post]
// @Security Bearer
func Deposit(
        accountSvc *accountsvc.AccountService,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                log.Infof("Deposit handler: called for account %s", c.Params("id"))
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov8" title="1">accountID, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for deposit: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid account ID", err, "Account ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">input, err := common.BindAndValidate[DepositRequest](c)
                if input == nil </span><span class="cov0" title="0">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">currencyCode := currency.USD
                if input.Currency != "" </span><span class="cov8" title="1">{
                        currencyCode = currency.Code(input.Currency)
                }</span>
                <span class="cov8" title="1">log.Infof("Deposit handler: calling service for user %s, account %s, amount %v, currency %s", userID, accountID, input.Amount, currencyCode)
                tx, convInfo, err := accountSvc.Deposit(userID, accountID, input.Amount, currencyCode)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to deposit: %v", err)
                        return common.ProblemDetailsJSON(c, "Failed to deposit", err)
                }</span>
                <span class="cov8" title="1">if convInfo != nil </span><span class="cov0" title="0">{
                        resp := ToConversionResponseDTO(tx, convInfo)
                        return common.SuccessResponseJSON(c, fiber.StatusOK, "Deposit successful (converted)", resp)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusOK, "Deposit successful", ToTransactionDTO(tx))</span>
        }
}

// Withdraw returns a Fiber handler for processing account withdrawal requests.
// It expects a UnitOfWork factory function as a dependency for transactional operations.
//
// The handler performs the following steps:
//  1. Retrieves the current user ID from the request context.
//  2. Parses the account ID from the route parameters.
//  3. Parses the withdrawal amount from the request body.
//  4. Calls the AccountService.Withdraw method to process the withdrawal.
//  5. Returns the transaction details as a JSON response on success.
//
// Error responses are returned in JSON format with appropriate status codes
// if any step fails (e.g., invalid user ID, invalid account ID, parsing errors, or withdrawal errors).
// @Summary Withdraw funds from an account
// @Description Withdraw a specified amount from the user's account
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Param request body WithdrawRequest true "Withdrawal request with amount"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /account/{id}/withdraw [post]
// @Security Bearer
func Withdraw(
        accountSvc *accountsvc.AccountService,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov8" title="1">accountID, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for withdrawal: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid account ID", err, "Account ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">input, err := common.BindAndValidate[WithdrawRequest](c)
                if input == nil </span><span class="cov0" title="0">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">currencyCode := currency.Code("USD")
                if input.Currency != "" </span><span class="cov8" title="1">{
                        currencyCode = currency.Code(input.Currency)
                }</span>
                <span class="cov8" title="1">tx, convInfo, err := accountSvc.Withdraw(userID, accountID, input.Amount, currencyCode)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to withdraw: %v", err)
                        return common.ProblemDetailsJSON(c, "Failed to withdraw", err)
                }</span>
                <span class="cov8" title="1">if convInfo != nil </span><span class="cov0" title="0">{
                        resp := ToConversionResponseDTO(tx, convInfo)
                        return common.SuccessResponseJSON(c, fiber.StatusOK, "Withdrawal successful (converted)", resp)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusOK, "Withdrawal successful", ToTransactionDTO(tx))</span>
        }
}

// GetTransactions returns a Fiber handler that retrieves the list of transactions for a specific account.
// It expects a UnitOfWork factory function as a dependency for service instantiation.
// The handler extracts the current user ID from the request context and parses the account ID from the URL parameters.
// On success, it returns the transactions as a JSON response. On error, it logs the error and returns an appropriate JSON error response.
// @Summary Get account transactions
// @Description Retrieve the list of transactions for a specific account
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /account/{id}/transactions [get]
// @Security Bearer
func GetTransactions(
        accountSvc *accountsvc.AccountService,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov0" title="0">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov0" title="0">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for transactions: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid account ID", err, "Account ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">tx, err := accountSvc.GetTransactions(userID, id)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to list transactions for account ID %s: %v", id, err)
                        return common.ProblemDetailsJSON(c, "Failed to list transactions", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Transactions fetched", tx)</span>
        }
}

// GetBalance returns a Fiber handler for retrieving the balance of a specific account.
// It expects a UnitOfWork factory function as a dependency for service instantiation.
// The handler extracts the current user ID from the request context and parses the account ID from the URL parameters.
// On success, it returns the account balance as a JSON response. On error, it logs the error and returns an appropriate JSON error response.
// @Summary Get account balance
// @Description Retrieve the balance of a specific account
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /account/{id}/balance [get]
// @Security Bearer
func GetBalance(
        accountSvc *accountsvc.AccountService,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for balance: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid account ID", err, "Account ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>

                <span class="cov8" title="1">balance, err := accountSvc.GetBalance(userID, id)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to fetch balance for account ID %s: %v", id, err)
                        return common.ProblemDetailsJSON(c, "Failed to fetch balance", err)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusOK, "Balance fetched", fiber.Map{"balance": balance})</span>
        }
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package account

import (
        "github.com/amirasaad/fintech/pkg/domain"
)

// CreateAccountRequest represents the request body for creating a new account.
type CreateAccountRequest struct {
        Currency string `json:"currency" validate:"omitempty,len=3,uppercase,alpha"`
}

// DepositRequest represents the request body for depositing funds into an account.
type DepositRequest struct {
        Amount   float64 `json:"amount" xml:"amount" form:"amount" validate:"required,gt=0"`
        Currency string  `json:"currency" validate:"omitempty,len=3,uppercase"`
}

// WithdrawRequest represents the request body for withdrawing funds from an account.
type WithdrawRequest struct {
        Amount   float64 `json:"amount" xml:"amount" form:"amount" validate:"required,gt=0"`
        Currency string  `json:"currency" validate:"omitempty,len=3,uppercase"`
}

// ConversionResponse wraps a transaction and conversion details if a currency conversion occurred.
type ConversionResponse struct {
        Transaction       *domain.Transaction `json:"transaction"`
        OriginalAmount    float64             `json:"original_amount,omitempty"`
        OriginalCurrency  string              `json:"original_currency,omitempty"`
        ConvertedAmount   float64             `json:"converted_amount,omitempty"`
        ConvertedCurrency string              `json:"converted_currency,omitempty"`
        ConversionRate    float64             `json:"conversion_rate,omitempty"`
}

// TransactionDTO is the API response representation of a transaction.
type TransactionDTO struct {
        ID        string  `json:"id"`
        UserID    string  `json:"user_id"`
        AccountID string  `json:"account_id"`
        Amount    float64 `json:"amount"`
        Balance   float64 `json:"balance"`
        CreatedAt string  `json:"created_at"`
        Currency  string  `json:"currency"`

        // Conversion fields (only present if conversion occurred)
        OriginalAmount   *float64 `json:"original_amount,omitempty"`
        OriginalCurrency *string  `json:"original_currency,omitempty"`
        ConversionRate   *float64 `json:"conversion_rate,omitempty"`
}

// ConversionResponseDTO wraps a transaction and conversion details for API responses.
type ConversionResponseDTO struct {
        Transaction       *TransactionDTO `json:"transaction"`
        OriginalAmount    float64         `json:"original_amount,omitempty"`
        OriginalCurrency  string          `json:"original_currency,omitempty"`
        ConvertedAmount   float64         `json:"converted_amount,omitempty"`
        ConvertedCurrency string          `json:"converted_currency,omitempty"`
        ConversionRate    float64         `json:"conversion_rate,omitempty"`
}

// ToTransactionDTO maps a domain.Transaction to a TransactionDTO.
func ToTransactionDTO(tx *domain.Transaction) *TransactionDTO <span class="cov8" title="1">{
        if tx == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">dto := &amp;TransactionDTO{
                ID:        tx.ID.String(),
                UserID:    tx.UserID.String(),
                AccountID: tx.AccountID.String(),
                Amount:    float64(tx.Amount) / 100.0, // assuming cents
                Balance:   float64(tx.Balance) / 100.0,
                CreatedAt: tx.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                Currency:  string(tx.Currency),
        }

        // Include conversion fields if they exist
        if tx.OriginalAmount != nil </span><span class="cov0" title="0">{
                dto.OriginalAmount = tx.OriginalAmount
        }</span>
        <span class="cov8" title="1">if tx.OriginalCurrency != nil </span><span class="cov0" title="0">{
                dto.OriginalCurrency = tx.OriginalCurrency
        }</span>
        <span class="cov8" title="1">if tx.ConversionRate != nil </span><span class="cov0" title="0">{
                dto.ConversionRate = tx.ConversionRate
        }</span>

        <span class="cov8" title="1">return dto</span>
}

// ToConversionResponseDTO maps a transaction and conversion info to a ConversionResponseDTO.
func ToConversionResponseDTO(tx *domain.Transaction, convInfo *domain.ConversionInfo) *ConversionResponseDTO <span class="cov0" title="0">{
        // If conversion info is provided (from service layer), use it
        if convInfo != nil </span><span class="cov0" title="0">{
                return &amp;ConversionResponseDTO{
                        Transaction:       ToTransactionDTO(tx),
                        OriginalAmount:    convInfo.OriginalAmount,
                        OriginalCurrency:  convInfo.OriginalCurrency,
                        ConvertedAmount:   convInfo.ConvertedAmount,
                        ConvertedCurrency: convInfo.ConvertedCurrency,
                        ConversionRate:    convInfo.ConversionRate,
                }
        }</span>

        // If no conversion info provided but transaction has stored conversion data, use that
        <span class="cov0" title="0">if tx.OriginalAmount != nil &amp;&amp; tx.OriginalCurrency != nil &amp;&amp; tx.ConversionRate != nil </span><span class="cov0" title="0">{
                return &amp;ConversionResponseDTO{
                        Transaction:       ToTransactionDTO(tx),
                        OriginalAmount:    *tx.OriginalAmount,
                        OriginalCurrency:  *tx.OriginalCurrency,
                        ConvertedAmount:   float64(tx.Amount) / 100.0, // Convert from cents
                        ConvertedCurrency: string(tx.Currency),
                        ConversionRate:    *tx.ConversionRate,
                }
        }</span>

        // No conversion occurred
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package webapi

import (
        "errors"
        "time"

        "github.com/amirasaad/fintech/pkg/config"
        accountsvc "github.com/amirasaad/fintech/pkg/service/account"
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        currencysvc "github.com/amirasaad/fintech/pkg/service/currency"
        usersvc "github.com/amirasaad/fintech/pkg/service/user"
        "github.com/amirasaad/fintech/webapi/account"
        "github.com/amirasaad/fintech/webapi/auth"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/amirasaad/fintech/webapi/currency"
        "github.com/amirasaad/fintech/webapi/user"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/limiter"
        "github.com/gofiber/fiber/v2/middleware/recover"
        "github.com/gofiber/swagger"

        // docs are generated by Swag CLI, you have to import them.
        _ "github.com/amirasaad/fintech/docs"
)

func NewApp(
        accountSvc *accountsvc.AccountService,
        userSvc *usersvc.UserService,
        authSvc *authsvc.AuthService,
        currencySvc *currencysvc.CurrencyService,
        cfg *config.AppConfig,
) *fiber.App <span class="cov8" title="1">{
        return newAppWithRateLimit(accountSvc, userSvc, authSvc, currencySvc, cfg, 5, 1*time.Second)
}</span>

func newAppWithRateLimit(
        accountSvc *accountsvc.AccountService,
        userSvc *usersvc.UserService,
        authSvc *authsvc.AuthService,
        currencySvc *currencysvc.CurrencyService,
        cfg *config.AppConfig,
        maxRequests int,
        expiration time.Duration,
) *fiber.App <span class="cov8" title="1">{
        app := fiber.New(fiber.Config{
                ErrorHandler: func(c *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Internal Server Error", err)
                }</span>,
        })
        <span class="cov8" title="1">app.Get("/swagger/*", swagger.New(swagger.Config{
                TryItOutEnabled:      true,
                WithCredentials:      true,
                PersistAuthorization: true,
        }))

        app.Use(limiter.New(limiter.Config{
                Max:        maxRequests,
                Expiration: expiration,
                KeyGenerator: func(c *fiber.Ctx) string </span><span class="cov8" title="1">{
                        return c.IP()
                }</span>,
                LimitReached: func(c *fiber.Ctx) error <span class="cov8" title="1">{
                        return common.ProblemDetailsJSON(c, "Too Many Requests", errors.New("rate limit exceeded"), fiber.StatusTooManyRequests)
                }</span>,
        }))
        <span class="cov8" title="1">app.Use(recover.New())

        app.Get("/", func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                return c.SendString("App is working! 🚀")
        }</span>)

        <span class="cov8" title="1">account.AccountRoutes(app, accountSvc, authSvc, cfg)
        user.UserRoutes(app, userSvc, authSvc, cfg)
        auth.AuthRoutes(app, authSvc)
        currency.CurrencyRoutes(app, currencySvc, authSvc, cfg)

        return app</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package auth

import (
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/gofiber/fiber/v2"
)

func AuthRoutes(app *fiber.App, authSvc *authsvc.AuthService) <span class="cov8" title="1">{
        app.Post("/auth/login", Login(authSvc))
}</span>

// Login handles user authentication and returns a JWT token.
// @Summary User login
// @Description Authenticate user with identity (username or email) and password
// @Tags auth
// @Accept json
// @Produce json
// @Param request body LoginInput true "Login credentials"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /auth/login [post]
func Login(authSvc *authsvc.AuthService) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                input, err := common.BindAndValidate[LoginInput](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // Error already written by BindAndValidate
                }</span>
                <span class="cov8" title="1">user, err := authSvc.Login(c.Context(), input.Identity, input.Password)
                if err != nil </span><span class="cov8" title="1">{
                        // Check if it's an unauthorized error
                        if err.Error() == "user unauthorized" </span><span class="cov8" title="1">{
                                return common.ProblemDetailsJSON(c, "Invalid identity or password", nil, "Identity or password is incorrect", fiber.StatusUnauthorized)
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(c, "Internal Server Error", err)</span>
                }
                <span class="cov8" title="1">if user == nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid identity or password", nil, "Identity or password is incorrect", fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">token, err := authSvc.GenerateToken(user)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Internal Server Error", err)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusOK, "Success login", fiber.Map{"token": token})</span>
        }
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package common

import (
        "errors"

        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/domain/common"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
)

// Response defines the standard API response structure for success cases.
type Response struct {
        Status  int    `json:"status"`         // HTTP status code
        Message string `json:"message"`        // Human-readable explanation
        Data    any    `json:"data,omitempty"` // Response data
}

// ProblemDetails follows RFC 9457 Problem Details for HTTP APIs.
type ProblemDetails struct {
        Type     string `json:"type,omitempty"`     // A URI reference that identifies the problem type
        Title    string `json:"title"`              // Short, human-readable summary
        Status   int    `json:"status"`             // HTTP status code
        Detail   string `json:"detail,omitempty"`   // Human-readable explanation
        Instance string `json:"instance,omitempty"` // URI reference that identifies the specific occurrence
        Errors   any    `json:"errors,omitempty"`   // Optional: additional error details
}

// ProblemDetailsJSON writes a problem+json error response with a status code inferred from the error (if present).
// The title is set to the error message (if error), and detail can be a string, error, or structured object.
// Optionally, a status code can be provided as the last argument (int) to override the fallback status.
func ProblemDetailsJSON(c *fiber.Ctx, title string, err error, detailOrStatus ...any) error <span class="cov0" title="0">{
        status := fiber.StatusBadRequest
        pdDetail := ""
        var pdErrors any
        var customStatus *int

        if err != nil </span><span class="cov0" title="0">{
                status = errorToStatusCode(err)
                title = err.Error()
                pdDetail = err.Error()
        }</span>
        // Check for custom detail or status code in variadic args
        <span class="cov0" title="0">for _, arg := range detailOrStatus </span><span class="cov0" title="0">{
                switch v := arg.(type) </span>{
                case int:<span class="cov0" title="0">
                        customStatus = &amp;v</span>
                case string:<span class="cov0" title="0">
                        pdDetail = v</span>
                case error:<span class="cov0" title="0">
                        pdDetail = v.Error()</span>
                default:<span class="cov0" title="0">
                        pdErrors = v</span>
                }
        }
        // Use custom status if provided
        <span class="cov0" title="0">if customStatus != nil </span><span class="cov0" title="0">{
                status = *customStatus
        }</span>
        <span class="cov0" title="0">pd := ProblemDetails{
                Status: status,
                Title:  title,
                Detail: pdDetail,
                Errors: pdErrors,
        }
        c.Set(fiber.HeaderContentType, "application/problem+json")
        if err := c.Status(status).JSON(pd); err != nil </span><span class="cov0" title="0">{
                log.Errorf("ProblemDetailsJSON failed: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// BindAndValidate parses the request body and validates it using go-playground/validator.
// Returns a pointer to the struct (populated), or writes an error response and returns nil.
func BindAndValidate[T any](c *fiber.Ctx) (*T, error) <span class="cov0" title="0">{
        var input T
        if err := c.BodyParser(&amp;input); err != nil </span><span class="cov0" title="0">{
                return nil, ProblemDetailsJSON(c, "Invalid request body", err, "Request body could not be parsed or has invalid types", fiber.StatusBadRequest) //nolint:errcheck
        }</span>

        <span class="cov0" title="0">validate := validator.New()
        if err := validate.Struct(input); err != nil </span><span class="cov0" title="0">{
                if ve, ok := err.(validator.ValidationErrors); ok </span><span class="cov0" title="0">{
                        details := make(map[string]string)
                        for _, fe := range ve </span><span class="cov0" title="0">{
                                field := fe.Field()
                                msg := fe.Tag()
                                details[field] = msg
                        }</span>
                        <span class="cov0" title="0">return nil, ProblemDetailsJSON(c, "Validation failed", nil, details, fiber.StatusBadRequest)</span> //nolint:errcheck
                }
                <span class="cov0" title="0">ProblemDetailsJSON(c, "Validation failed", err, "Request validation failed", fiber.StatusBadRequest) //nolint:errcheck
                return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;input, nil</span>
}

// SuccessResponseJSON writes a JSON response with the given status, message, and data using the standard Response struct.
// Use for successful API responses (e.g., 200, 201, 202).
func SuccessResponseJSON(c *fiber.Ctx, status int, message string, data any) error <span class="cov0" title="0">{
        return c.Status(status).JSON(Response{
                Status:  status,
                Message: message,
                Data:    data,
        })
}</span>

// errorToStatusCode maps domain errors to appropriate HTTP status codes.
func errorToStatusCode(err error) int <span class="cov0" title="0">{
        switch </span>{
        // Account errors
        case errors.Is(err, domain.ErrAccountNotFound):<span class="cov0" title="0">
                return fiber.StatusNotFound</span>
        case errors.Is(err, domain.ErrDepositAmountExceedsMaxSafeInt):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, domain.ErrTransactionAmountMustBePositive):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, domain.ErrWithdrawalAmountMustBePositive):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, domain.ErrInsufficientFunds):<span class="cov0" title="0">
                return fiber.StatusUnprocessableEntity</span>
        // Common errors
        case errors.Is(err, domain.ErrInvalidCurrencyCode):<span class="cov0" title="0">
                return fiber.StatusUnprocessableEntity</span>
        case errors.Is(err, common.ErrInvalidDecimalPlaces):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, common.ErrAmountExceedsMaxSafeInt):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        // Money/currency conversion errors
        case errors.Is(err, domain.ErrExchangeRateUnavailable):<span class="cov0" title="0">
                return fiber.StatusServiceUnavailable</span>
        case errors.Is(err, domain.ErrUnsupportedCurrencyPair):<span class="cov0" title="0">
                return fiber.StatusUnprocessableEntity</span>
        case errors.Is(err, domain.ErrExchangeRateExpired):<span class="cov0" title="0">
                return fiber.StatusServiceUnavailable</span>
        case errors.Is(err, domain.ErrExchangeRateInvalid):<span class="cov0" title="0">
                return fiber.StatusUnprocessableEntity</span>
        // User errors
        case errors.Is(err, user.ErrUserNotFound):<span class="cov0" title="0">
                return fiber.StatusNotFound</span>
        case errors.Is(err, user.ErrUserUnauthorized):<span class="cov0" title="0">
                return fiber.StatusUnauthorized</span>
        default:<span class="cov0" title="0">
                return fiber.StatusInternalServerError</span>
        }
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package currency

import (
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/middleware"
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        currencysvc "github.com/amirasaad/fintech/pkg/service/currency"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/gofiber/fiber/v2"
)

// CurrencyRoutes sets up currency-related routes
func CurrencyRoutes(app *fiber.App, currencySvc *currencysvc.CurrencyService, authSvc *authsvc.AuthService, cfg *config.AppConfig) <span class="cov0" title="0">{
        currencyGroup := app.Group("/api/currencies")

        // Public endpoints
        currencyGroup.Get("/", ListCurrencies(currencySvc))
        currencyGroup.Get("/supported", ListSupportedCurrencies(currencySvc))
        currencyGroup.Get("/:code", GetCurrency(currencySvc))
        currencyGroup.Get("/:code/supported", CheckCurrencySupported(currencySvc))
        currencyGroup.Get("/search", SearchCurrencies(currencySvc))
        currencyGroup.Get("/region/:region", SearchCurrenciesByRegion(currencySvc))
        currencyGroup.Get("/statistics", GetCurrencyStatistics(currencySvc))
        currencyGroup.Get("/default", GetDefaultCurrency(currencySvc))

        // Admin endpoints (require authentication)
        adminGroup := currencyGroup.Group("/admin")
        adminGroup.Post("/", middleware.JwtProtected(cfg.Jwt), RegisterCurrency(currencySvc))
        adminGroup.Delete("/:code", middleware.JwtProtected(cfg.Jwt), UnregisterCurrency(currencySvc))
        adminGroup.Put("/:code/activate", middleware.JwtProtected(cfg.Jwt), ActivateCurrency(currencySvc))
        adminGroup.Put("/:code/deactivate", middleware.JwtProtected(cfg.Jwt), DeactivateCurrency(currencySvc))
}</span>

// ListCurrencies returns a Fiber handler for listing all available currencies.
// @Summary List all currencies
// @Description Get a list of all available currencies in the system
// @Tags currencies
// @Accept json
// @Produce json
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /currency [get]
// @Security Bearer
func ListCurrencies(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                currencies, err := currencySvc.ListAllCurrencies(c.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to list currencies", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currencies fetched successfully", currencies)</span>
        }
}

// ListSupportedCurrencies returns all supported currency codes
// @Summary List supported currencies
// @Description Get all supported currency codes
// @Tags currencies
// @Accept json
// @Produce json
// @Success 200 {array} string
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/supported [get]
func ListSupportedCurrencies(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                currencies, err := currencySvc.ListSupportedCurrencies(c.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to list supported currencies", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Supported currencies fetched successfully", currencies)</span>
        }
}

// GetCurrency returns currency information by code
// @Summary Get currency by code
// @Description Get currency information by ISO 4217 code
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code (e.g., USD, EUR)"
// @Success 200 {object} currency.CurrencyMeta
// @Failure 400 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/{code} [get]
func GetCurrency(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Currency code is required", nil, "Missing currency code", fiber.StatusBadRequest)
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCurrencyCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid currency code", err, "Currency code must be a valid ISO 4217 code", fiber.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">currency, err := currencySvc.GetCurrency(c.Context(), code)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Currency not found", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currency fetched successfully", currency)</span>
        }
}

// CheckCurrencySupported checks if a currency is supported
// @Summary Check if currency is supported
// @Description Check if a currency code is supported
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code (e.g., USD, EUR)"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Router /api/currencies/{code}/supported [get]
func CheckCurrencySupported(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Currency code is required", nil)
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCurrencyCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid currency code", err)
                }</span>

                <span class="cov0" title="0">supported := currencySvc.IsCurrencySupported(c.Context(), code)
                return common.SuccessResponseJSON(c, fiber.StatusOK, "Currency support checked successfully", fiber.Map{"code": code, "supported": supported})</span>
        }
}

// SearchCurrencies searches for currencies by name
// @Summary Search currencies
// @Description Search for currencies by name
// @Tags currencies
// @Accept json
// @Produce json
// @Param q query string true "Search query"
// @Success 200 {array} currency.CurrencyMeta
// @Failure 400 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/search [get]
func SearchCurrencies(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                query := c.Query("q")
                if query == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Search query is required", nil, "Missing search query", fiber.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">currencies, err := currencySvc.SearchCurrencies(c.Context(), query)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to search currencies", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currencies searched successfully", currencies)</span>
        }
}

// SearchCurrenciesByRegion searches for currencies by region
// @Summary Search currencies by region
// @Description Search for currencies by region
// @Tags currencies
// @Accept json
// @Produce json
// @Param region path string true "Region name"
// @Success 200 {array} currency.CurrencyMeta
// @Failure 400 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/region/{region} [get]
func SearchCurrenciesByRegion(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                region := c.Params("region")
                if region == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Region is required", nil, "Missing region", fiber.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">currencies, err := currencySvc.SearchCurrenciesByRegion(c.Context(), region)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to search currencies by region", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currencies by region fetched successfully", currencies)</span>
        }
}

// GetCurrencyStatistics returns currency statistics
// @Summary Get currency statistics
// @Description Get currency registry statistics
// @Tags currencies
// @Accept json
// @Produce json
// @Success 200 {object} common.Response
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/statistics [get]
func GetCurrencyStatistics(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                stats, err := currencySvc.GetCurrencyStatistics(c.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to get currency statistics", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currency statistics fetched successfully", stats)</span>
        }
}

// GetDefaultCurrency returns the default currency information
// @Summary Get default currency
// @Description Get the default currency information
// @Tags currencies
// @Accept json
// @Produce json
// @Success 200 {object} currency.CurrencyMeta
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/default [get]
func GetDefaultCurrency(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                defaultCurrency, err := currencySvc.GetDefaultCurrency(c.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to get default currency", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Default currency fetched successfully", defaultCurrency)</span>
        }
}

// RegisterCurrency registers a new currency (admin only)
// @Summary Register currency
// @Description Register a new currency (admin only)
// @Tags currencies
// @Accept json
// @Produce json
// @Param currency body RegisterCurrencyRequest true "Currency information"
// @Success 201 {object} currency.CurrencyMeta
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 409 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/admin [post]
func RegisterCurrency(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                input, err := common.BindAndValidate[RegisterCurrencyRequest](c)
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Error already written by BindAndValidate
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err = currencySvc.ValidateCurrencyCode(c.Context(), input.Code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid currency code", err)
                }</span>

                <span class="cov0" title="0">currencyMeta := currency.CurrencyMeta{
                        Code:     input.Code,
                        Name:     input.Name,
                        Symbol:   input.Symbol,
                        Decimals: input.Decimals,
                        Country:  input.Country,
                        Region:   input.Region,
                        Active:   input.Active,
                        Metadata: input.Metadata,
                }

                if err = currencySvc.RegisterCurrency(c.Context(), currencyMeta); err != nil </span><span class="cov0" title="0">{
                        if err == currency.ErrCurrencyExists </span><span class="cov0" title="0">{
                                return common.ProblemDetailsJSON(c, "Failed to register currency", err)
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(c, "Failed to register currency", err)</span>
                }

                // Get the registered currency
                <span class="cov0" title="0">registered, err := currencySvc.GetCurrency(c.Context(), input.Code)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to retrieve registered currency", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusCreated, "Currency registered successfully", registered)</span>
        }
}

// UnregisterCurrency removes a currency from the registry (admin only)
// @Summary Unregister currency
// @Description Remove a currency from the registry (admin only)
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/admin/{code} [delete]
func UnregisterCurrency(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Currency code is required", nil)
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCurrencyCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid currency code", err)
                }</span>

                <span class="cov0" title="0">if err := currencySvc.UnregisterCurrency(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        if err == currency.ErrCurrencyNotFound </span><span class="cov0" title="0">{
                                return common.ProblemDetailsJSON(c, "Failed to unregister currency", err)
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(c, "Failed to unregister currency", err)</span>
                }
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currency unregistered successfully", fiber.Map{"code": code})</span>
        }
}

// ActivateCurrency activates a currency (admin only)
// @Summary Activate currency
// @Description Activate a currency (admin only)
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/admin/{code}/activate [put]
func ActivateCurrency(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Currency code is required", nil)
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCurrencyCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid currency code", err)
                }</span>

                <span class="cov0" title="0">if err := currencySvc.ActivateCurrency(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        if err == currency.ErrCurrencyNotFound </span><span class="cov0" title="0">{
                                return common.ProblemDetailsJSON(c, "Failed to activate currency", err)
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(c, "Failed to activate currency", err)</span>
                }
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currency activated successfully", fiber.Map{"code": code})</span>
        }
}

// DeactivateCurrency deactivates a currency (admin only)
// @Summary Deactivate currency
// @Description Deactivate a currency (admin only)
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/admin/{code}/deactivate [put]
func DeactivateCurrency(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Currency code is required", nil)
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCurrencyCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid currency code", err)
                }</span>

                <span class="cov0" title="0">if err := currencySvc.DeactivateCurrency(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        if err == currency.ErrCurrencyNotFound </span><span class="cov0" title="0">{
                                return common.ProblemDetailsJSON(c, "Failed to deactivate currency", err)
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(c, "Failed to deactivate currency", err)</span>
                }
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currency deactivated successfully", fiber.Map{"code": code})</span>
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package testutils

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "net/http/httptest"
        "os"
        "path/filepath"
        "runtime"
        "time"

        "github.com/amirasaad/fintech/infra/provider"
        infrarepo "github.com/amirasaad/fintech/infra/repository"
        fixturescurrency "github.com/amirasaad/fintech/internal/fixtures/currency"
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/service/account"
        "github.com/amirasaad/fintech/pkg/service/auth"
        currencyservice "github.com/amirasaad/fintech/pkg/service/currency"
        userservice "github.com/amirasaad/fintech/pkg/service/user"
        "github.com/amirasaad/fintech/webapi"
        "github.com/amirasaad/fintech/webapi/common"

        "github.com/gofiber/fiber/v2"
        "github.com/golang-migrate/migrate/v4"
        migratepostgres "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "github.com/google/uuid"
        "github.com/stretchr/testify/suite"
        "github.com/testcontainers/testcontainers-go"
        tcpostgres "github.com/testcontainers/testcontainers-go/modules/postgres"
        "github.com/testcontainers/testcontainers-go/wait"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

// E2ETestSuite provides a test suite with a real Postgres database using Testcontainers
type E2ETestSuite struct {
        suite.Suite
        pgContainer *tcpostgres.PostgresContainer
        db          *gorm.DB
        app         *fiber.App
        cfg         *config.AppConfig
}

func (s *E2ETestSuite) BeforeTest() <span class="cov0" title="0">{
        s.T().Parallel()
}</span>

// SetupSuite initializes the test suite with a real Postgres database
func (s *E2ETestSuite) SetupSuite() <span class="cov0" title="0">{
        ctx := context.Background()

        // Start Postgres container
        pg, err := tcpostgres.Run(
                ctx,
                "postgres:15-alpine",
                tcpostgres.WithDatabase("testdb"),
                tcpostgres.WithUsername("test"),
                tcpostgres.WithPassword("test"),
                testcontainers.WithWaitStrategy(
                        wait.ForLog("database system is ready to accept connections").
                                WithOccurrence(2).WithStartupTimeout(30*time.Second),
                ),
        )
        s.Require().NoError(err)
        s.pgContainer = pg

        // Get connection string and connect to database
        dsn, err := pg.ConnectionString(ctx, "sslmode=disable")
        s.Require().NoError(err)

        s.db, err = gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        s.Require().NoError(err)

        // Run migrations
        sqlDB, err := s.db.DB()
        s.Require().NoError(err)

        driver, err := migratepostgres.WithInstance(sqlDB, &amp;migratepostgres.Config{})
        s.Require().NoError(err)

        _, filename, _, _ := runtime.Caller(0)
        migrationsPath := filepath.Join(filepath.Dir(filename), "../../internal/migrations")

        m, err := migrate.NewWithDatabaseInstance("file://"+migrationsPath, "postgres", driver)
        s.Require().NoError(err)

        err = m.Up()
        if err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                s.Require().NoError(err)
        }</span>

        // Load config
        <span class="cov0" title="0">cfgPath, err := s.findEnvTest()
        s.Require().NoError(err)
        s.cfg, err = config.LoadAppConfig(slog.Default(), cfgPath)
        s.Require().NoError(err)
        s.cfg.DB.Url = dsn

        // Setup services and app
        s.setupApp()</span>
        // log.SetOutput(io.Discard)
}

// TearDownSuite cleans up the test suite resources
func (s *E2ETestSuite) TearDownSuite() <span class="cov0" title="0">{
        ctx := context.Background()
        if s.pgContainer != nil </span><span class="cov0" title="0">{
                _ = s.pgContainer.Terminate(ctx)
        }</span>
}

// setupApp creates all services and the test app
func (s *E2ETestSuite) setupApp() <span class="cov0" title="0">{
        uow := infrarepo.NewUoW(s.db)
        logger := slog.Default()

        // Create services
        authStrategy := auth.NewJWTAuthStrategy(uow, s.cfg.Jwt, logger)
        authService := auth.NewAuthService(uow, authStrategy, logger)
        currencyConverter := provider.NewStubCurrencyConverter()
        accountSvc := account.NewAccountService(uow, currencyConverter, logger)
        userSvc := userservice.NewUserService(uow, logger)

        // Setup currency service
        ctx := context.Background()
        currencyRegistry, err := currency.NewCurrencyRegistry(ctx)
        s.Require().NoError(err)

        // Load currency fixtures
        _, filename, _, _ := runtime.Caller(0)
        fixturePath := filepath.Join(filepath.Dir(filename), "../../internal/fixtures/currency/meta.csv")
        metas, err := fixturescurrency.LoadCurrencyMetaCSV(fixturePath)
        s.Require().NoError(err)

        for _, meta := range metas </span><span class="cov0" title="0">{
                s.Require().NoError(currencyRegistry.Register(meta))
        }</span>

        <span class="cov0" title="0">currencySvc := currencyservice.NewCurrencyService(currencyRegistry, logger)

        // Create test app
        s.app = webapi.NewApp(accountSvc, userSvc, authService, currencySvc, s.cfg)</span>
}

// findEnvTest searches for the nearest .env.test file
func (s *E2ETestSuite) findEnvTest() (string, error) <span class="cov0" title="0">{
        startDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">curr := startDir
        for </span><span class="cov0" title="0">{
                candidate := filepath.Join(curr, ".env.test")
                if _, err = os.Stat(candidate); err == nil </span><span class="cov0" title="0">{
                        return candidate, nil
                }</span>
                <span class="cov0" title="0">parent := filepath.Dir(curr)
                if parent == curr </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">curr = parent</span>
        }
        <span class="cov0" title="0">return "", os.ErrNotExist</span>
}

// MakeRequest is a helper for making HTTP requests in tests
func (s *E2ETestSuite) MakeRequest(method, path, body, token string) *http.Response <span class="cov0" title="0">{
        var req *http.Request
        if body != "" </span><span class="cov0" title="0">{
                req = httptest.NewRequest(method, path, bytes.NewBufferString(body))
                req.Header.Set("Content-Type", "application/json")
        }</span> else<span class="cov0" title="0"> {
                req = httptest.NewRequest(method, path, nil)
        }</span>
        <span class="cov0" title="0">if token != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+token)
        }</span>
        <span class="cov0" title="0">resp, err := s.app.Test(req, 1000000)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return resp</span>
}

// CreateTestUser creates a unique test user via the POST /user/ endpoint
func (s *E2ETestSuite) CreateTestUser() *domain.User <span class="cov0" title="0">{
        randomID := uuid.New().String()[:8]
        username := fmt.Sprintf("testuser_%s", randomID)
        email := fmt.Sprintf("test_%s@example.com", randomID)

        // Create user via HTTP POST request
        createUserBody := fmt.Sprintf(`{"username":"%s","email":"%s","password":"password123"}`, username, email)
        resp := s.MakeRequest("POST", "/user", createUserBody, "")

        if resp.StatusCode != 201 </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Expected 201 Created for user creation, got %d", resp.StatusCode))</span>
        }

        // Parse response to get the created user
        <span class="cov0" title="0">var response common.Response
        err := json.NewDecoder(resp.Body).Decode(&amp;response)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Extract user data from response
        <span class="cov0" title="0">if userData, ok := response.Data.(map[string]any); ok </span><span class="cov0" title="0">{
                userIDStr, ok := userData["id"].(string)
                if !ok </span><span class="cov0" title="0">{
                        panic("User ID should be present in response")</span>
                }

                <span class="cov0" title="0">userID, err := uuid.Parse(userIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">return &amp;domain.User{
                        ID:       userID,
                        Username: username,
                        Email:    email,
                        Password: "password123",
                }</span>
        }

        // Fallback: create user directly
        <span class="cov0" title="0">testUser, err := user.NewUser(username, email, "password123")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return testUser</span>
}

// LoginUser makes an actual HTTP request to login and returns the JWT token
func (s *E2ETestSuite) LoginUser(testUser *domain.User) string <span class="cov0" title="0">{
        loginBody := fmt.Sprintf(`{"identity":"%s","password":"password123"}`, testUser.Email)
        resp := s.MakeRequest("POST", "/auth/login", loginBody, "")

        var response common.Response
        err := json.NewDecoder(resp.Body).Decode(&amp;response)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Extract token from response
        <span class="cov0" title="0">var token string
        if dataMap, ok := response.Data.(map[string]any); ok </span><span class="cov0" title="0">{
                if tokenInterface, exists := dataMap["token"]; exists </span><span class="cov0" title="0">{
                        token = tokenInterface.(string)
                }</span>
        } else<span class="cov0" title="0"> if dataMap, ok := response.Data.(map[string]string); ok </span><span class="cov0" title="0">{
                token = dataMap["token"]
        }</span>

        <span class="cov0" title="0">if token == "" </span><span class="cov0" title="0">{
                panic("No token found in response")</span>
        }
        <span class="cov0" title="0">return token</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package user

import (
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/middleware"
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        usersvc "github.com/amirasaad/fintech/pkg/service/user"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

func UserRoutes(app *fiber.App, userSvc *usersvc.UserService, authSvc *authsvc.AuthService, cfg *config.AppConfig) <span class="cov8" title="1">{
        app.Get("/user/:id", middleware.JwtProtected(cfg.Jwt), GetUser(userSvc))
        app.Post("/user", CreateUser(userSvc))
        app.Put("/user/:id", middleware.JwtProtected(cfg.Jwt), UpdateUser(userSvc, authSvc))
        app.Delete("/user/:id", middleware.JwtProtected(cfg.Jwt), DeleteUser(userSvc, authSvc))
}</span>

// GetUser returns a Fiber handler for retrieving a user by ID.
// @Summary Get user by ID
// @Description Retrieve a user by their ID
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Router /user/{id} [get]
// @Security Bearer
func GetUser(userSvc *usersvc.UserService) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid user ID: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err, "User ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">user, err := userSvc.GetUser(c.Context(), id.String())
                if err != nil || user == nil </span><span class="cov8" title="1">{
                        // Generic error for not found to prevent user enumeration
                        return common.ProblemDetailsJSON(c, "Invalid credentials", nil, fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusOK, "User found", user)</span>
        }
}

// CreateUser creates a new user account.
// @Summary Create a new user
// @Description Create a new user account with username, email, and password
// @Tags users
// @Accept json
// @Produce json
// @Param request body NewUser true "User creation data"
// @Success 201 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /user [post]
func CreateUser(userSvc *usersvc.UserService) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                input, err := common.BindAndValidate[NewUser](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">if len(input.Password) &gt; 72 </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid request body", nil, "Password too long")
                }</span>
                <span class="cov8" title="1">user, err := userSvc.CreateUser(c.Context(), input.Username, input.Email, input.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Couldn't create user", err)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusCreated, "Created user", user)</span>
        }
}

// UpdateUser updates user information.
// @Summary Update user
// @Description Update user information by ID
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Param request body UpdateUserInput true "User update data"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /user/{id} [put]
// @Security Bearer
func UpdateUser(
        userSvc *usersvc.UserService,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                input, err := common.BindAndValidate[UpdateUserInput](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid user ID: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err, "User ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context", fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">if id != userID </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Forbidden", nil, "You are not allowed to update this user", fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">err = userSvc.UpdateUser(c.Context(), id.String(), func(u *user.User) error </span><span class="cov8" title="1">{
                        u.Names = input.Names
                        return nil
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        // Generic error for update failure
                        return common.ProblemDetailsJSON(c, "Invalid credentials", nil, fiber.StatusUnauthorized)
                }</span>
                // Get the updated user to return in response
                <span class="cov8" title="1">updatedUser, err := userSvc.GetUser(c.Context(), id.String())
                if err != nil || updatedUser == nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid credentials", nil, fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusOK, "User updated successfully", updatedUser)</span>
        }
}

// DeleteUser deletes a user account.
// @Summary Delete user
// @Description Delete a user account by ID with password confirmation
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Param request body PasswordInput true "Password confirmation"
// @Success 204 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /user/{id} [delete]
// @Security Bearer
func DeleteUser(
        userSvc *usersvc.UserService,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                input, err := common.BindAndValidate[PasswordInput](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid user ID: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err, "User ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context", fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">if id != userID </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Forbidden", nil, "You are not allowed to update this user", fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">isValid, err := userSvc.ValidUser(c.Context(), id.String(), input.Password)
                if err != nil </span><span class="cov0" title="0">{
                        // If this is a DB/internal error, return 500
                        return common.ProblemDetailsJSON(c, "Failed to validate user", err, fiber.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">if !isValid </span><span class="cov8" title="1">{
                        // Invalid password or user not found
                        return common.ProblemDetailsJSON(c, "Invalid credentials", nil, fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">err = userSvc.DeleteUser(c.Context(), id.String())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to delete user", err, fiber.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusNoContent, "User successfully deleted", nil)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
