
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/amirasaad/fintech/app/app.go (0.0%)</option>

				<option value="file1">github.com/amirasaad/fintech/docs/docs.go (0.0%)</option>

				<option value="file2">github.com/amirasaad/fintech/infra/cache/memory_cache.go (0.0%)</option>

				<option value="file3">github.com/amirasaad/fintech/infra/cache/redis_cache.go (0.0%)</option>

				<option value="file4">github.com/amirasaad/fintech/infra/database.go (0.0%)</option>

				<option value="file5">github.com/amirasaad/fintech/infra/eventbus/memory_event_bus.go (0.0%)</option>

				<option value="file6">github.com/amirasaad/fintech/infra/factory.go (0.0%)</option>

				<option value="file7">github.com/amirasaad/fintech/infra/provider/currency_converter.go (0.0%)</option>

				<option value="file8">github.com/amirasaad/fintech/infra/provider/exchange_rates.go (68.0%)</option>

				<option value="file9">github.com/amirasaad/fintech/infra/provider/exchangerate_api.go (0.0%)</option>

				<option value="file10">github.com/amirasaad/fintech/infra/provider/mock_payment_provider.go (0.0%)</option>

				<option value="file11">github.com/amirasaad/fintech/infra/provider/stub_currency_converter.go (0.0%)</option>

				<option value="file12">github.com/amirasaad/fintech/infra/repository/repository.go (23.0%)</option>

				<option value="file13">github.com/amirasaad/fintech/infra/repository/uow.go (93.9%)</option>

				<option value="file14">github.com/amirasaad/fintech/pkg/config/app_config.go (0.0%)</option>

				<option value="file15">github.com/amirasaad/fintech/pkg/config/env.go (43.5%)</option>

				<option value="file16">github.com/amirasaad/fintech/pkg/currency/currency.go (80.7%)</option>

				<option value="file17">github.com/amirasaad/fintech/pkg/domain/account/account.go (65.8%)</option>

				<option value="file18">github.com/amirasaad/fintech/pkg/domain/account/event.go (25.0%)</option>

				<option value="file19">github.com/amirasaad/fintech/pkg/domain/account/transaction.go (0.0%)</option>

				<option value="file20">github.com/amirasaad/fintech/pkg/domain/money/money.go (82.1%)</option>

				<option value="file21">github.com/amirasaad/fintech/pkg/domain/user/user.go (66.7%)</option>

				<option value="file22">github.com/amirasaad/fintech/pkg/handler/base.go (100.0%)</option>

				<option value="file23">github.com/amirasaad/fintech/pkg/handler/builder.go (100.0%)</option>

				<option value="file24">github.com/amirasaad/fintech/pkg/handler/chain.go (0.0%)</option>

				<option value="file25">github.com/amirasaad/fintech/pkg/handler/deposit_persistence.go (61.3%)</option>

				<option value="file26">github.com/amirasaad/fintech/pkg/handler/money.go (78.6%)</option>

				<option value="file27">github.com/amirasaad/fintech/pkg/handler/operation.go (61.5%)</option>

				<option value="file28">github.com/amirasaad/fintech/pkg/handler/transaction_factory.go (100.0%)</option>

				<option value="file29">github.com/amirasaad/fintech/pkg/handler/transfer_persistence.go (56.4%)</option>

				<option value="file30">github.com/amirasaad/fintech/pkg/handler/validation.go (73.0%)</option>

				<option value="file31">github.com/amirasaad/fintech/pkg/handler/withdraw_persistence.go (61.3%)</option>

				<option value="file32">github.com/amirasaad/fintech/pkg/middleware/auth.go (100.0%)</option>

				<option value="file33">github.com/amirasaad/fintech/pkg/registry/enhanced_registry.go (63.4%)</option>

				<option value="file34">github.com/amirasaad/fintech/pkg/registry/factory.go (34.9%)</option>

				<option value="file35">github.com/amirasaad/fintech/pkg/registry/implementations.go (59.8%)</option>

				<option value="file36">github.com/amirasaad/fintech/pkg/registry/interface.go (89.3%)</option>

				<option value="file37">github.com/amirasaad/fintech/pkg/registry/registry.go (98.4%)</option>

				<option value="file38">github.com/amirasaad/fintech/pkg/service/account/account.go (39.8%)</option>

				<option value="file39">github.com/amirasaad/fintech/pkg/service/account/chain.go (25.0%)</option>

				<option value="file40">github.com/amirasaad/fintech/pkg/service/account/queries.go (85.7%)</option>

				<option value="file41">github.com/amirasaad/fintech/pkg/service/auth/auth.go (47.6%)</option>

				<option value="file42">github.com/amirasaad/fintech/pkg/service/currency/currency.go (91.3%)</option>

				<option value="file43">github.com/amirasaad/fintech/pkg/service/currency/currency_converter.go (0.0%)</option>

				<option value="file44">github.com/amirasaad/fintech/pkg/service/user/user.go (80.5%)</option>

				<option value="file45">github.com/amirasaad/fintech/pkg/utils/utils.go (0.0%)</option>

				<option value="file46">github.com/amirasaad/fintech/webapi/account/account.go (62.0%)</option>

				<option value="file47">github.com/amirasaad/fintech/webapi/account/dto.go (0.0%)</option>

				<option value="file48">github.com/amirasaad/fintech/webapi/account/webhook.go (14.3%)</option>

				<option value="file49">github.com/amirasaad/fintech/webapi/app.go (81.5%)</option>

				<option value="file50">github.com/amirasaad/fintech/webapi/auth/auth.go (81.2%)</option>

				<option value="file51">github.com/amirasaad/fintech/webapi/common/utils.go (0.0%)</option>

				<option value="file52">github.com/amirasaad/fintech/webapi/currency/currency.go (0.0%)</option>

				<option value="file53">github.com/amirasaad/fintech/webapi/testutils/testutils.go (0.0%)</option>

				<option value="file54">github.com/amirasaad/fintech/webapi/user/user.go (73.3%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package app

import (
        "context"
        "errors"
        "strings"

        accountsvc "github.com/amirasaad/fintech/pkg/service/account"
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        currencysvc "github.com/amirasaad/fintech/pkg/service/currency"
        usersvc "github.com/amirasaad/fintech/pkg/service/user"
        "github.com/amirasaad/fintech/webapi/account"
        "github.com/amirasaad/fintech/webapi/auth"
        "github.com/amirasaad/fintech/webapi/common"
        currencywebapi "github.com/amirasaad/fintech/webapi/currency"
        "github.com/amirasaad/fintech/webapi/user"
        "github.com/gofiber/fiber/v2/middleware/limiter"
        "github.com/gofiber/swagger"

        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/handler"

        accountdomain "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/recover"
        "github.com/google/uuid"
)

// New builds all services, registers event handlers, and returns the Fiber app.
func New(deps config.Deps) *fiber.App <span class="cov0" title="0">{
        // Build services
        accountSvc := accountsvc.NewService(deps)
        userSvc := usersvc.NewService(deps)
        authStrategy := authsvc.NewJWTAuthStrategy(deps.Uow, deps.Config.Jwt, deps.Logger)
        authSvc := authsvc.NewAuthService(deps.Uow, authStrategy, deps.Logger)
        currencySvc := currencysvc.NewCurrencyService(deps.CurrencyRegistry, deps.Logger)

        // Register event handlers (example for DepositRequestedEvent)
        accountChain := handler.NewAccountChain(deps.Uow, deps.CurrencyConverter, deps.Logger)
        deps.EventBus.Subscribe("DepositRequestedEvent", func(e domain.Event) </span><span class="cov0" title="0">{
                // Use type assertion with ok check
                if evt, ok := e.(accountdomain.DepositRequestedEvent); ok </span><span class="cov0" title="0">{
                        userID := uuid.MustParse(evt.UserID)
                        accountID := uuid.MustParse(evt.AccountID)
                        amount := evt.Amount
                        currencyCode := currency.Code(evt.Currency)
                        moneySource := string(evt.Source)
                        paymentID := evt.PaymentID
                        _, err := accountChain.Deposit(context.Background(), userID, accountID, amount, currencyCode, moneySource, paymentID)
                        if err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Error("Deposit event handler failed", "error", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        deps.Logger.Error("event type assertion failed", "event", e)
                }</span>
        })
        <span class="cov0" title="0">deps.EventBus.Subscribe("WithdrawRequestedEvent", func(e domain.Event) </span><span class="cov0" title="0">{
                if evt, ok := e.(accountdomain.WithdrawRequestedEvent); ok </span><span class="cov0" title="0">{
                        userID := uuid.MustParse(evt.UserID)
                        accountID := uuid.MustParse(evt.AccountID)
                        amount := evt.Amount
                        currencyCode := currency.Code(evt.Currency)
                        externalTarget := evt.Target
                        paymentID := evt.PaymentID
                        _, err := accountChain.Withdraw(context.Background(), userID, accountID, amount, currencyCode, handler.ExternalTarget(externalTarget), paymentID)
                        if err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Error("Withdraw event handler failed", "error", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        deps.Logger.Error("event type assertion failed", "event", e)
                }</span>
        })
        <span class="cov0" title="0">deps.EventBus.Subscribe("TransferRequestedEvent", func(e domain.Event) </span><span class="cov0" title="0">{
                if evt, ok := e.(accountdomain.TransferRequestedEvent); ok </span><span class="cov0" title="0">{
                        senderUserID := evt.SenderUserID
                        receiverUserID := evt.ReceiverUserID
                        sourceAccID := evt.SourceAccountID
                        destAccID := evt.DestAccountID
                        amount := evt.Amount
                        currencyCode := currency.Code(evt.Currency)
                        _, err := accountChain.Transfer(context.Background(), senderUserID, receiverUserID, sourceAccID, destAccID, amount, currencyCode)
                        if err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Error("Deposit event handler failed", "error", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        deps.Logger.Error("event type assertion failed", "event", e)
                }</span>
        })

        <span class="cov0" title="0">app := fiber.New(fiber.Config{
                ErrorHandler: func(c *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Internal Server Error", err)
                }</span>,
        })
        <span class="cov0" title="0">app.Get("/swagger/*", swagger.New(swagger.Config{
                TryItOutEnabled:      true,
                WithCredentials:      true,
                PersistAuthorization: true,
                OAuth2RedirectUrl:    "/auth/login",
        }))

        app.Use(limiter.New(limiter.Config{
                Max:        deps.Config.RateLimit.MaxRequests,
                Expiration: deps.Config.RateLimit.Window,
                KeyGenerator: func(c *fiber.Ctx) string </span><span class="cov0" title="0">{
                        // Use X-Forwarded-For header if available (for load balancers/proxies)
                        // Fall back to X-Real-IP, then to direct IP
                        if forwardedFor := c.Get("X-Forwarded-For"); forwardedFor != "" </span><span class="cov0" title="0">{
                                // Take the first IP in the chain
                                if commaIndex := strings.Index(forwardedFor, ","); commaIndex != -1 </span><span class="cov0" title="0">{
                                        return strings.TrimSpace(forwardedFor[:commaIndex])
                                }</span>
                                <span class="cov0" title="0">return strings.TrimSpace(forwardedFor)</span>
                        }
                        <span class="cov0" title="0">if realIP := c.Get("X-Real-IP"); realIP != "" </span><span class="cov0" title="0">{
                                return realIP
                        }</span>
                        <span class="cov0" title="0">return c.IP()</span>
                },
                LimitReached: func(c *fiber.Ctx) error <span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Too Many Requests", errors.New("rate limit exceeded"), fiber.StatusTooManyRequests)
                }</span>,
        }))
        <span class="cov0" title="0">app.Use(recover.New())

        app.Get("/", func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                return c.SendString("App is working! 🚀")
        }</span>)

        <span class="cov0" title="0">app.Post("/webhook/payment", account.PaymentWebhookHandler(accountSvc))

        account.Routes(app, accountSvc, authSvc, deps.Config)
        user.Routes(app, userSvc, authSvc, deps.Config)
        auth.Routes(app, authSvc)
        currencywebapi.Routes(app, currencySvc, authSvc, deps.Config)
        return app</span>
}
</pre>

		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "email": "fiber@swagger.io"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/account": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Creates a new account for the authenticated user. You can specify the currency for the account. Returns the created account details.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Create a new account",
                "responses": {
                    "201": {
                        "description": "Account created successfully",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Invalid request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too many requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/account/{id}/balance": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Retrieves the current balance for the specified account. Returns the balance amount and currency.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Get account balance",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Balance fetched",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Invalid request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too many requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/account/{id}/deposit": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Adds funds to the specified account. Specify the amount, currency, and optional money source. Returns the transaction details.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Deposit funds into an account",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Deposit details",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/account.DepositRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Deposit successful",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Invalid request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too many requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/account/{id}/transactions": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Retrieves a list of transactions for the specified account. Returns an array of transaction details.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Get account transactions",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Transactions fetched",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Invalid request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too many requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/account/{id}/transfer": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Transfers a specified amount from one account to another. Specify the source and destination account IDs, amount, and currency. Returns the transaction details.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Transfer funds between accounts",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Source Account ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Transfer details",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/account.TransferRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Transfer successful",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Invalid request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "422": {
                        "description": "Unprocessable entity",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too many requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/account/{id}/withdraw": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Withdraws a specified amount from the user's account. Specify the amount and currency. Returns the transaction details.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "accounts"
                ],
                "summary": "Withdraw funds from an account",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Account ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Withdrawal details",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/account.WithdrawRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Withdrawal successful",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Invalid request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too many requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/admin": {
            "post": {
                "description": "Register a new currency (admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Register currency",
                "parameters": [
                    {
                        "description": "Currency information",
                        "name": "currency",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/currency.RegisterCurrencyRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/currency.CurrencyMeta"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/admin/{code}": {
            "delete": {
                "description": "Remove a currency from the registry (admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Unregister currency",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Currency code",
                        "name": "code",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/admin/{code}/activate": {
            "put": {
                "description": "Activate a currency (admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Activate currency",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Currency code",
                        "name": "code",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/admin/{code}/deactivate": {
            "put": {
                "description": "Deactivate a currency (admin only)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Deactivate currency",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Currency code",
                        "name": "code",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/default": {
            "get": {
                "description": "Get the default currency information",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Get default currency",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/currency.CurrencyMeta"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/region/{region}": {
            "get": {
                "description": "Search for currencies by region",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Search currencies by region",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Region name",
                        "name": "region",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/currency.CurrencyMeta"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/search": {
            "get": {
                "description": "Search for currencies by name",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Search currencies",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Search query",
                        "name": "q",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/currency.CurrencyMeta"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/statistics": {
            "get": {
                "description": "Get currency registry statistics",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Get currency statistics",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/supported": {
            "get": {
                "description": "Get all supported currency codes",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "List supported currencies",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/{code}": {
            "get": {
                "description": "Get currency information by ISO 4217 code",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Get currency by code",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Currency code (e.g., USD, EUR)",
                        "name": "code",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/currency.CurrencyMeta"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/api/currencies/{code}/supported": {
            "get": {
                "description": "Check if a currency code is supported",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "Check if currency is supported",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Currency code (e.g., USD, EUR)",
                        "name": "code",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/auth/login": {
            "post": {
                "description": "Authenticate user with identity (username or email) and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "Login credentials",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/auth.LoginInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/currency": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get a list of all available currencies in the system",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "currencies"
                ],
                "summary": "List all currencies",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/user": {
            "post": {
                "description": "Create a new user account with username, email, and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Create a new user",
                "parameters": [
                    {
                        "description": "User creation data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user.NewUser"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        },
        "/user/{id}": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Retrieve a user by their ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get user by ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Update user information by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Update user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "User update data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user.UpdateUserInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Delete a user account by ID with password confirmation",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Delete user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Password confirmation",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user.PasswordInput"
                        }
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content",
                        "schema": {
                            "$ref": "#/definitions/common.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "429": {
                        "description": "Too Many Requests",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ProblemDetails"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "account.DepositRequest": {
            "type": "object",
            "required": [
                "amount",
                "money_source"
            ],
            "properties": {
                "amount": {
                    "type": "number"
                },
                "currency": {
                    "type": "string"
                },
                "money_source": {
                    "type": "string",
                    "maxLength": 64,
                    "minLength": 2
                }
            }
        },
        "account.TransferRequest": {
            "type": "object",
            "required": [
                "amount",
                "destination_account_id"
            ],
            "properties": {
                "amount": {
                    "type": "number"
                },
                "currency": {
                    "type": "string"
                },
                "destination_account_id": {
                    "type": "string"
                }
            }
        },
        "account.WithdrawRequest": {
            "type": "object",
            "required": [
                "amount"
            ],
            "properties": {
                "amount": {
                    "type": "number"
                },
                "currency": {
                    "type": "string"
                }
            }
        },
        "auth.LoginInput": {
            "type": "object",
            "required": [
                "identity",
                "password"
            ],
            "properties": {
                "identity": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "common.ProblemDetails": {
            "type": "object",
            "properties": {
                "detail": {
                    "description": "Human-readable explanation",
                    "type": "string"
                },
                "errors": {
                    "description": "Optional: additional error details"
                },
                "instance": {
                    "description": "URI reference that identifies the specific occurrence",
                    "type": "string"
                },
                "status": {
                    "description": "HTTP status code",
                    "type": "integer"
                },
                "title": {
                    "description": "Short, human-readable summary",
                    "type": "string"
                },
                "type": {
                    "description": "A URI reference that identifies the problem type",
                    "type": "string"
                }
            }
        },
        "common.Response": {
            "type": "object",
            "properties": {
                "data": {
                    "description": "Response data"
                },
                "message": {
                    "description": "Human-readable explanation",
                    "type": "string"
                },
                "status": {
                    "description": "HTTP status code",
                    "type": "integer"
                }
            }
        },
        "currency.CurrencyMeta": {
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "code": {
                    "type": "string"
                },
                "country": {
                    "type": "string"
                },
                "created": {
                    "type": "string"
                },
                "decimals": {
                    "type": "integer"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "region": {
                    "type": "string"
                },
                "symbol": {
                    "type": "string"
                },
                "updated": {
                    "type": "string"
                }
            }
        },
        "currency.RegisterCurrencyRequest": {
            "type": "object",
            "required": [
                "code",
                "decimals",
                "name",
                "symbol"
            ],
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "code": {
                    "type": "string"
                },
                "country": {
                    "type": "string"
                },
                "decimals": {
                    "type": "integer",
                    "maximum": 8,
                    "minimum": 0
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "region": {
                    "type": "string"
                },
                "symbol": {
                    "type": "string"
                }
            }
        },
        "user.NewUser": {
            "type": "object",
            "required": [
                "email",
                "password",
                "username"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "maxLength": 50
                },
                "password": {
                    "type": "string",
                    "maxLength": 72,
                    "minLength": 6
                },
                "username": {
                    "type": "string",
                    "maxLength": 50,
                    "minLength": 3
                }
            }
        },
        "user.PasswordInput": {
            "type": "object",
            "required": [
                "password"
            ],
            "properties": {
                "password": {
                    "type": "string"
                }
            }
        },
        "user.UpdateUserInput": {
            "type": "object",
            "properties": {
                "names": {
                    "type": "string",
                    "maxLength": 100
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0.0",
        Host:             "fintech-beryl-beta.vercel.app",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "Fintech API",
        Description:      "Fintech API documentation",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>

		<pre class="file" id="file2" style="display: none">package cache

import (
        "sync"
        "time"

        "github.com/amirasaad/fintech/pkg/domain"
)

// MemoryCache implements ExchangeRateCache using in-memory storage
type MemoryCache struct {
        cache      map[string]*cacheEntry
        lastUpdate map[string]time.Time
        mu         sync.RWMutex
}

// NewMemoryCache creates a new in-memory cache
func NewMemoryCache() *MemoryCache <span class="cov0" title="0">{
        cache := &amp;MemoryCache{
                cache:      make(map[string]*cacheEntry),
                lastUpdate: make(map[string]time.Time),
        }

        // Start cleanup goroutine
        go cache.cleanup()

        return cache
}</span>

// Get retrieves a rate from cache
func (c *MemoryCache) Get(key string) (*domain.ExchangeRate, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        entry, exists := c.cache[key]
        if !exists </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if time.Now().After(entry.expiresAt) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return entry.rate, nil</span>
}

// Set stores a rate in cache with TTL
func (c *MemoryCache) Set(key string, rate *domain.ExchangeRate, ttl time.Duration) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.cache[key] = &amp;cacheEntry{
                rate:      rate,
                expiresAt: time.Now().Add(ttl),
        }

        return nil
}</span>

// Delete removes a rate from cache
func (c *MemoryCache) Delete(key string) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.cache, key)
        return nil
}</span>

// GetLastUpdate returns the last update timestamp for a key
func (c *MemoryCache) GetLastUpdate(key string) (time.Time, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        ts, ok := c.lastUpdate[key]
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, nil
        }</span>
        <span class="cov0" title="0">return ts, nil</span>
}

// SetLastUpdate sets the last update timestamp for a key
func (c *MemoryCache) SetLastUpdate(key string, t time.Time) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.lastUpdate[key] = t
        return nil
}</span>

// cleanup removes expired entries from cache
func (c *MemoryCache) cleanup() <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                c.mu.Lock()
                now := time.Now()
                for key, entry := range c.cache </span><span class="cov0" title="0">{
                        if now.After(entry.expiresAt) </span><span class="cov0" title="0">{
                                delete(c.cache, key)
                        }</span>
                }
                <span class="cov0" title="0">c.mu.Unlock()</span>
        }
}

type cacheEntry struct {
        rate      *domain.ExchangeRate
        expiresAt time.Time
}
</pre>

		<pre class="file" id="file3" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "time"

        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/redis/go-redis/v9"
)

// RedisExchangeRateCache implements ExchangeRateCache using Redis.
type RedisExchangeRateCache struct {
        client *redis.Client
        prefix string
        logger *slog.Logger
}

// NewRedisExchangeRateCache creates a new RedisExchangeRateCache.
func NewRedisExchangeRateCache(addr, password string, db int, prefix string) *RedisExchangeRateCache <span class="cov0" title="0">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:     addr,
                Password: password,
                DB:       db,
        })
        return &amp;RedisExchangeRateCache{client: client, prefix: prefix}
}</span>

// NewRedisExchangeRateCacheWithOptions creates a new RedisExchangeRateCache from redis.Options.
func NewRedisExchangeRateCacheWithOptions(opt *redis.Options, prefix string, logger *slog.Logger) *RedisExchangeRateCache <span class="cov0" title="0">{
        client := redis.NewClient(opt)
        return &amp;RedisExchangeRateCache{client: client, prefix: prefix, logger: logger}
}</span>

func (r *RedisExchangeRateCache) key(key string) string <span class="cov0" title="0">{
        return r.prefix + key
}</span>

func (r *RedisExchangeRateCache) Get(key string) (*domain.ExchangeRate, error) <span class="cov0" title="0">{
        ctx := context.Background()
        val, err := r.client.Get(ctx, r.key(key)).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                r.logger.Debug("Redis cache miss", "key", key)
                return nil, nil // cache miss
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache get error", "key", key, "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">var rate domain.ExchangeRate
        if err := json.Unmarshal([]byte(val), &amp;rate); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache unmarshal error", "key", key, "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">r.logger.Debug("Redis cache hit", "key", key, "rate", rate.Rate)
        return &amp;rate, nil</span>
}

func (r *RedisExchangeRateCache) Set(key string, rate *domain.ExchangeRate, ttl time.Duration) error <span class="cov0" title="0">{
        ctx := context.Background()
        data, err := json.Marshal(rate)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache marshal error", "key", key, "error", err)
                return err
        }</span>
        <span class="cov0" title="0">err = r.client.Set(ctx, r.key(key), data, ttl).Err()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache set error", "key", key, "error", err)
                return err
        }</span>
        <span class="cov0" title="0">r.logger.Debug("Redis cache set", "key", key, "rate", rate.Rate, "ttl", ttl)
        return nil</span>
}

func (r *RedisExchangeRateCache) Delete(key string) error <span class="cov0" title="0">{
        ctx := context.Background()
        err := r.client.Del(ctx, r.key(key)).Err()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache delete error", "key", key, "error", err)
                return err
        }</span>
        <span class="cov0" title="0">r.logger.Debug("Redis cache delete", "key", key)
        return nil</span>
}

func (r *RedisExchangeRateCache) GetLastUpdate(key string) (time.Time, error) <span class="cov0" title="0">{
        ctx := context.Background()
        val, err := r.client.Get(ctx, r.key("last_update:"+key)).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return time.Time{}, nil // not set
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache get last update error", "key", key, "error", err)
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">ts, err := time.Parse(time.RFC3339Nano, val)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache parse last update error", "key", key, "error", err)
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">return ts, nil</span>
}

func (r *RedisExchangeRateCache) SetLastUpdate(key string, t time.Time) error <span class="cov0" title="0">{
        ctx := context.Background()
        err := r.client.Set(ctx, r.key("last_update:"+key), t.Format(time.RFC3339Nano), 0).Err()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Redis cache set last update error", "key", key, "error", err)
                return err
        }</span>
        <span class="cov0" title="0">r.logger.Debug("Redis cache set last update", "key", key, "timestamp", t)
        return nil</span>
}
</pre>

		<pre class="file" id="file4" style="display: none">package infra

import (
        "errors"
        "time"

        "github.com/amirasaad/fintech/pkg/config"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

// Add appEnv as a parameter for dependency-injected environment
func NewDBConnection(cnf config.DBConfig, appEnv string) (*gorm.DB, error) <span class="cov0" title="0">{
        databaseUrl := cnf.Url
        if databaseUrl == "" </span><span class="cov0" title="0">{
                return nil, errors.New("DATABASE_URL is not set")
        }</span>

        <span class="cov0" title="0">var logMode logger.LogLevel
        if appEnv == "development" </span><span class="cov0" title="0">{
                logMode = logger.Info
        }</span> else<span class="cov0" title="0"> {
                logMode = logger.Silent
        }</span>

        <span class="cov0" title="0">connection, err := gorm.Open(postgres.Open(databaseUrl), &amp;gorm.Config{
                Logger:                 logger.Default.LogMode(logMode),
                SkipDefaultTransaction: true})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sqlDB, err := connection.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(25)
        sqlDB.SetMaxIdleConns(25)
        sqlDB.SetConnMaxLifetime(1 * time.Hour)

        return connection, nil</span>
}
</pre>

		<pre class="file" id="file5" style="display: none">package eventbus

import (
        "reflect"
        "sync"

        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/eventbus"
)

// MemoryEventBus is a simple in-memory implementation of the EventBus interface.
type MemoryEventBus struct {
        handlers map[string][]func(domain.Event)
        mu       sync.RWMutex
}

// NewMemoryEventBus creates a new in-memory event bus for event-driven communication.
func NewMemoryEventBus() *MemoryEventBus <span class="cov0" title="0">{
        return &amp;MemoryEventBus{
                handlers: make(map[string][]func(domain.Event)),
        }
}</span>

// Subscribe registers a handler for a specific event type.
func (b *MemoryEventBus) Subscribe(eventType string, handler func(domain.Event)) <span class="cov0" title="0">{
        b.mu.Lock()
        defer b.mu.Unlock()
        b.handlers[eventType] = append(b.handlers[eventType], handler)
}</span>

// Publish dispatches the event to all registered handlers for its type.
func (b *MemoryEventBus) Publish(event domain.Event) error <span class="cov0" title="0">{
        eventType := reflect.TypeOf(event).Name()
        b.mu.RLock()
        handlers := b.handlers[eventType]
        b.mu.RUnlock()
        for _, handler := range handlers </span><span class="cov0" title="0">{
                handler(event)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ensure MemoryEventBus implements the EventBus interface.
var _ eventbus.EventBus = (*MemoryEventBus)(nil)
</pre>

		<pre class="file" id="file6" style="display: none">package infra

import (
        "log/slog"

        infra_cache "github.com/amirasaad/fintech/infra/cache"
        infra_provider "github.com/amirasaad/fintech/infra/provider"
        "github.com/amirasaad/fintech/pkg/cache"
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/redis/go-redis/v9"
)

// NewExchangeRateSystem creates a complete exchange rate system with providers, cache, and converter
func NewExchangeRateSystem(logger *slog.Logger, cfg config.AppConfig) (domain.CurrencyConverter, error) <span class="cov0" title="0">{
        // Create cache
        var rateCache cache.ExchangeRateCache
        if cfg.Redis.URL != "" </span><span class="cov0" title="0">{
                opt, err := redis.ParseURL(cfg.Redis.URL)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Invalid Redis URL", "url", cfg.Redis.URL, "error", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">rateCache = infra_cache.NewRedisExchangeRateCacheWithOptions(opt, cfg.Exchange.CachePrefix, logger)
                logger.Info("Using Redis for exchange rate cache", "url", cfg.Redis.URL)</span>
        } else<span class="cov0" title="0"> {
                rateCache = infra_cache.NewMemoryCache()
                logger.Info("Using in-memory cache for exchange rates")
        }</span>

        // Create providers
        <span class="cov0" title="0">var exchangeRateProviders []provider.ExchangeRateProvider

        // Use USD as the base currency for now (configurable in future)
        baseCurrency := "USD"
        // TODO: Make base currency configurable via config.Exchange.BaseCurrency

        // Add ExchangeRate API provider if API key is configured
        var exchangeRateProvider *infra_provider.ExchangeRateAPIProvider
        if cfg.Exchange.ApiKey != "" </span><span class="cov0" title="0">{
                exchangeRateProvider = infra_provider.NewExchangeRateAPIProvider(cfg.Exchange, logger)
                exchangeRateProviders = append(exchangeRateProviders, exchangeRateProvider)
                logger.Info("ExchangeRate API provider configured", "apiKey", maskAPIKey(cfg.Exchange.ApiKey))
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("No ExchangeRate API key configured, using fallback only")
        }</span>

        // Fetch and cache rates ONCE at startup for POC
        <span class="cov0" title="0">if exchangeRateProvider != nil </span><span class="cov0" title="0">{
                err := exchangeRateProvider.FetchAndCacheRates(baseCurrency, rateCache, cfg.Exchange.CacheTTL)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to fetch and cache exchange rates at startup", "error", err)
                }</span>
        }

        // Create exchange rate service
        <span class="cov0" title="0">exchangeRateService := infra_provider.NewExchangeRateService(exchangeRateProviders, rateCache, logger, &amp;cfg.Exchange)

        // Create fallback converter
        var fallback domain.CurrencyConverter
        if cfg.Exchange.EnableFallback </span><span class="cov0" title="0">{
                fallback = infra_provider.NewStubCurrencyConverter()
                logger.Info("Fallback currency converter enabled")
        }</span>

        // Create real currency converter
        <span class="cov0" title="0">converter := infra_provider.NewRealCurrencyConverter(exchangeRateService, fallback, logger)

        logger.Info("Exchange rate system initialized",
                "providers", len(exchangeRateProviders),
                "fallbackEnabled", cfg.Exchange.EnableFallback,
                "cacheTTL", cfg.Exchange.CacheTTL)

        return converter, nil</span>
}

// maskAPIKey returns a masked version of the API key for logging
func maskAPIKey(apiKey string) string <span class="cov0" title="0">{
        if len(apiKey) &lt;= 8 </span><span class="cov0" title="0">{
                return "***"
        }</span>
        <span class="cov0" title="0">return apiKey[:4] + "..." + apiKey[len(apiKey)-4:]</span>
}
</pre>

		<pre class="file" id="file7" style="display: none">package provider

import (
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain"
)

// RealCurrencyConverter implements the CurrencyConverter interface using real exchange rates.
type RealCurrencyConverter struct {
        exchangeRateService *ExchangeRateService
        logger              *slog.Logger
        fallback            domain.CurrencyConverter
}

// NewRealCurrencyConverter creates a new real currency converter with fallback support.
func NewRealCurrencyConverter(exchangeRateService *ExchangeRateService, fallback domain.CurrencyConverter, logger *slog.Logger) *RealCurrencyConverter <span class="cov0" title="0">{
        return &amp;RealCurrencyConverter{
                exchangeRateService: exchangeRateService,
                logger:              logger,
                fallback:            fallback,
        }
}</span>

// Convert converts an amount from one currency to another using real exchange rates.
func (c *RealCurrencyConverter) Convert(amount float64, from, to string) (*domain.ConversionInfo, error) <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return &amp;domain.ConversionInfo{
                        OriginalAmount:    amount,
                        OriginalCurrency:  from,
                        ConvertedAmount:   amount,
                        ConvertedCurrency: to,
                        ConversionRate:    1.0,
                }, nil
        }</span>

        // Try to get real exchange rate
        <span class="cov0" title="0">rate, err := c.exchangeRateService.GetRate(from, to)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to get real exchange rate, falling back", "from", from, "to", to, "error", err)

                // Use fallback converter
                if c.fallback != nil </span><span class="cov0" title="0">{
                        return c.fallback.Convert(amount, from, to)
                }</span>

                <span class="cov0" title="0">return nil, domain.ErrExchangeRateUnavailable</span>
        }

        <span class="cov0" title="0">convertedAmount := amount * rate.Rate

        c.logger.Info("Currency conversion completed",
                "from", from, "to", to, "amount", amount,
                "converted", convertedAmount, "rate", rate.Rate, "source", rate.Source)

        return &amp;domain.ConversionInfo{
                OriginalAmount:    amount,
                OriginalCurrency:  from,
                ConvertedAmount:   convertedAmount,
                ConvertedCurrency: to,
                ConversionRate:    rate.Rate,
        }, nil</span>
}

// GetRate returns the current exchange rate between two currencies.
func (c *RealCurrencyConverter) GetRate(from, to string) (float64, error) <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return 1.0, nil
        }</span>

        <span class="cov0" title="0">rate, err := c.exchangeRateService.GetRate(from, to)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to get real exchange rate, falling back", "from", from, "to", to, "error", err)

                // Use fallback converter
                if c.fallback != nil </span><span class="cov0" title="0">{
                        return c.fallback.GetRate(from, to)
                }</span>

                <span class="cov0" title="0">return 0, domain.ErrExchangeRateUnavailable</span>
        }

        <span class="cov0" title="0">return rate.Rate, nil</span>
}

// IsSupported checks if a currency pair is supported by checking if we can get a rate.
func (c *RealCurrencyConverter) IsSupported(from, to string) bool <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return true
        }</span>

        // Try to get a rate to check if supported
        <span class="cov0" title="0">_, err := c.exchangeRateService.GetRate(from, to)
        if err == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check fallback
        <span class="cov0" title="0">if c.fallback != nil </span><span class="cov0" title="0">{
                return c.fallback.IsSupported(from, to)
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>

		<pre class="file" id="file8" style="display: none">package provider

import (
        "fmt"
        "log/slog"
        "math"
        "time"

        infra_cache "github.com/amirasaad/fintech/infra/cache"
        "github.com/amirasaad/fintech/pkg/cache"
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/provider"
)

// ExchangeRateService provides real-time exchange rates with caching and fallback providers.
type ExchangeRateService struct {
        providers []provider.ExchangeRateProvider
        cache     cache.ExchangeRateCache
        logger    *slog.Logger
        cfg       *config.ExchangeRateConfig
        // mu        sync.RWMutex
}

// NewExchangeRateService creates a new exchange rate service with the given providers, cache, and exchange rate config.
func NewExchangeRateService(providers []provider.ExchangeRateProvider, cache cache.ExchangeRateCache, logger *slog.Logger, cfg *config.ExchangeRateConfig) *ExchangeRateService <span class="cov8" title="1">{
        return &amp;ExchangeRateService{
                providers: providers,
                cache:     cache,
                logger:    logger,
                cfg:       cfg,
        }
}</span>

// GetRate retrieves an exchange rate, trying cache first, then providers in order.
func (s *ExchangeRateService) GetRate(from, to string) (*domain.ExchangeRate, error) <span class="cov8" title="1">{
        s.logger.Info("[DIAG] Cache type", "type", fmt.Sprintf("%T", s.cache))
        if from == to </span><span class="cov8" title="1">{
                return &amp;domain.ExchangeRate{
                        FromCurrency: from,
                        ToCurrency:   to,
                        Rate:         1.0,
                        LastUpdated:  time.Now(),
                        Source:       "internal",
                        ExpiresAt:    time.Now().Add(24 * time.Hour),
                }, nil
        }</span>

        <span class="cov8" title="1">cacheKey := fmt.Sprintf("%s:%s", from, to)

        // Check last update timestamp
        if redisCache, ok := s.cache.(*infra_cache.RedisExchangeRateCache); ok </span><span class="cov0" title="0">{
                s.logger.Info("[DIAG] Checking last update timestamp in Redis", "key", cacheKey)
                lastUpdate, err := redisCache.GetLastUpdate(cacheKey)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("[DIAG] Failed to get last update from Redis", "key", cacheKey, "error", err)
                }</span>
                <span class="cov0" title="0">if err == nil &amp;&amp; !lastUpdate.IsZero() </span><span class="cov0" title="0">{
                        s.logger.Info("[DIAG] Last update timestamp found", "key", cacheKey, "lastUpdate", lastUpdate, "age", time.Since(lastUpdate), "ttl", s.cfg.CacheTTL)
                }</span>
                <span class="cov0" title="0">if err == nil &amp;&amp; !lastUpdate.IsZero() &amp;&amp; time.Since(lastUpdate) &lt; s.cfg.CacheTTL </span><span class="cov0" title="0">{
                        // Try cache first
                        if cached, err := s.cache.Get(cacheKey); err == nil &amp;&amp; cached != nil </span><span class="cov0" title="0">{
                                if time.Now().Before(cached.ExpiresAt) </span><span class="cov0" title="0">{
                                        s.logger.Info("[DIAG] Exchange rate retrieved from cache (last update valid)", "from", from, "to", to, "rate", cached.Rate)
                                        return cached, nil
                                }</span>
                        }
                }
        }

        // Try reverse pair in cache and invert
        <span class="cov8" title="1">reverseKey := fmt.Sprintf("%s:%s", to, from)
        if cached, err := s.cache.Get(reverseKey); err == nil &amp;&amp; cached != nil </span><span class="cov0" title="0">{
                if time.Now().Before(cached.ExpiresAt) &amp;&amp; cached.Rate != 0 </span><span class="cov0" title="0">{
                        s.logger.Debug("Exchange rate retrieved from cache (reversed)", "from", to, "to", from, "rate", cached.Rate)
                        return &amp;domain.ExchangeRate{
                                FromCurrency: from,
                                ToCurrency:   to,
                                Rate:         1 / cached.Rate,
                                LastUpdated:  cached.LastUpdated,
                                Source:       cached.Source + " (reversed)",
                                ExpiresAt:    cached.ExpiresAt,
                        }, nil
                }</span>
        }

        // Try providers in order
        <span class="cov8" title="1">for _, provider := range s.providers </span><span class="cov8" title="1">{
                if !provider.IsHealthy() </span><span class="cov8" title="1">{
                        s.logger.Warn("Provider not healthy, skipping", "provider", provider.Name())
                        continue</span>
                }

                <span class="cov8" title="1">rate, err := provider.GetRate(from, to)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Warn("Failed to get rate from provider", "provider", provider.Name(), "error", err)
                        continue</span>
                }

                // Validate rate
                <span class="cov8" title="1">if rate.Rate &lt;= 0 || math.IsNaN(rate.Rate) || math.IsInf(rate.Rate, 0) </span><span class="cov8" title="1">{
                        s.logger.Warn("Invalid rate received from provider", "provider", provider.Name(), "rate", rate.Rate)
                        continue</span>
                }

                // Cache the rate
                <span class="cov8" title="1">ttl := time.Until(rate.ExpiresAt)
                if ttl &gt; 0 </span><span class="cov8" title="1">{
                        _ = s.cache.Set(cacheKey, rate, ttl)
                        if redisCache, ok := s.cache.(*infra_cache.RedisExchangeRateCache); ok </span><span class="cov0" title="0">{
                                _ = redisCache.SetLastUpdate(cacheKey, time.Now())
                        }</span>
                }

                <span class="cov8" title="1">s.logger.Info("Exchange rate retrieved from provider", "provider", provider.Name(), "from", from, "to", to, "rate", rate.Rate)
                return rate, nil</span>
        }

        <span class="cov8" title="1">return nil, domain.ErrExchangeRateUnavailable</span>
}

// GetRates retrieves multiple exchange rates efficiently.
func (s *ExchangeRateService) GetRates(from string, to []string) (map[string]*domain.ExchangeRate, error) <span class="cov8" title="1">{
        results := make(map[string]*domain.ExchangeRate)
        var missing []string

        // Try cache first for each currency
        for _, currency := range to </span><span class="cov8" title="1">{
                cacheKey := fmt.Sprintf("%s:%s", from, currency)
                if cached, err := s.cache.Get(cacheKey); err == nil &amp;&amp; cached != nil </span><span class="cov0" title="0">{
                        if time.Now().Before(cached.ExpiresAt) </span><span class="cov0" title="0">{
                                results[currency] = cached
                                continue</span>
                        }
                        <span class="cov0" title="0">_ = s.cache.Delete(cacheKey)</span>
                }
                <span class="cov8" title="1">missing = append(missing, currency)</span>
        }

        // If we have missing rates, try providers
        <span class="cov8" title="1">if len(missing) &gt; 0 </span><span class="cov8" title="1">{
                for _, provider := range s.providers </span><span class="cov8" title="1">{
                        if !provider.IsHealthy() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">rates, err := provider.GetRates(from, missing)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to get rates from provider", "provider", provider.Name(), "error", err)
                                continue</span>
                        }

                        // Cache and add valid rates
                        <span class="cov8" title="1">for currency, rate := range rates </span><span class="cov8" title="1">{
                                if rate.Rate &gt; 0 &amp;&amp; !math.IsNaN(rate.Rate) &amp;&amp; !math.IsInf(rate.Rate, 0) </span><span class="cov8" title="1">{
                                        results[currency] = rate
                                        cacheKey := fmt.Sprintf("%s:%s", from, currency)
                                        ttl := time.Until(rate.ExpiresAt)
                                        if ttl &gt; 0 </span><span class="cov8" title="1">{
                                                _ = s.cache.Set(cacheKey, rate, ttl)
                                        }</span>
                                }
                        }

                        // Update missing list
                        <span class="cov8" title="1">missing = missing[:0]
                        for _, currency := range to </span><span class="cov8" title="1">{
                                if _, exists := results[currency]; !exists </span><span class="cov0" title="0">{
                                        missing = append(missing, currency)
                                }</span>
                        }

                        <span class="cov8" title="1">if len(missing) == 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, domain.ErrExchangeRateUnavailable
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}
</pre>

		<pre class="file" id="file9" style="display: none">package provider

import (
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "time"

        "github.com/amirasaad/fintech/pkg/cache"
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/provider"
)

// ExchangeRateAPIProvider implements the ExchangeRateProvider interface for exchangerate-api.com
// Updated to use v6 endpoint and config
type ExchangeRateAPIProvider struct {
        apiKey     string
        baseURL    string
        httpClient *http.Client
        logger     *slog.Logger
        timeout    time.Duration
}

// ExchangeRateAPIResponseV6 represents the v6 response from the ExchangeRate API
// See: https://www.exchangerate-api.com/docs/standard-requests
// Example: { "result": "success", "documentation": "...", "terms_of_use": "...", "time_last_update_unix": 1585267200, ... }
type ExchangeRateAPIResponseV6 struct {
        Result             string             `json:"result"`
        Documentation      string             `json:"documentation"`
        TermsOfUse         string             `json:"terms_of_use"`
        TimeLastUpdateUnix int64              `json:"time_last_update_unix"`
        TimeLastUpdateUTC  string             `json:"time_last_update_utc"`
        TimeNextUpdateUnix int64              `json:"time_next_update_unix"`
        TimeNextUpdateUTC  string             `json:"time_next_update_utc"`
        BaseCode           string             `json:"base_code"`
        ConversionRates    map[string]float64 `json:"conversion_rates"`
        // Error fields (if any)
        ErrorType string `json:"error-type,omitempty"`
}

// NewExchangeRateAPIProvider creates a new ExchangeRate API provider using config
func NewExchangeRateAPIProvider(cfg config.ExchangeRateConfig, logger *slog.Logger) *ExchangeRateAPIProvider <span class="cov0" title="0">{
        return &amp;ExchangeRateAPIProvider{
                apiKey:  cfg.ApiKey,
                baseURL: cfg.ApiUrl, // Should be like https://v6.exchangerate-api.com/v6
                httpClient: &amp;http.Client{
                        Timeout: cfg.HTTPTimeout,
                },
                logger:  logger,
                timeout: cfg.HTTPTimeout,
        }
}</span>

// FetchAndCacheRates fetches all rates for the base currency and caches them
func (p *ExchangeRateAPIProvider) FetchAndCacheRates(base string, cache cache.ExchangeRateCache, ttl time.Duration) error <span class="cov0" title="0">{
        // Check last update before fetching
        lastUpdate, err := cache.GetLastUpdate(base)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Warn("Could not check last update for exchange rates", "error", err)
        }</span>
        <span class="cov0" title="0">if !lastUpdate.IsZero() &amp;&amp; time.Since(lastUpdate) &lt; ttl </span><span class="cov0" title="0">{
                p.logger.Info("Exchange rates cache is still valid, skipping fetch", "base", base, "lastUpdate", lastUpdate)
                return nil
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s/%s/latest/%s", p.baseURL, p.apiKey, base)
        p.logger.Info("Fetching exchange rates from", "baseUrl", p.baseURL)

        resp, err := p.httpClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to fetch rates: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := resp.Body.Close(); cerr != nil </span><span class="cov0" title="0">{
                        p.logger.Warn("Failed to close response body", "error", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("API returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResp ExchangeRateAPIResponseV6
        if err := json.NewDecoder(resp.Body).Decode(&amp;apiResp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if apiResp.Result != "success" </span><span class="cov0" title="0">{
                return fmt.Errorf("API returned result=%s", apiResp.Result)
        }</span>

        // Cache each rate as base:to
        <span class="cov0" title="0">for to, rate := range apiResp.ConversionRates </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%s:%s", base, to)
                rateObj := &amp;domain.ExchangeRate{
                        FromCurrency: base,
                        ToCurrency:   to,
                        Rate:         rate,
                        LastUpdated:  time.Now(),
                        Source:       "exchangerate-api",
                        ExpiresAt:    time.Now().Add(ttl),
                }
                if err := cache.Set(key, rateObj, ttl); err != nil </span><span class="cov0" title="0">{
                        p.logger.Warn("Failed to cache exchange rate", "key", key, "error", err)
                }</span>
        }
        // Set last update for this base
        <span class="cov0" title="0">_ = cache.SetLastUpdate(base, time.Now())
        p.logger.Info("Exchange rates cached successfully", "base", base, "count", len(apiResp.ConversionRates))
        return nil</span>
}

// GetRate fetches the current exchange rate for a currency pair
func (p *ExchangeRateAPIProvider) GetRate(from, to string) (*domain.ExchangeRate, error) <span class="cov0" title="0">{
        // Update GetRate to use the v6 endpoint and response if needed, or rely on cache for POC
        // For now, we'll assume a simple call to the base URL with the API key
        url := fmt.Sprintf("%s/%s", p.baseURL, from)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">if p.apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+p.apiKey)
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := resp.Body.Close(); cerr != nil </span><span class="cov0" title="0">{
                        p.logger.Warn("Failed to close response body", "error", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResp ExchangeRateAPIResponseV6
        if err = json.NewDecoder(resp.Body).Decode(&amp;apiResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if apiResp.Result != "success" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned result=%s", apiResp.Result)
        }</span>

        <span class="cov0" title="0">rate, exists := apiResp.ConversionRates[to]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("currency %s not found in response", to)
        }</span>

        // Parse the date from the API response
        <span class="cov0" title="0">date, err := time.Parse("2006-01-02", "2006-01-02") // No date field in v6 response
        if err != nil </span><span class="cov0" title="0">{
                date = time.Now()
        }</span>

        <span class="cov0" title="0">return &amp;domain.ExchangeRate{
                FromCurrency: from,
                ToCurrency:   to,
                Rate:         rate,
                LastUpdated:  time.Now(),
                Source:       "exchangerate-api",
                ExpiresAt:    date.Add(24 * time.Hour), // Rates typically valid for 24 hours
        }, nil</span>
}

// GetRates fetches multiple exchange rates in a single request
func (p *ExchangeRateAPIProvider) GetRates(from string, to []string) (map[string]*domain.ExchangeRate, error) <span class="cov0" title="0">{
        // For this provider, we need to make a single request and extract the rates we need
        // We'll make a direct request to get all rates for the base currency

        // Since this provider returns all rates in one call, we need to make a full request
        url := fmt.Sprintf("%s/%s", p.baseURL, from)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">if p.apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+p.apiKey)
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := resp.Body.Close(); cerr != nil </span><span class="cov0" title="0">{
                        p.logger.Warn("Failed to close response body", "error", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResp ExchangeRateAPIResponseV6
        if err = json.NewDecoder(resp.Body).Decode(&amp;apiResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if apiResp.Result != "success" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned result=%s", apiResp.Result)
        }</span>

        // Parse the date from the API response
        <span class="cov0" title="0">date, err := time.Parse("2006-01-02", "2006-01-02") // No date field in v6 response
        if err != nil </span><span class="cov0" title="0">{
                date = time.Now()
        }</span>

        <span class="cov0" title="0">results := make(map[string]*domain.ExchangeRate)
        for _, currency := range to </span><span class="cov0" title="0">{
                if rate, exists := apiResp.ConversionRates[currency]; exists </span><span class="cov0" title="0">{
                        results[currency] = &amp;domain.ExchangeRate{
                                FromCurrency: from,
                                ToCurrency:   currency,
                                Rate:         rate,
                                LastUpdated:  time.Now(),
                                Source:       "exchangerate-api",
                                ExpiresAt:    date.Add(24 * time.Hour),
                        }
                }</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// Name returns the provider's name
func (p *ExchangeRateAPIProvider) Name() string <span class="cov0" title="0">{
        return "exchangerate-api"
}</span>

// IsHealthy checks if the provider is currently available
func (p *ExchangeRateAPIProvider) IsHealthy() bool <span class="cov0" title="0">{
        // Make a simple health check request
        url := fmt.Sprintf("%s/USD", p.baseURL)
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if p.apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+p.apiKey)
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := resp.Body.Close(); cerr != nil </span><span class="cov0" title="0">{
                        p.logger.Warn("Failed to close response body", "error", cerr)
                }</span>
        }()

        <span class="cov0" title="0">return resp.StatusCode == http.StatusOK</span>
}

// Ensure ExchangeRateAPIProvider implements provider.ExchangeRateProvider
var _ provider.ExchangeRateProvider = (*ExchangeRateAPIProvider)(nil)
</pre>

		<pre class="file" id="file10" style="display: none">package provider

import (
        "context"
        "sync"
        "time"

        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/google/uuid"
)

type mockPayment struct {
        status provider.PaymentStatus
}

// MockPaymentProvider simulates a payment provider for tests and local development.
//
// Usage:
// - InitiateDeposit/InitiateWithdraw simulate async payment completion after a short delay.
// - GetPaymentStatus can be polled until PaymentCompleted is returned.
// - This is NOT for production use. Real payment providers use webhooks or callbacks.
//
// In tests, the service will poll GetPaymentStatus until completion, simulating a real-world async flow.
//
// See pkg/service/account/account.go for example usage.
//
// For production, use a real provider and event-driven confirmation.
type MockPaymentProvider struct {
        mu       sync.Mutex
        payments map[string]*mockPayment
}

// NewMockPaymentProvider creates a new instance of MockPaymentProvider.
func NewMockPaymentProvider() *MockPaymentProvider <span class="cov0" title="0">{
        return &amp;MockPaymentProvider{
                payments: make(map[string]*mockPayment),
        }
}</span>

// InitiatePayment simulates initiating a deposit payment.
func (m *MockPaymentProvider) InitiatePayment(ctx context.Context, userID, accountID uuid.UUID, amount float64, currency string) (string, error) <span class="cov0" title="0">{
        paymentID := uuid.New().String()
        m.mu.Lock()
        m.payments[paymentID] = &amp;mockPayment{status: provider.PaymentPending}
        m.mu.Unlock()
        // Simulate async completion
        go func() </span><span class="cov0" title="0">{
                time.Sleep(2 * time.Second)
                m.mu.Lock()
                m.payments[paymentID].status = provider.PaymentCompleted
                m.mu.Unlock()
        }</span>()
        <span class="cov0" title="0">return paymentID, nil</span>
}

// GetPaymentStatus returns the current status of a payment.
func (m *MockPaymentProvider) GetPaymentStatus(ctx context.Context, paymentID string) (provider.PaymentStatus, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        if p, ok := m.payments[paymentID]; ok </span><span class="cov0" title="0">{
                return p.status, nil
        }</span>
        <span class="cov0" title="0">return provider.PaymentFailed, nil</span>
}
</pre>

		<pre class="file" id="file11" style="display: none">package provider

import (
        "github.com/amirasaad/fintech/pkg/domain"
)

// StubCurrencyConverter is a simple implementation that returns the same amount (1:1 conversion).
type StubCurrencyConverter struct {
        rates map[string]map[string]float64
}

// NewStubCurrencyConverter creates a new StubCurrencyConverter with an empty rates map.
func NewStubCurrencyConverter() *StubCurrencyConverter <span class="cov0" title="0">{
        return &amp;StubCurrencyConverter{rates: map[string]map[string]float64{
                "USD": {
                        "EUR": 0.84,
                        "GBP": 0.76,
                        "JPY": 0.0027,
                },
                "EUR": {
                        "USD": 1.19,
                        "GBP": 0.90,
                        "JPY": 0.0024,
                },
                "GBP": {
                        "USD": 1.32,
                        "EUR": 1.11,
                        "JPY": 0.0024,
                },
                "JPY": {
                        "USD": 0.0027,
                        "EUR": 0.0024,
                        "GBP": 0.0024,
                },
        }}
}</span>

func (s *StubCurrencyConverter) Convert(amount float64, from, to string) (*domain.ConversionInfo, error) <span class="cov0" title="0">{
        rate, exists := s.rates[from][to]
        if !exists </span><span class="cov0" title="0">{
                return nil, domain.ErrUnsupportedCurrencyPair
        }</span>
        <span class="cov0" title="0">return &amp;domain.ConversionInfo{
                OriginalAmount:    amount,
                OriginalCurrency:  from,
                ConvertedAmount:   amount * rate,
                ConvertedCurrency: to,
                ConversionRate:    rate,
        }, nil</span>
}

func (s *StubCurrencyConverter) GetRate(from, to string) (float64, error) <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return 1.0, nil
        }</span>
        <span class="cov0" title="0">rate, exists := s.rates[from][to]
        if !exists </span><span class="cov0" title="0">{
                return 0, domain.ErrUnsupportedCurrencyPair
        }</span>
        <span class="cov0" title="0">return rate, nil</span>
}

func (s *StubCurrencyConverter) IsSupported(from, to string) bool <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">_, exists := s.rates[from][to]
        return exists</span>
}
</pre>

		<pre class="file" id="file12" style="display: none">package repository

import (
        "errors"
        "time"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/common"
        "github.com/amirasaad/fintech/pkg/domain/money"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/amirasaad/fintech/pkg/utils"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type accountRepository struct {
        db *gorm.DB
}

// NewAccountRepository creates a new account repository instance.
func NewAccountRepository(db *gorm.DB) repository.AccountRepository <span class="cov8" title="1">{
        return &amp;accountRepository{db: db}
}</span>

func (r *accountRepository) Get(id uuid.UUID) (*account.Account, error) <span class="cov8" title="1">{
        var a Account
        result := r.db.First(&amp;a, id)
        if result.Error != nil </span><span class="cov8" title="1">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, account.ErrAccountNotFound
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }
        <span class="cov8" title="1">accBalance := money.NewFromData(a.Balance, a.Currency)
        return account.NewAccountFromData(a.ID, a.UserID, accBalance, a.CreatedAt, a.UpdatedAt), nil</span>
}

func (r *accountRepository) Create(acc *account.Account) error <span class="cov0" title="0">{
        a := Account{
                Model: gorm.Model{
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
                ID:       acc.ID,
                UserID:   acc.UserID,
                Balance:  acc.Balance.Amount(),
                Currency: string(acc.Balance.Currency()),
        }
        result := r.db.Create(&amp;a)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *accountRepository) Update(a *account.Account) error <span class="cov0" title="0">{
        // Use infra.Account for DB operations
        dbModel := Account{
                Model: gorm.Model{
                        CreatedAt: a.CreatedAt,
                        DeletedAt: gorm.DeletedAt{},
                        UpdatedAt: time.Now().UTC(),
                },
                ID:       a.ID,
                UserID:   a.UserID,
                Balance:  a.Balance.Amount(),
                Currency: string(a.Balance.Currency()),
        }
        result := r.db.Save(&amp;dbModel)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *accountRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        result := r.db.Delete(&amp;Account{}, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type transactionRepository struct {
        db *gorm.DB
}

// NewTransactionRepository creates a new transaction repository instance.
func NewTransactionRepository(db *gorm.DB) repository.TransactionRepository <span class="cov8" title="1">{
        return &amp;transactionRepository{db: db}
}</span>

func (r *transactionRepository) Create(transaction *account.Transaction, convInfo *common.ConversionInfo, externalTargetMasked string) error <span class="cov8" title="1">{
        // Convert domain transaction to GORM model
        dbTransaction := Transaction{
                Model: gorm.Model{
                        CreatedAt: transaction.CreatedAt,
                        UpdatedAt: transaction.CreatedAt,
                },
                ID:                   transaction.ID,
                AccountID:            transaction.AccountID,
                UserID:               transaction.UserID,
                PaymentID:            transaction.PaymentID,
                Amount:               transaction.Amount.Amount(),
                Currency:             string(transaction.Amount.Currency()),
                Balance:              transaction.Balance.Amount(),
                MoneySource:          string(transaction.MoneySource),
                ExternalTargetMasked: externalTargetMasked,
        }

        // Only set conversion fields if conversion info is provided
        if convInfo != nil </span><span class="cov8" title="1">{
                dbTransaction.OriginalAmount = &amp;convInfo.OriginalAmount
                dbTransaction.OriginalCurrency = &amp;convInfo.OriginalCurrency
                dbTransaction.ConversionRate = &amp;convInfo.ConversionRate
        }</span>

        <span class="cov8" title="1">result := r.db.Create(&amp;dbTransaction)
        if result.Error != nil </span><span class="cov8" title="1">{
                return result.Error
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *transactionRepository) Get(
        id uuid.UUID,
) (
        *account.Transaction,
        error,
) <span class="cov0" title="0">{
        var t Transaction
        result := r.db.First(&amp;t, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, account.ErrAccountNotFound
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }
        <span class="cov0" title="0">amount := money.NewFromData(t.Balance, t.Currency)
        balance := money.NewFromData(t.Amount, t.Currency)
        return account.NewTransactionFromData(
                t.ID,
                t.UserID, t.AccountID, amount, balance, account.MoneySource(t.MoneySource), t.CreatedAt), nil</span>
}

func (r *transactionRepository) List(
        userID, accountID uuid.UUID,
) ([]*account.Transaction, error) <span class="cov0" title="0">{
        var dbTransactions []*Transaction
        result := r.db.Where("account_id = ? and user_id = ?", accountID, userID).Order("created_at desc").Limit(100).Find(&amp;dbTransactions)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">tx := make([]*account.Transaction, 0, len(dbTransactions))
        for _, t := range dbTransactions </span><span class="cov0" title="0">{
                amount := money.NewFromData(t.Balance, t.Currency)
                balance := money.NewFromData(t.Amount, t.Currency)
                tx = append(tx, account.NewTransactionFromData(t.ID, t.UserID, t.AccountID, amount, balance, account.MoneySource(t.MoneySource), t.CreatedAt))
        }</span>
        <span class="cov0" title="0">return tx, nil</span>
}

func (r *transactionRepository) GetByPaymentID(paymentID string) (*account.Transaction, error) <span class="cov0" title="0">{
        var m Transaction
        if err := r.db.Where("payment_id = ?", paymentID).First(&amp;m).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return account.NewTransactionFromData(
                        m.ID, m.UserID, m.AccountID,
                        money.NewFromData(m.Balance, m.Currency),
                        money.NewFromData(m.Amount, m.Currency),
                        account.MoneySource(m.MoneySource),
                        m.CreatedAt),
                nil</span>
}

func (r *transactionRepository) Update(tx *account.Transaction) error <span class="cov0" title="0">{
        dbTx := Transaction{
                ID:          tx.ID,
                AccountID:   tx.AccountID,
                UserID:      tx.UserID,
                Amount:      tx.Amount.Amount(),
                Currency:    string(tx.Amount.Currency()),
                Balance:     tx.Balance.Amount(),
                Status:      string(tx.Status),
                PaymentID:   tx.PaymentID,
                MoneySource: string(tx.MoneySource),
                // Add other fields as needed (conversion, external target, etc.)
        }
        result := r.db.Model(&amp;Transaction{}).Where("id = ?", tx.ID).Updates(&amp;dbTx)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type userRepository struct {
        db *gorm.DB
}

// Valid implements repository.UserRepository.
func (u *userRepository) Valid(id uuid.UUID, password string) bool <span class="cov0" title="0">{
        var usr user.User
        result := u.db.Where("id = ?", id).First(&amp;usr)
        if result.Error != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // Compare the provided password with the stored hash
        <span class="cov0" title="0">return utils.CheckPasswordHash(password, usr.Password)</span>
}

// Create implements repository.UserRepository.
func (u *userRepository) Create(user *user.User) error <span class="cov8" title="1">{
        result := u.db.Create(user)
        if result.Error != nil </span><span class="cov8" title="1">{
                return result.Error
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Delete implements repository.UserRepository.
func (u *userRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        result := u.db.Delete(&amp;user.User{}, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Get implements repository.UserRepository.
func (u *userRepository) Get(id uuid.UUID) (*user.User, error) <span class="cov0" title="0">{
        var usr user.User
        result := u.db.First(&amp;usr, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, user.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }
        <span class="cov0" title="0">return &amp;usr, nil</span>
}

// GetByEmail implements repository.UserRepository.
func (u *userRepository) GetByEmail(email string) (*user.User, error) <span class="cov0" title="0">{
        var usr user.User
        result := u.db.Where("email = ?", email).First(&amp;usr)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, user.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }
        <span class="cov0" title="0">return &amp;usr, nil</span>
}

// GetByUsername implements repository.UserRepository.
func (u *userRepository) GetByUsername(username string) (*user.User, error) <span class="cov0" title="0">{
        var usr user.User
        result := u.db.Where("username = ?", username).First(&amp;usr)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, user.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }
        <span class="cov0" title="0">return &amp;usr, nil</span>
}

// Update implements repository.UserRepository.
func (u *userRepository) Update(user *user.User) error <span class="cov0" title="0">{
        result := u.db.Save(user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NewUserRepository creates a new user repository instance.
func NewUserRepository(db *gorm.DB) repository.UserRepository <span class="cov8" title="1">{
        return &amp;userRepository{db: db}
}</span>
</pre>

		<pre class="file" id="file13" style="display: none">package repository

import (
        "context"
        "fmt"

        "github.com/amirasaad/fintech/pkg/repository"
        "gorm.io/gorm"
)

// UoW provides transaction boundary and repository access in one abstraction.
//
// Why is GetRepository part of UoW?
// - Ensures all repositories use the same DB session/transaction for true atomicity.
// - Keeps service code clean and focused on business logic.
// - Centralizes repository wiring and registry for maintainability.
// - Prevents accidental use of the wrong DB session (which would break transactionality).
// - Is idiomatic for Go UoW patterns and easy to mock in tests.
type UoW struct {
        db *gorm.DB
        tx *gorm.DB

        // Direct repository instances for type-safe access
        accountRepo     repository.AccountRepository
        transactionRepo repository.TransactionRepository
        userRepo        repository.UserRepository
}

// NewUoW creates a new UoW for the given *gorm.DB.
func NewUoW(db *gorm.DB) *UoW <span class="cov8" title="1">{
        return &amp;UoW{
                db: db,
        }
}</span>

// Do runs the given function in a transaction boundary, providing a UoW with repository access.
func (u *UoW) Do(ctx context.Context, fn func(uow repository.UnitOfWork) error) error <span class="cov8" title="1">{
        return u.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                txnUow := &amp;UoW{
                        db:              u.db,
                        tx:              tx,
                        accountRepo:     NewAccountRepository(tx),
                        transactionRepo: NewTransactionRepository(tx),
                        userRepo:        NewUserRepository(tx),
                }
                return fn(txnUow)
        }</span>)
}

// GetRepository provides generic, type-safe access to repositories using the transaction session.
// This method is maintained for backward compatibility but is deprecated in favor of type-safe methods.
//
// This method is part of UoW to guarantee that all repository operations within a transaction
// use the same DB session, ensuring atomicity and consistency. It also centralizes repository
// construction and makes testing and extension easier.
func (u *UoW) GetRepository(repoType interface{}) (any, error) <span class="cov8" title="1">{
        // Use transaction DB if available, otherwise use main DB
        dbToUse := u.tx
        if dbToUse == nil </span><span class="cov0" title="0">{
                dbToUse = u.db
        }</span>

        // Create repositories on-demand for backward compatibility
        <span class="cov8" title="1">switch repoType </span>{
        case (*repository.AccountRepository)(nil):<span class="cov8" title="1">
                return NewAccountRepository(dbToUse), nil</span>
        case (*repository.TransactionRepository)(nil):<span class="cov8" title="1">
                return NewTransactionRepository(dbToUse), nil</span>
        case (*repository.UserRepository)(nil):<span class="cov8" title="1">
                return NewUserRepository(dbToUse), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported repository type: %T", repoType)</span>
        }
}

// Type-safe repository access methods (preferred approach)

// AccountRepository returns the account repository bound to the current transaction
func (u *UoW) AccountRepository() (repository.AccountRepository, error) <span class="cov8" title="1">{
        if u.accountRepo != nil </span><span class="cov8" title="1">{
                return u.accountRepo, nil
        }</span>

        // Create repository on-demand if not already created
        <span class="cov8" title="1">dbToUse := u.tx
        if dbToUse == nil </span><span class="cov8" title="1">{
                dbToUse = u.db
        }</span>

        <span class="cov8" title="1">u.accountRepo = NewAccountRepository(dbToUse)
        return u.accountRepo, nil</span>
}

// TransactionRepository returns the transaction repository bound to the current transaction
func (u *UoW) TransactionRepository() (repository.TransactionRepository, error) <span class="cov8" title="1">{
        if u.transactionRepo != nil </span><span class="cov8" title="1">{
                return u.transactionRepo, nil
        }</span>

        // Create repository on-demand if not already created
        <span class="cov8" title="1">dbToUse := u.tx
        if dbToUse == nil </span><span class="cov8" title="1">{
                dbToUse = u.db
        }</span>

        <span class="cov8" title="1">u.transactionRepo = NewTransactionRepository(dbToUse)
        return u.transactionRepo, nil</span>
}

// UserRepository returns the user repository bound to the current transaction
func (u *UoW) UserRepository() (repository.UserRepository, error) <span class="cov8" title="1">{
        if u.userRepo != nil </span><span class="cov8" title="1">{
                return u.userRepo, nil
        }</span>

        // Create repository on-demand if not already created
        <span class="cov8" title="1">dbToUse := u.tx
        if dbToUse == nil </span><span class="cov8" title="1">{
                dbToUse = u.db
        }</span>

        <span class="cov8" title="1">u.userRepo = NewUserRepository(dbToUse)
        return u.userRepo, nil</span>
}

// ---
// Sample mock for tests:
//
// type MockUnitOfWork struct {
//     DoFunc func(ctx context.Context, fn func(uow UnitOfWork) error) error
//     GetRepositoryFunc func(repoType any) (any, error)
// }
//
// func (m *MockUnitOfWork) Do(ctx context.Context, fn func(uow UnitOfWork) error) error {
//     if m.DoFunc != nil { return m.DoFunc(ctx, fn) }
//     return fn(m)
// }
// func (m *MockUnitOfWork) GetRepository(repoType any) (any, error) {
//     if m.GetRepositoryFunc != nil {
//         return m.GetRepositoryFunc(repoType)
//     }
//     return nil, nil
// }
</pre>

		<pre class="file" id="file14" style="display: none">package config

import (
        "log/slog"
        "regexp"
        "time"

        "github.com/joho/godotenv"
        "github.com/kelseyhightower/envconfig"
)

type DBConfig struct {
        Url string `envconfig:"URL" default:"postgres://postgres:password@localhost:5432/fintech?sslmode=disable"`
}

type AuthConfig struct {
        Strategy string `envconfig:"STRATEGY" default:"jwt"`
}
type JwtConfig struct {
        Secret string        `envconfig:"SECRET_KEY" required:"true"`
        Expiry time.Duration `envconfig:"EXPIRY" default:"24h"`
}

type RedisConfig struct {
        URL string `envconfig:"REDIS_URL" default:"redis://localhost:6379/0"`
}

type RateLimitConfig struct {
        MaxRequests int           `envconfig:"MAX_REQUESTS" default:"100"`
        Window      time.Duration `envconfig:"WINDOW" default:"1m"`
}

type ExchangeRateConfig struct {
        ApiKey            string        `envconfig:"API_KEY"`
        ApiUrl            string        `envconfig:"API_URL" default:"https://api.exchangerate-api.com/v4/latest"`
        CacheTTL          time.Duration `envconfig:"CACHE_TTL" default:"15m"`
        HTTPTimeout       time.Duration `envconfig:"HTTP_TIMEOUT" default:"10s"`
        MaxRetries        int           `envconfig:"MAX_RETRIES" default:"3"`
        RequestsPerMinute int           `envconfig:"REQUESTS_PER_MINUTE" default:"60"`
        BurstSize         int           `envconfig:"BURST_SIZE" default:"10"`
        EnableFallback    bool          `envconfig:"ENABLE_FALLBACK" default:"true"`
        FallbackTTL       time.Duration `envconfig:"FALLBACK_TTL" default:"1h"`
        CachePrefix       string        `envconfig:"CACHE_PREFIX" default:"exr:rate:"`
}

type AppConfig struct {
        Env       string             `envconfig:"APP_ENV" default:"development"`
        Host      string             `envconfig:"APP_HOST" default:"localhost"`
        Port      int                `envconfig:"APP_PORT" default:"3000"`
        DB        DBConfig           `envconfig:"DATABASE"`
        Auth      AuthConfig         `envconfig:"AUTH"`
        Jwt       JwtConfig          `envconfig:"JWT"`
        Exchange  ExchangeRateConfig `envconfig:"EXCHANGE_RATE"`
        Redis     RedisConfig        `envconfig:"REDIS"`
        RateLimit RateLimitConfig    `envconfig:"RATE_LIMIT"`
}

func maskApiKey(key string) string <span class="cov0" title="0">{
        if len(key) &lt;= 6 </span><span class="cov0" title="0">{
                return "****"
        }</span>
        <span class="cov0" title="0">return key[:2] + "****" + key[len(key)-4:]</span>
}

func maskApiKeyInUrl(url string) string <span class="cov0" title="0">{
        // Mask /v6/&lt;key&gt; in path
        re := regexp.MustCompile(`(v6/)[^/]+`)
        masked := re.ReplaceAllString(url, `${1}[MASKED]`)
        // Mask api_key in query string
        qre := regexp.MustCompile(`([?&amp;]api_key=)[^&amp;]+`)
        masked = qre.ReplaceAllString(masked, `${1}[MASKED]`)
        return masked
}</span>

func LoadAppConfig(logger *slog.Logger, envFilePath ...string) (*AppConfig, error) <span class="cov0" title="0">{
        var err error
        if len(envFilePath) &gt; 0 &amp;&amp; envFilePath[0] != "" </span><span class="cov0" title="0">{
                err = godotenv.Load(envFilePath[0])
        }</span> else<span class="cov0" title="0"> {
                err = godotenv.Load()
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Warn("No .env file found or specified, using system environment variables")
        }</span> else<span class="cov0" title="0"> {
                logger.Info("Environment variables loaded from .env file")
        }</span>
        <span class="cov0" title="0">var cfg AppConfig
        if err := envconfig.Process("", &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">logger.Info("App config loaded",
                "db", cfg.DB.Url,
                "jwt_expiry", cfg.Jwt.Expiry,
                "exchange_cache_ttl", cfg.Exchange.CacheTTL,
                "exchange_api_url", maskApiKeyInUrl(cfg.Exchange.ApiUrl),
                "exchange_api_key", maskApiKey(cfg.Exchange.ApiKey),
                "rate_limit_max_requests", cfg.RateLimit.MaxRequests,
                "rate_limit_window", cfg.RateLimit.Window,
        )
        return &amp;cfg, nil</span>
}
</pre>

		<pre class="file" id="file15" style="display: none">package config

import (
        "log/slog"
        "os"
        "strconv"
        "time"

        "github.com/joho/godotenv"
)

// LoadEnv loads environment variables from .env file
// If .env file is not found, it logs a warning and continues
func LoadEnv(logger *slog.Logger) <span class="cov8" title="1">{
        if err := godotenv.Load(); err != nil </span><span class="cov8" title="1">{
                logger.Warn("No .env file found, using system environment variables")
        }</span> else<span class="cov0" title="0"> {
                logger.Info("Environment variables loaded from .env file")
        }</span>
}

// GetEnv retrieves an environment variable with a default value
func GetEnv(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

// GetEnvRequired retrieves a required environment variable
// Panics if the environment variable is not set
func GetEnvRequired(key string) string <span class="cov8" title="1">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov8" title="1">{
                panic("Required environment variable " + key + " is not set")</span>
        }
        <span class="cov8" title="1">return value</span>
}

// IsEnvSet checks if an environment variable is set
func IsEnvSet(key string) bool <span class="cov8" title="1">{
        return os.Getenv(key) != ""
}</span>

// GetEnvAsInt retrieves an environment variable as int with a default value
func GetEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

// GetEnvAsBool retrieves an environment variable as bool with a default value
func GetEnvAsBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

// GetEnvAsDuration retrieves an environment variable as time.Duration with a default value
func GetEnvAsDuration(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>

		<pre class="file" id="file16" style="display: none">package currency

import (
        "context"
        "errors"
        "fmt"
        "regexp"
        "strconv"
        "time"

        "github.com/amirasaad/fintech/pkg/registry"
)

// Common errors
var (
        ErrInvalidCurrencyCode = errors.New("invalid currency code: must be 3 uppercase letters")
        ErrInvalidDecimals     = errors.New("invalid decimals: must be between 0 and 8")
        ErrInvalidSymbol       = errors.New("invalid symbol: must not be empty and max 10 characters")
        ErrCurrencyNotFound    = errors.New("currency not found")
        ErrCurrencyExists      = errors.New("currency already exists")
)

const (
        // DefaultCurrency is the fallback currency code (USD)
        DefaultCurrency = "USD"
        // DefaultDecimals is the default number of decimal places for currencies
        DefaultDecimals = 2
        // MaxDecimals is the maximum number of decimal places allowed
        MaxDecimals = 8
        // MaxSymbolLength is the maximum length for currency symbols
        MaxSymbolLength = 10

        USD = Code("USD")
        EUR = Code("EUR")
)

// Code represents a 3-letter ISO currency code
type Code string

// CurrencyMeta holds currency-specific metadata
type CurrencyMeta struct {
        Code     string            `json:"code"`
        Name     string            `json:"name"`
        Symbol   string            `json:"symbol"`
        Decimals int               `json:"decimals"`
        Country  string            `json:"country,omitempty"`
        Region   string            `json:"region,omitempty"`
        Active   bool              `json:"active"`
        Metadata map[string]string `json:"metadata,omitempty"`
        Created  time.Time         `json:"created"`
        Updated  time.Time         `json:"updated"`
}

// CurrencyEntity implements the registry.Entity interface
type CurrencyEntity struct {
        *registry.BaseEntity
        meta CurrencyMeta
}

// NewCurrencyEntity creates a new currency entity
func NewCurrencyEntity(meta CurrencyMeta) *CurrencyEntity <span class="cov8" title="1">{
        now := time.Now()
        meta.Created = now
        meta.Updated = now

        return &amp;CurrencyEntity{
                BaseEntity: registry.NewBaseEntity(meta.Code, meta.Name),
                meta:       meta,
        }
}</span>

// Code returns the currency code
func (c *CurrencyEntity) Code() string <span class="cov8" title="1">{
        return c.meta.Code
}</span>

// Name returns the currency name
func (c *CurrencyEntity) Name() string <span class="cov8" title="1">{
        return c.meta.Name
}</span>

// Active returns whether the currency is active
func (c *CurrencyEntity) Active() bool <span class="cov8" title="1">{
        return c.meta.Active
}</span>

// Metadata returns currency metadata
func (c *CurrencyEntity) Metadata() map[string]string <span class="cov8" title="1">{
        metadata := c.BaseEntity.Metadata()
        metadata["code"] = c.meta.Code
        metadata["symbol"] = c.meta.Symbol
        metadata["decimals"] = strconv.Itoa(c.meta.Decimals)
        metadata["country"] = c.meta.Country
        metadata["region"] = c.meta.Region
        metadata["active"] = strconv.FormatBool(c.meta.Active)
        metadata["created"] = c.meta.Created.Format(time.RFC3339)
        metadata["updated"] = c.meta.Updated.Format(time.RFC3339)

        // Add custom metadata
        for k, v := range c.meta.Metadata </span><span class="cov8" title="1">{
                metadata[k] = v
        }</span>

        <span class="cov8" title="1">return metadata</span>
}

// CreatedAt returns the creation timestamp
func (c *CurrencyEntity) CreatedAt() time.Time <span class="cov8" title="1">{
        return c.meta.Created
}</span>

// UpdatedAt returns the last update timestamp
func (c *CurrencyEntity) UpdatedAt() time.Time <span class="cov8" title="1">{
        return c.meta.Updated
}</span>

// Meta returns the currency metadata
func (c *CurrencyEntity) Meta() CurrencyMeta <span class="cov8" title="1">{
        return c.meta
}</span>

// CurrencyValidator implements registry.RegistryValidator for currency entities
type CurrencyValidator struct{}

// NewCurrencyValidator creates a new currency validator
func NewCurrencyValidator() *CurrencyValidator <span class="cov8" title="1">{
        return &amp;CurrencyValidator{}
}</span>

// Validate validates a currency entity
func (cv *CurrencyValidator) Validate(ctx context.Context, entity registry.Entity) error <span class="cov8" title="1">{
        // Try to convert to CurrencyEntity first
        if currencyEntity, ok := entity.(*CurrencyEntity); ok </span><span class="cov8" title="1">{
                return validateMeta(currencyEntity.Meta())
        }</span>

        // If it's not a CurrencyEntity, try to validate using metadata
        // This handles cases where the entity might be a BaseEntity or other type
        <span class="cov8" title="1">metadata := entity.Metadata()
        if len(metadata) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid entity type: expected *CurrencyEntity or entity with metadata")
        }</span>

        // Validate required metadata fields
        <span class="cov8" title="1">requiredFields := []string{"code", "symbol", "decimals"}
        for _, field := range requiredFields </span><span class="cov8" title="1">{
                if value, exists := metadata[field]; !exists || value == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("required metadata field missing: %s", field)
                }</span>
        }

        // Validate currency code format
        <span class="cov8" title="1">if code, exists := metadata["code"]; exists </span><span class="cov8" title="1">{
                if !isValidCurrencyCode(code) </span><span class="cov0" title="0">{
                        return ErrInvalidCurrencyCode
                }</span>
        }

        // Validate decimals
        <span class="cov8" title="1">if decimalsStr, exists := metadata["decimals"]; exists </span><span class="cov8" title="1">{
                if decimals, err := strconv.Atoi(decimalsStr); err != nil </span><span class="cov0" title="0">{
                        return ErrInvalidDecimals
                }</span> else<span class="cov8" title="1"> if decimals &lt; 0 || decimals &gt; MaxDecimals </span><span class="cov0" title="0">{
                        return ErrInvalidDecimals
                }</span>
        }

        // Validate symbol
        <span class="cov8" title="1">if symbol, exists := metadata["symbol"]; exists </span><span class="cov8" title="1">{
                if symbol == "" || len(symbol) &gt; MaxSymbolLength </span><span class="cov0" title="0">{
                        return ErrInvalidSymbol
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateMetadata validates currency metadata
func (cv *CurrencyValidator) ValidateMetadata(ctx context.Context, metadata map[string]string) error <span class="cov8" title="1">{
        // Validate required metadata fields
        requiredFields := []string{"code", "symbol", "decimals"}
        for _, field := range requiredFields </span><span class="cov8" title="1">{
                if value, exists := metadata[field]; !exists || value == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("required metadata field missing: %s", field)
                }</span>
        }

        // Validate currency code format
        <span class="cov8" title="1">if code, exists := metadata["code"]; exists </span><span class="cov8" title="1">{
                if !isValidCurrencyCode(code) </span><span class="cov8" title="1">{
                        return ErrInvalidCurrencyCode
                }</span>
        }

        // Validate decimals
        <span class="cov8" title="1">if decimalsStr, exists := metadata["decimals"]; exists </span><span class="cov8" title="1">{
                if decimals, err := strconv.Atoi(decimalsStr); err != nil </span><span class="cov8" title="1">{
                        return ErrInvalidDecimals
                }</span> else<span class="cov8" title="1"> if decimals &lt; 0 || decimals &gt; MaxDecimals </span><span class="cov0" title="0">{
                        return ErrInvalidDecimals
                }</span>
        }

        // Validate symbol
        <span class="cov8" title="1">if symbol, exists := metadata["symbol"]; exists </span><span class="cov8" title="1">{
                if symbol == "" || len(symbol) &gt; MaxSymbolLength </span><span class="cov0" title="0">{
                        return ErrInvalidSymbol
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateMeta validates currency metadata
func validateMeta(meta CurrencyMeta) error <span class="cov8" title="1">{
        // Validate currency code format
        if !isValidCurrencyCode(meta.Code) </span><span class="cov8" title="1">{
                return ErrInvalidCurrencyCode
        }</span>

        // Validate decimals
        <span class="cov8" title="1">if meta.Decimals &lt; 0 || meta.Decimals &gt; MaxDecimals </span><span class="cov8" title="1">{
                return ErrInvalidDecimals
        }</span>

        // Validate symbol
        <span class="cov8" title="1">if meta.Symbol == "" || len(meta.Symbol) &gt; MaxSymbolLength </span><span class="cov8" title="1">{
                return ErrInvalidSymbol
        }</span>

        // Validate name
        <span class="cov8" title="1">if meta.Name == "" </span><span class="cov8" title="1">{
                return errors.New("currency name cannot be empty")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsValidCodeFormat returns true if the code is a well-formed ISO 4217 currency code (3 uppercase letters).
func IsValidCodeFormat(code string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^[A-Z]{3}$`)
        return re.MatchString(code)
}</span>

// isValidCurrencyCode checks if a currency code is valid (3 uppercase letters)
func isValidCurrencyCode(code string) bool <span class="cov8" title="1">{
        return IsValidCodeFormat(code)
}</span>

// CurrencyRegistry provides currency-specific operations using the registry system
type CurrencyRegistry struct {
        registry registry.RegistryProvider
        ctx      context.Context
}

// NewRegistry creates a new currency registry with default currencies
func NewRegistry(ctx context.Context) (*CurrencyRegistry, error) <span class="cov8" title="1">{
        // Create registry with currency-specific configuration
        config := registry.RegistryConfig{
                Name:             "currency-registry",
                MaxEntities:      1000,
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         10 * time.Minute,
        }

        reg := registry.NewEnhancedRegistry(config)
        reg.WithValidator(NewCurrencyValidator())
        reg.WithCache(registry.NewMemoryCache(10 * time.Minute))

        cr := &amp;CurrencyRegistry{
                registry: reg,
                ctx:      ctx,
        }

        // Register default currencies
        if err := cr.registerDefaults(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to register default currencies: %w", err)
        }</span>

        <span class="cov8" title="1">return cr, nil</span>
}

// NewRegistryWithPersistence creates a currency registry with persistence
func NewRegistryWithPersistence(ctx context.Context, persistencePath string) (*CurrencyRegistry, error) <span class="cov8" title="1">{
        config := registry.RegistryConfig{
                Name:              "currency-registry",
                MaxEntities:       1000,
                EnableEvents:      true,
                EnableValidation:  true,
                CacheSize:         100,
                CacheTTL:          10 * time.Minute,
                EnablePersistence: true,
                PersistencePath:   persistencePath,
                AutoSaveInterval:  time.Minute,
        }

        reg := registry.NewEnhancedRegistry(config)
        reg.WithValidator(NewCurrencyValidator())
        reg.WithCache(registry.NewMemoryCache(10 * time.Minute))

        // Add persistence
        persistence := registry.NewFilePersistence(persistencePath)
        reg.WithPersistence(persistence)

        cr := &amp;CurrencyRegistry{
                registry: reg,
                ctx:      ctx,
        }

        // Load existing currencies from persistence
        entities, err := persistence.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load currencies from persistence: %w", err)
        }</span>

        // Register loaded currencies
        <span class="cov8" title="1">for _, entity := range entities </span><span class="cov0" title="0">{
                if err := reg.Register(ctx, entity); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to register loaded currency: %w", err)
                }</span>
        }

        // If no currencies were loaded, register defaults
        <span class="cov8" title="1">if len(entities) == 0 </span><span class="cov8" title="1">{
                if err := cr.registerDefaults(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to register default currencies: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return cr, nil</span>
}

// registerDefaults registers the default set of currencies
func (cr *CurrencyRegistry) registerDefaults() error <span class="cov8" title="1">{
        defaultCurrencies := []CurrencyMeta{
                {Code: "USD", Name: "US Dollar", Symbol: "$", Decimals: 2, Country: "United States", Region: "North America", Active: true},
                {Code: "EUR", Name: "Euro", Symbol: "€", Decimals: 2, Country: "European Union", Region: "Europe", Active: true},
                {Code: "GBP", Name: "British Pound", Symbol: "£", Decimals: 2, Country: "United Kingdom", Region: "Europe", Active: true},
                {Code: "JPY", Name: "Japanese Yen", Symbol: "¥", Decimals: 0, Country: "Japan", Region: "Asia", Active: true},
                {Code: "CAD", Name: "Canadian Dollar", Symbol: "C$", Decimals: 2, Country: "Canada", Region: "North America", Active: true},
                {Code: "AUD", Name: "Australian Dollar", Symbol: "A$", Decimals: 2, Country: "Australia", Region: "Oceania", Active: true},
                {Code: "CHF", Name: "Swiss Franc", Symbol: "CHF", Decimals: 2, Country: "Switzerland", Region: "Europe", Active: true},
                {Code: "CNY", Name: "Chinese Yuan", Symbol: "¥", Decimals: 2, Country: "China", Region: "Asia", Active: true},
                {Code: "INR", Name: "Indian Rupee", Symbol: "₹", Decimals: 2, Country: "India", Region: "Asia", Active: true},
                {Code: "BRL", Name: "Brazilian Real", Symbol: "R$", Decimals: 2, Country: "Brazil", Region: "South America", Active: true},
                {Code: "KWD", Name: "Kuwaiti Dinar", Symbol: "د.ك", Decimals: 3, Country: "Kuwait", Region: "Middle East", Active: true},
                {Code: "EGP", Name: "Egyptian Pound", Symbol: "£", Decimals: 2, Country: "Egypt", Region: "Africa", Active: true},
        }

        for _, meta := range defaultCurrencies </span><span class="cov8" title="1">{
                if err := cr.Register(meta); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to register %s: %w", meta.Code, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Register adds or updates a currency in the registry
func (cr *CurrencyRegistry) Register(meta CurrencyMeta) error <span class="cov8" title="1">{
        // Validate currency metadata
        if err := validateMeta(meta); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        // Create currency entity
        <span class="cov8" title="1">entity := NewCurrencyEntity(meta)

        // Register with the registry
        if err := cr.registry.Register(cr.ctx, entity); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register currency: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Get returns currency metadata for the given code
func (cr *CurrencyRegistry) Get(code string) (CurrencyMeta, error) <span class="cov8" title="1">{
        entity, err := cr.registry.Get(cr.ctx, code)
        if err != nil </span><span class="cov8" title="1">{
                return CurrencyMeta{}, fmt.Errorf("currency not found: %w", err)
        }</span>

        // Convert entity back to currency metadata
        <span class="cov8" title="1">currencyEntity, ok := entity.(*CurrencyEntity)
        if !ok </span><span class="cov0" title="0">{
                // Fallback: try to convert from BaseEntity
                metadata := entity.Metadata()
                decimals, _ := strconv.Atoi(metadata["decimals"])
                active, _ := strconv.ParseBool(metadata["active"])

                return CurrencyMeta{
                        Code:     metadata["code"],
                        Name:     entity.Name(),
                        Symbol:   metadata["symbol"],
                        Decimals: decimals,
                        Country:  metadata["country"],
                        Region:   metadata["region"],
                        Active:   active,
                }, nil
        }</span>

        <span class="cov8" title="1">return currencyEntity.Meta(), nil</span>
}

// IsSupported checks if a currency code is registered and active
func (cr *CurrencyRegistry) IsSupported(code string) bool <span class="cov8" title="1">{
        if !cr.registry.IsRegistered(cr.ctx, code) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">entity, err := cr.registry.Get(cr.ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if ce, ok := entity.(*CurrencyEntity); ok </span><span class="cov8" title="1">{
                return ce.Active()
        }</span> else<span class="cov8" title="1"> {
                return entity.Active()
        }</span>
}

// ListSupported returns a list of all supported currency codes
func (cr *CurrencyRegistry) ListSupported() ([]string, error) <span class="cov8" title="1">{
        entities, err := cr.registry.ListActive(cr.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list currencies: %w", err)
        }</span>

        <span class="cov8" title="1">codes := make([]string, len(entities))
        for i, entity := range entities </span><span class="cov8" title="1">{
                if ce, ok := entity.(*CurrencyEntity); ok </span><span class="cov8" title="1">{
                        codes[i] = ce.Code()
                }</span> else<span class="cov0" title="0"> {
                        codes[i] = entity.ID()
                }</span>
        }

        <span class="cov8" title="1">return codes, nil</span>
}

// ListAll returns all registered currencies (active and inactive)
func (cr *CurrencyRegistry) ListAll() ([]CurrencyMeta, error) <span class="cov8" title="1">{
        entities, err := cr.registry.List(cr.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list currencies: %w", err)
        }</span>

        <span class="cov8" title="1">currencies := make([]CurrencyMeta, len(entities))
        for i, entity := range entities </span><span class="cov8" title="1">{
                if currencyEntity, ok := entity.(*CurrencyEntity); ok </span><span class="cov8" title="1">{
                        currencies[i] = currencyEntity.Meta()
                }</span> else<span class="cov0" title="0"> {
                        // Fallback conversion
                        metadata := entity.Metadata()
                        decimals, _ := strconv.Atoi(metadata["decimals"])
                        active, _ := strconv.ParseBool(metadata["active"])

                        currencies[i] = CurrencyMeta{
                                Code:     metadata["code"],
                                Name:     entity.Name(),
                                Symbol:   metadata["symbol"],
                                Decimals: decimals,
                                Country:  metadata["country"],
                                Region:   metadata["region"],
                                Active:   active,
                        }
                }</span>
        }

        <span class="cov8" title="1">return currencies, nil</span>
}

// Unregister removes a currency from the registry
func (cr *CurrencyRegistry) Unregister(code string) error <span class="cov8" title="1">{
        if err := cr.registry.Unregister(cr.ctx, code); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unregister currency: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Activate activates a currency
func (cr *CurrencyRegistry) Activate(code string) error <span class="cov8" title="1">{
        if err := cr.registry.Activate(cr.ctx, code); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to activate currency: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Deactivate deactivates a currency
func (cr *CurrencyRegistry) Deactivate(code string) error <span class="cov8" title="1">{
        if err := cr.registry.Deactivate(cr.ctx, code); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deactivate currency: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Count returns the total number of registered currencies
func (cr *CurrencyRegistry) Count() (int, error) <span class="cov8" title="1">{
        return cr.registry.Count(cr.ctx)
}</span>

// CountActive returns the number of active currencies
func (cr *CurrencyRegistry) CountActive() (int, error) <span class="cov8" title="1">{
        return cr.registry.CountActive(cr.ctx)
}</span>

// Search searches for currencies by name
func (cr *CurrencyRegistry) Search(query string) ([]CurrencyMeta, error) <span class="cov8" title="1">{
        entities, err := cr.registry.Search(cr.ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search currencies: %w", err)
        }</span>

        <span class="cov8" title="1">currencies := make([]CurrencyMeta, len(entities))
        for i, entity := range entities </span><span class="cov8" title="1">{
                if currencyEntity, ok := entity.(*CurrencyEntity); ok </span><span class="cov8" title="1">{
                        currencies[i] = currencyEntity.Meta()
                }</span>
        }

        <span class="cov8" title="1">return currencies, nil</span>
}

// SearchByRegion searches for currencies by region
func (cr *CurrencyRegistry) SearchByRegion(region string) ([]CurrencyMeta, error) <span class="cov8" title="1">{
        entities, err := cr.registry.SearchByMetadata(cr.ctx, map[string]string{"region": region})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search currencies by region: %w", err)
        }</span>

        <span class="cov8" title="1">currencies := make([]CurrencyMeta, len(entities))
        for i, entity := range entities </span><span class="cov8" title="1">{
                if currencyEntity, ok := entity.(*CurrencyEntity); ok </span><span class="cov8" title="1">{
                        currencies[i] = currencyEntity.Meta()
                }</span>
        }

        <span class="cov8" title="1">return currencies, nil</span>
}

// GetRegistry returns the underlying registry provider
func (cr *CurrencyRegistry) GetRegistry() registry.RegistryProvider <span class="cov0" title="0">{
        return cr.registry
}</span>

// Global currency registry instance
var globalCurrencyRegistry *CurrencyRegistry

// Initialize global registry
func init() <span class="cov8" title="1">{
        var err error
        globalCurrencyRegistry, err = NewRegistry(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to initialize global currency registry: %v", err))</span>
        }
}

// Global convenience functions with error handling
func Register(meta CurrencyMeta) error <span class="cov8" title="1">{
        return globalCurrencyRegistry.Register(meta)
}</span>

func Get(code string) (CurrencyMeta, error) <span class="cov8" title="1">{
        return globalCurrencyRegistry.Get(code)
}</span>

func IsSupported(code string) bool <span class="cov8" title="1">{
        return globalCurrencyRegistry.IsSupported(code)
}</span>

func ListSupported() ([]string, error) <span class="cov8" title="1">{
        return globalCurrencyRegistry.ListSupported()
}</span>

func ListAll() ([]CurrencyMeta, error) <span class="cov0" title="0">{
        return globalCurrencyRegistry.ListAll()
}</span>

func Unregister(code string) error <span class="cov8" title="1">{
        return globalCurrencyRegistry.Unregister(code)
}</span>

func Count() (int, error) <span class="cov8" title="1">{
        return globalCurrencyRegistry.Count()
}</span>

func CountActive() (int, error) <span class="cov0" title="0">{
        return globalCurrencyRegistry.CountActive()
}</span>

func Search(query string) ([]CurrencyMeta, error) <span class="cov8" title="1">{
        return globalCurrencyRegistry.Search(query)
}</span>

func SearchByRegion(region string) ([]CurrencyMeta, error) <span class="cov0" title="0">{
        return globalCurrencyRegistry.SearchByRegion(region)
}</span>

// Backward compatibility functions (deprecated)
func Legacy(code string, meta CurrencyMeta) <span class="cov8" title="1">{
        // Convert legacy format to new format
        newMeta := CurrencyMeta{
                Code:     code,
                Name:     code,
                Symbol:   meta.Symbol,
                Decimals: meta.Decimals,
                Active:   true,
        }

        if err := Register(newMeta); err != nil </span><span class="cov0" title="0">{
                // Log error but don't panic for backward compatibility
                fmt.Printf("Warning: failed to register currency %s: %v\n", code, err)
        }</span>
}

func GetLegacy(code string) CurrencyMeta <span class="cov8" title="1">{
        meta, err := Get(code)
        if err != nil </span><span class="cov8" title="1">{
                // Return default for backward compatibility
                return CurrencyMeta{
                        Code:     code,
                        Name:     code,
                        Symbol:   code,
                        Decimals: DefaultDecimals,
                        Active:   false,
                }
        }</span>
        <span class="cov8" title="1">return meta</span>
}

func IsSupportedLegacy(code string) bool <span class="cov8" title="1">{
        return IsSupported(code)
}</span>

func ListSupportedLegacy() []string <span class="cov8" title="1">{
        codes, err := ListSupported()
        if err != nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov8" title="1">return codes</span>
}

func UnregisterLegacy(code string) bool <span class="cov8" title="1">{
        err := Unregister(code)
        return err == nil
}</span>

func CountLegacy() int <span class="cov8" title="1">{
        count, err := Count()
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return count</span>
}
</pre>

		<pre class="file" id="file17" style="display: none">package account

import (
        "errors"
        "math"
        "regexp"
        "sync"
        "time"

        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/common"
        "github.com/amirasaad/fintech/pkg/domain/money"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/google/uuid"
)

var (
        // ErrDepositAmountExceedsMaxSafeInt is returned when a deposit would overflow the account balance.
        ErrDepositAmountExceedsMaxSafeInt = errors.New("deposit amount exceeds maximum safe integer value") // Deposit would overflow balance

        // ErrTransactionAmountMustBePositive is returned when a transaction amount is not positive.
        ErrTransactionAmountMustBePositive = errors.New("transaction amount must be positive") // Amount must be &gt; 0

        // ErrWithdrawalAmountMustBePositive is returned when a withdrawal amount is not positive.
        ErrWithdrawalAmountMustBePositive = errors.New("withdrawal amount must be positive") // Withdrawal must be &gt; 0

        // ErrInsufficientFunds is returned when an account has insufficient funds for a withdrawal.
        ErrInsufficientFunds = errors.New("insufficient funds for withdrawal") // Not enough balance

        // ErrAccountNotFound is returned when an account cannot be found.
        ErrAccountNotFound = errors.New("account not found") // Account does not exist

        // ErrCannotTransferToSameAccount is returned when a transfer is attempted to the same account.
        ErrCannotTransferToSameAccount = errors.New("cannot transfer to same account")
        // ErrNilAccount is returned when a nil account is encountered in a transfer or operation.
        ErrNilAccount = errors.New("nil account")
        // ErrNotOwner is returned when an operation is attempted by a non-owner.
        ErrNotOwner = errors.New("not owner")
        // ErrCurrencyMismatch is returned when there is a currency mismatch in an operation.
        ErrCurrencyMismatch = errors.New("currency mismatch")
)

// Account represents a user's financial account, supporting multi-currency.
// Invariants:
//   - Only the account owner can perform actions.
//   - Currency must be valid and match the account's currency.
//   - Balance cannot overflow int64.
//   - Balance cannot be negative.
//   - All operations are thread-safe.
type Account struct {
        ID        uuid.UUID
        UserID    uuid.UUID
        Balance   money.Money // Account balance as a value object
        UpdatedAt time.Time
        CreatedAt time.Time
        mu        sync.Mutex
        events    []common.Event // buffer for domain events
}

// IsValidCodeFormat returns true if the code is a well-formed ISO 4217 currency code (3 uppercase letters).
func IsValidCodeFormat(code currency.Code) bool <span class="cov0" title="0">{
        re := regexp.MustCompile(`^[A-Z]{3}$`)
        return re.MatchString(string(code))
}</span>

// Builder is used to build Account instances using a fluent API.
type Builder struct {
        id        uuid.UUID
        userID    uuid.UUID
        balance   int64
        currency  currency.Code
        updatedAt time.Time
        createdAt time.Time
}

// New creates a new Builder with default values.
func New() *Builder <span class="cov8" title="1">{
        return &amp;Builder{
                id:        uuid.New(),
                currency:  currency.DefaultCurrency,
                createdAt: time.Now(),
        }
}</span>

// WithUserID sets the user ID for the account.
func (b *Builder) WithUserID(userID uuid.UUID) *Builder <span class="cov8" title="1">{
        b.userID = userID
        return b
}</span>

// WithCurrency sets the currency for the account.
func (b *Builder) WithCurrency(currencyCode currency.Code) *Builder <span class="cov8" title="1">{
        b.currency = currencyCode
        return b
}</span>

// WithBalance sets the initial balance for the account (for test/data hydration only).
func (b *Builder) WithBalance(balance int64) *Builder <span class="cov8" title="1">{
        b.balance = balance
        return b
}</span>

// WithCreatedAt sets the createdAt timestamp (for test/data hydration only).
func (b *Builder) WithCreatedAt(t time.Time) *Builder <span class="cov0" title="0">{
        b.createdAt = t
        return b
}</span>

// WithUpdatedAt sets the updatedAt timestamp (for test/data hydration only).
func (b *Builder) WithUpdatedAt(t time.Time) *Builder <span class="cov0" title="0">{
        b.updatedAt = t
        return b
}</span>

// Build validates invariants and returns a new Account instance.
func (b *Builder) Build() (*Account, error) <span class="cov8" title="1">{
        if !currency.IsValidCodeFormat(string(b.currency)) </span><span class="cov0" title="0">{
                return nil, common.ErrInvalidCurrencyCode
        }</span>
        <span class="cov8" title="1">if b.userID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, errors.New("userID is required")
        }</span>
        <span class="cov8" title="1">bal, err := money.NewMoneyFromSmallestUnit(b.balance, b.currency)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;Account{
                ID:        b.id,
                UserID:    b.userID,
                Balance:   bal,
                CreatedAt: b.createdAt,
                UpdatedAt: b.updatedAt,
                mu:        sync.Mutex{},
        }, nil</span>
}

// NewAccount creates a new Account for the given user ID.
// Deprecated: Use New().WithUserID(...).WithCurrency(...).Build() instead.
func NewAccount(userID uuid.UUID) (acc *Account) <span class="cov0" title="0">{
        acc, _ = New().WithUserID(userID).Build()
        return
}</span>

// NewAccountWithCurrency creates a new Account for the given user ID and currency.
// Deprecated: Use New().WithUserID(...).WithCurrency(...).Build() instead.
func NewAccountWithCurrency(userID uuid.UUID, currencyCode currency.Code) (acc *Account, err error) <span class="cov0" title="0">{
        return New().WithUserID(userID).WithCurrency(currencyCode).Build()
}</span>

// NewAccountFromData creates an Account from raw data (used for DB hydration).
// This bypasses invariants and should only be used for repository hydration or tests.
func NewAccountFromData(
        id, userID uuid.UUID,
        balance money.Money,
        created, updated time.Time,
) *Account <span class="cov8" title="1">{
        return &amp;Account{
                ID:        id,
                UserID:    userID,
                Balance:   balance,
                CreatedAt: created,
                UpdatedAt: updated,
                mu:        sync.Mutex{},
        }
}</span>

// GetBalance returns the current balance of the account in the main currency unit (e.g., dollars for USD).
// Invariants enforced:
//   - Only the account owner can view the balance.
//   - Currency metadata must be valid.
//
// Returns the balance as float64 or an error if any invariant is violated.
func (a *Account) GetBalance(userID uuid.UUID) (balance float64, err error) <span class="cov8" title="1">{
        if a.UserID != userID </span><span class="cov8" title="1">{
                err = user.ErrUserUnauthorized
                return
        }</span>
        <span class="cov0" title="0">meta, err := currency.Get(string(a.Balance.Currency()))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">divisor := math.Pow10(meta.Decimals)
        balance = float64(a.Balance.Amount()) / divisor
        return</span>
}

// GetBalanceAsMoney returns the current balance as a Money value object.
// Invariants enforced:
//   - Only the account owner can view the balance.
//   - Currency must be valid.
//
// Returns Money or an error if any invariant is violated.
func (a *Account) GetBalanceAsMoney(userID uuid.UUID) (m money.Money, err error) <span class="cov0" title="0">{
        if a.UserID != userID </span><span class="cov0" title="0">{
                err = user.ErrUserUnauthorized
                return
        }</span>
        <span class="cov0" title="0">m = a.Balance
        return</span>
}

// PullEvents returns and clears the buffered domain events.
func (a *Account) PullEvents() []common.Event <span class="cov8" title="1">{
        events := a.events
        a.events = nil
        return events
}</span>

// Deposit adds funds to the account if all business invariants are satisfied.
// Invariants enforced:
//   - Only the account owner can deposit.
//   - Deposit amount must be positive.
//   - Deposit currency must match account currency.
//   - Deposit must not cause integer overflow.
//
// Returns a Transaction or an error if any invariant is violated.
func (a *Account) Deposit(userID uuid.UUID, m money.Money, moneySource MoneySource, paymentID string) error <span class="cov8" title="1">{
        if a.UserID != userID </span><span class="cov8" title="1">{
                return ErrNotOwner
        }</span>
        <span class="cov8" title="1">if !m.IsPositive() </span><span class="cov8" title="1">{
                return ErrTransactionAmountMustBePositive
        }</span>
        <span class="cov8" title="1">if string(m.Currency()) != string(a.Balance.Currency()) </span><span class="cov0" title="0">{
                return common.ErrInvalidCurrencyCode
        }</span>

        <span class="cov8" title="1">a.events = append(a.events, DepositRequestedEvent{
                AccountID: a.ID.String(),
                UserID:    userID.String(),
                Amount:    m.AmountFloat(),
                Currency:  string(m.Currency()),
                Source:    moneySource,
                Timestamp: time.Now().Unix(),
                PaymentID: paymentID,
        })
        return nil</span>
}

// Withdraw removes funds from the account if all business invariants are satisfied.
// Invariants enforced:
//   - Only the account owner can withdraw.
//   - Withdrawal amount must be positive.
//   - Withdrawal currency must match account currency.
//   - Cannot withdraw more than the current balance.
//
// Returns a Transaction or an error if any invariant is violated.
func (a *Account) Withdraw(userID uuid.UUID, m money.Money, target ExternalTarget, paymentID string) error <span class="cov8" title="1">{
        if a.UserID != userID </span><span class="cov8" title="1">{
                return ErrNotOwner
        }</span>
        <span class="cov8" title="1">if !m.IsPositive() </span><span class="cov8" title="1">{
                return ErrWithdrawalAmountMustBePositive
        }</span>
        <span class="cov8" title="1">if string(m.Currency()) != string(a.Balance.Currency()) </span><span class="cov0" title="0">{
                return common.ErrInvalidCurrencyCode
        }</span>

        <span class="cov8" title="1">a.events = append(a.events, WithdrawRequestedEvent{
                AccountID: a.ID.String(),
                UserID:    userID.String(),
                Amount:    m.AmountFloat(),
                Currency:  string(m.Currency()),
                Target:    target,
                Timestamp: time.Now().Unix(),
                PaymentID: paymentID,
        })
        return nil</span>
}

// Transfer moves funds from this account to another account.
func (a *Account) Transfer(senderUserID, receiverUserID uuid.UUID, dest *Account, amount money.Money, moneySource MoneySource) error <span class="cov8" title="1">{
        if a == nil || dest == nil </span><span class="cov8" title="1">{
                return ErrNilAccount
        }</span>
        <span class="cov8" title="1">if a.ID == dest.ID </span><span class="cov8" title="1">{
                return ErrCannotTransferToSameAccount
        }</span>
        <span class="cov8" title="1">if a.UserID != senderUserID </span><span class="cov8" title="1">{
                return ErrNotOwner
        }</span>
        <span class="cov8" title="1">if !amount.IsPositive() </span><span class="cov8" title="1">{
                return ErrTransactionAmountMustBePositive
        }</span>
        <span class="cov8" title="1">if !a.Balance.IsSameCurrency(amount) || !dest.Balance.IsSameCurrency(amount) </span><span class="cov8" title="1">{
                return ErrCurrencyMismatch
        }</span>
        <span class="cov8" title="1">hasEnough, _ := a.Balance.GreaterThan(amount)
        if !hasEnough &amp;&amp; !a.Balance.Equals(amount) </span><span class="cov8" title="1">{
                return ErrInsufficientFunds
        }</span>

        <span class="cov8" title="1">a.events = append(a.events, TransferRequestedEvent{
                EventID:         uuid.New(),
                SenderUserID:    senderUserID,
                ReceiverUserID:  receiverUserID,
                SourceAccountID: a.ID,
                DestAccountID:   dest.ID,
                Amount:          amount.AmountFloat(),
                Currency:        string(amount.Currency()),
                Source:          moneySource,
                Timestamp:       time.Now().Unix(),
        })
        return nil</span>
}
</pre>

		<pre class="file" id="file18" style="display: none">package account

import "github.com/google/uuid"

// PaymentStatus represents the status of a payment transaction event.
type PaymentStatus string

const (
        // PaymentStatusInitiated indicates the user requested a payment (not yet sent to provider).
        PaymentStatusInitiated PaymentStatus = "initiated"
        // PaymentStatusPending indicates the payment is in progress (sent to provider, awaiting confirmation).
        PaymentStatusPending PaymentStatus = "pending"
        // PaymentStatusCompleted indicates the payment has been confirmed and completed.
        PaymentStatusCompleted PaymentStatus = "completed"
        // PaymentStatusFailed indicates the payment has failed or was rejected.
        PaymentStatusFailed PaymentStatus = "failed"
)

// PaymentEvent represents an event in the payment lifecycle (initiated, pending, completed, failed).
type PaymentEvent struct {
        EventID       uuid.UUID         // Unique event ID (UUID)
        TransactionID string            // Associated transaction
        AccountID     string            // Account involved
        UserID        string            // User who initiated
        Amount        int64             // Amount in minor units
        Currency      string            // Currency code (ISO 4217)
        Status        PaymentStatus     // initiated, pending, completed, failed
        Provider      string            // Payment provider name
        Timestamp     int64             // Unix timestamp (UTC)
        Metadata      map[string]string // Optional extra info
}

// EventType returns the type of the PaymentEvent.
func (e PaymentEvent) EventType() string <span class="cov0" title="0">{ return "PaymentEvent" }</span>

// DepositRequestedEvent is emitted when a deposit is requested (pure event-driven domain).
type DepositRequestedEvent struct {
        EventID   uuid.UUID
        AccountID string
        UserID    string
        Amount    float64
        Currency  string
        Source    MoneySource
        Timestamp int64
        PaymentID string // Added for payment provider integration
}

// EventType returns the type of the DepositRequestedEvent.
func (e DepositRequestedEvent) EventType() string <span class="cov0" title="0">{ return "DepositRequestedEvent" }</span>

// WithdrawRequestedEvent is emitted when a withdrawal is requested (pure event-driven domain).
type WithdrawRequestedEvent struct {
        EventID   uuid.UUID
        AccountID string
        UserID    string
        Amount    float64
        Currency  string
        Target    ExternalTarget
        Timestamp int64
        PaymentID string // Added for payment provider integration
}

// EventType returns the type of the WithdrawRequestedEvent.
func (e WithdrawRequestedEvent) EventType() string <span class="cov0" title="0">{ return "WithdrawRequestedEvent" }</span>

// TransferRequestedEvent is emitted when a transfer is requested (pure event-driven domain).
type TransferRequestedEvent struct {
        EventID         uuid.UUID
        SourceAccountID uuid.UUID
        DestAccountID   uuid.UUID
        SenderUserID    uuid.UUID
        ReceiverUserID  uuid.UUID
        Amount          float64
        Currency        string
        Source          MoneySource
        Timestamp       int64
}

// EventType returns the type of the TransferRequestedEvent.
func (e TransferRequestedEvent) EventType() string <span class="cov8" title="1">{ return "TransferRequestedEvent" }</span>
</pre>

		<pre class="file" id="file19" style="display: none">package account

import (
        "time"

        "github.com/amirasaad/fintech/pkg/domain/money"
        "github.com/google/uuid"
)

// TransactionStatus represents the status of a transaction in the payment lifecycle.
type TransactionStatus string

// TransactionStatusInitiated indicates that a transaction has been initiated but not yet completed.
const TransactionStatusInitiated = "initiated"

// TransactionStatusPending indicates that a transaction is pending and awaiting completion.
const TransactionStatusPending = "pending"

// TransactionStatusCompleted indicates that a transaction has been completed successfully.
const TransactionStatusCompleted = "completed"

// TransactionStatusFailed indicates that a transaction has been failed.
const TransactionStatusFailed TransactionStatus = "failed"

// ExternalTarget represents the destination for an external withdrawal, such as a bank account or wallet.
type ExternalTarget struct {
        BankAccountNumber     string
        RoutingNumber         string
        ExternalWalletAddress string
}

// Transaction represents a financial transaction for an account.
type Transaction struct {
        ID             uuid.UUID
        UserID         uuid.UUID
        AccountID      uuid.UUID
        Amount         money.Money
        Balance        money.Money // Account balance snapshot
        MoneySource    MoneySource // Origin of funds (e.g., Cash, BankAccount, Stripe, etc.)
        Status         TransactionStatus
        ExternalTarget ExternalTarget
        PaymentID      string // External payment provider ID for webhook correlation
        CreatedAt      time.Time
}

// NewTransactionFromData creates a Transaction from raw data (used for DB hydration or test fixtures).
// This bypasses invariants and should only be used for repository hydration or tests.
func NewTransactionFromData(
        id, userID, accountID uuid.UUID,
        amount money.Money,
        balance money.Money,
        moneySource MoneySource,
        created time.Time,
) *Transaction <span class="cov0" title="0">{
        return &amp;Transaction{
                ID:          id,
                UserID:      userID,
                AccountID:   accountID,
                Amount:      amount,
                Balance:     balance,
                MoneySource: moneySource,
                CreatedAt:   created,
        }
}</span>

// MoneySource represents the origin of funds for a transaction.
type MoneySource string

// Money source constants define the origin of funds for transactions.
const (
        MoneySourceInternal       MoneySource = "Internal"
        MoneySourceBankAccount    MoneySource = "BankAccount"
        MoneySourceCard           MoneySource = "Card"
        MoneySourceCash           MoneySource = "Cash"
        MoneySourceExternalWallet MoneySource = "ExternalWallet"
)
</pre>

		<pre class="file" id="file20" style="display: none">package money

import (
        "fmt"
        "log/slog"
        "math"
        "math/big"

        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/common"
)

// Use common.ErrInvalidCurrencyCode and common.ConversionInfo

// Amount represents a monetary amount as an integer in the smallest currency unit (e.g., cents for USD).
type Amount = int64

// Money represents a monetary value in a specific currency.
// Invariants:
//   - Amount is always stored in the smallest currency unit (e.g., cents for USD).
//   - Currency code must be valid ISO 4217 (3 uppercase letters).
//   - All arithmetic operations require matching currencies.
type Money struct {
        amount   Amount
        currency currency.Code
}

// Zero creates a Money object with zero amount in the specified currency.
func Zero(cur currency.Code) Money <span class="cov0" title="0">{
        return Money{
                amount:   0,
                currency: cur,
        }
}</span>

// NewFromData creates a Money object from raw data (used for DB hydration).
// This bypasses invariants and should only be used for repository hydration or tests.
func NewFromData(amount int64, cc string) Money <span class="cov0" title="0">{
        return Money{
                amount:   amount,
                currency: currency.Code(cc),
        }
}</span>

// New creates a new Money value object with the given amount and currency code.
// Invariants enforced:
//   - Currency code must be valid ISO 4217 (3 uppercase letters).
//   - Amount must not have more decimal places than allowed by the currency.
//   - Amount is converted to the smallest currency unit.
//
// Returns Money or an error if any invariant is violated.
func New(
        amount float64,
        currencyCode currency.Code,
) (
        money Money,
        err error,
) <span class="cov8" title="1">{
        if currencyCode == "" </span><span class="cov0" title="0">{
                currencyCode = currency.Code(currency.DefaultCurrency)
        }</span>
        <span class="cov8" title="1">if !currency.IsValidCodeFormat(string(currencyCode)) </span><span class="cov8" title="1">{
                err = common.ErrInvalidCurrencyCode
                return
        }</span>

        <span class="cov8" title="1">smallestUnit, err := convertToSmallestUnit(amount, string(currencyCode))
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">money = Money{amount: Amount(smallestUnit), currency: currencyCode}
        return</span>
}

// NewMoneyFromSmallestUnit creates a new Money object from the smallest currency unit.
// Invariants enforced:
//   - Currency code must be valid ISO 4217 (3 uppercase letters).
//
// Returns Money or an error if any invariant is violated.
func NewMoneyFromSmallestUnit(
        amount int64,
        currencyCode currency.Code,
) (
        money Money,
        err error,
) <span class="cov8" title="1">{
        if currencyCode == "" </span><span class="cov0" title="0">{
                currencyCode = currency.Code(currency.DefaultCurrency)
        }</span>
        <span class="cov8" title="1">if !currency.IsValidCodeFormat(string(currencyCode)) </span><span class="cov8" title="1">{
                err = common.ErrInvalidCurrencyCode
                return
        }</span>

        <span class="cov8" title="1">money = Money{amount: Amount(amount), currency: currencyCode}
        return</span>
}

// Amount returns the amount of the Money object in the smallest currency unit.
func (m Money) Amount() Amount <span class="cov8" title="1">{
        return m.amount
}</span>

// AmountFloat returns the amount as a float64 in the main currency unit (e.g., dollars for USD).
// Invariants enforced:
//   - Currency metadata must be valid.
func (m Money) AmountFloat() float64 <span class="cov8" title="1">{
        meta, err := currency.Get(string(m.currency))
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("invalid currency code in AmountFloat", "currency", m.currency, "error", err)
                return 0
        }</span>

        <span class="cov8" title="1">divisor := math.Pow10(meta.Decimals)
        return float64(m.amount) / divisor</span>
}

// Currency returns the currency of the Money object.
func (m Money) Currency() currency.Code <span class="cov8" title="1">{
        return m.currency
}</span>

// Add adds another Money object to the current Money object.
// Invariants enforced:
//   - Currencies must match.
//
// Returns Money or an error if currencies do not match.
func (m Money) Add(other Money) (Money, error) <span class="cov8" title="1">{
        if !m.IsSameCurrency(other) </span><span class="cov8" title="1">{
                return Money{}, common.ErrInvalidCurrencyCode
        }</span>
        <span class="cov8" title="1">return Money{
                amount:   m.amount + other.amount,
                currency: m.currency,
        }, nil</span>
}

// Subtract subtracts another Money object from the current Money object.
// Invariants enforced:
//   - Currencies must match.
//
// Returns Money or an error if currencies do not match.
func (m Money) Subtract(other Money) (Money, error) <span class="cov8" title="1">{
        if !m.IsSameCurrency(other) </span><span class="cov0" title="0">{
                return Money{}, common.ErrInvalidCurrencyCode
        }</span>
        <span class="cov8" title="1">return Money{
                amount:   m.amount - other.amount,
                currency: m.currency,
        }, nil</span>
}

// Negate negates the current Money object.
func (m Money) Negate() Money <span class="cov8" title="1">{
        return Money{
                amount:   -m.amount,
                currency: m.currency,
        }
}</span>

// Equals checks if the current Money object is equal to another Money object.
// Invariants enforced:
//   - Currencies must match.
//
// Returns false if currencies do not match.
func (m Money) Equals(other Money) bool <span class="cov8" title="1">{
        return m.IsSameCurrency(other) &amp;&amp; m.amount == other.amount
}</span>

// GreaterThan checks if the current Money object is greater than another Money object.
// Invariants enforced:
//   - Currencies must match.
//
// Returns an error if currencies do not match.
func (m Money) GreaterThan(other Money) (bool, error) <span class="cov8" title="1">{
        if !m.IsSameCurrency(other) </span><span class="cov8" title="1">{
                return false, common.ErrInvalidCurrencyCode
        }</span>
        <span class="cov8" title="1">return m.amount &gt; other.amount, nil</span>
}

// LessThan checks if the current Money object is less than another Money object.
// Invariants enforced:
//   - Currencies must match.
//
// Returns an error if currencies do not match.
func (m Money) LessThan(other Money) (bool, error) <span class="cov8" title="1">{
        if !m.IsSameCurrency(other) </span><span class="cov0" title="0">{
                return false, common.ErrInvalidCurrencyCode
        }</span>
        <span class="cov8" title="1">return m.amount &lt; other.amount, nil</span>
}

// IsSameCurrency checks if the current Money object has the same currency as another Money object.
func (m Money) IsSameCurrency(other Money) bool <span class="cov8" title="1">{
        return m.currency == other.currency
}</span>

// IsPositive returns true if the amount is greater than zero.
func (m Money) IsPositive() bool <span class="cov8" title="1">{
        return m.amount &gt; 0
}</span>

// IsNegative returns true if the amount is less than zero.
func (m Money) IsNegative() bool <span class="cov8" title="1">{
        return m.amount &lt; 0
}</span>

// IsZero returns true if the amount is zero.
func (m Money) IsZero() bool <span class="cov8" title="1">{
        return m.amount == 0
}</span>

// Abs returns the absolute value of the Money amount.
func (m Money) Abs() Money <span class="cov8" title="1">{
        if m.amount &lt; 0 </span><span class="cov8" title="1">{
                return m.Negate()
        }</span>
        <span class="cov8" title="1">return m</span>
}

// Multiply multiplies the Money amount by a scalar factor.
// Invariants enforced:
//   - Result must not overflow int64.
//
// Returns Money or an error if overflow would occur.
func (m Money) Multiply(factor float64) (Money, error) <span class="cov8" title="1">{
        // Convert to float for multiplication
        resultFloat := float64(m.amount) * factor

        // Check for overflow
        if resultFloat &gt; float64(math.MaxInt64) || resultFloat &lt; float64(math.MinInt64) </span><span class="cov0" title="0">{
                return Money{}, fmt.Errorf("multiplication result would overflow")
        }</span>

        <span class="cov8" title="1">return Money{
                amount:   Amount(int64(resultFloat)),
                currency: m.currency,
        }, nil</span>
}

// Divide divides the Money amount by a scalar divisor.
// Invariants enforced:
//   - Divisor must not be zero.
//   - Result must not overflow int64.
//   - Division must not lose precision.
//
// Returns Money or an error if any invariant is violated.
func (m Money) Divide(divisor float64) (Money, error) <span class="cov8" title="1">{
        if divisor == 0 </span><span class="cov8" title="1">{
                return Money{}, fmt.Errorf("division by zero")
        }</span>

        // Convert to float for division
        <span class="cov8" title="1">resultFloat := float64(m.amount) / divisor

        // Check for overflow
        if resultFloat &gt; float64(math.MaxInt64) || resultFloat &lt; float64(math.MinInt64) </span><span class="cov0" title="0">{
                return Money{}, fmt.Errorf("division result would overflow")
        }</span>

        // Check if result is an integer (no precision loss)
        <span class="cov8" title="1">if resultFloat != float64(int64(resultFloat)) </span><span class="cov8" title="1">{
                return Money{}, fmt.Errorf("division would result in precision loss")
        }</span>

        <span class="cov8" title="1">return Money{
                amount:   Amount(int64(resultFloat)),
                currency: m.currency,
        }, nil</span>
}

// String returns a string representation of the Money object.
func (m Money) String() string <span class="cov8" title="1">{
        meta, err := currency.Get(string(m.currency))
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("invalid currency code in String", "currency", m.currency, "error", err)
                return ""
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.*f %s", meta.Decimals, m.AmountFloat(), m.currency)</span>
}

// convertToSmallestUnit converts a float64 amount to the smallest currency unit.
// This ensures precision by avoiding floating-point arithmetic issues.
func convertToSmallestUnit(amount float64, currencyCode string) (int64, error) <span class="cov8" title="1">{
        meta, err := currency.Get(currencyCode)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">factor := new(big.Rat).SetFloat64(math.Pow10(meta.Decimals))
        amountRat := new(big.Rat).SetFloat64(amount)
        if amountRat == nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid amount float")
        }</span>
        // Multiply amount by factor
        <span class="cov8" title="1">scaled := new(big.Rat).Mul(amountRat, factor)
        // Convert to float64 for rounding
        scaledFloat, _ := scaled.Float64()
        rounded := int64(math.Round(scaledFloat))
        if float64(rounded) &gt; float64(math.MaxInt64) || float64(rounded) &lt; float64(math.MinInt64) </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("amount exceeds maximum safe integer value")
        }</span>
        <span class="cov8" title="1">return rounded, nil</span>
}
</pre>

		<pre class="file" id="file21" style="display: none">package user

import (
        "errors"
        "time"

        "github.com/amirasaad/fintech/pkg/utils"
        "github.com/google/uuid"
)

var (
        // ErrUserNotFound is returned when a user cannot be found in the repository.
        ErrUserNotFound = errors.New("user not found")
        // ErrUserUnauthorized is return when user
        ErrUserUnauthorized = errors.New("user unauthorized")
)

// User represents a user in the system.
type User struct {
        ID        uuid.UUID `json:"id"`
        Username  string    `json:"username"`
        Email     string    `json:"email"`
        Password  string    `json:"password"`
        Names     string    `json:"names"`
        CreatedAt time.Time `json:"created"`
        UpdatedAt time.Time `json:"updated"`
}

// NewUser creates a new User with a hashed password and current timestamps.
func NewUser(username, email, password string) (*User, error) <span class="cov8" title="1">{
        if username == "" </span><span class="cov8" title="1">{
                return nil, errors.New("username cannot be empty")
        }</span>
        <span class="cov8" title="1">if email == "" </span><span class="cov0" title="0">{
                return nil, errors.New("email cannot be empty")
        }</span>
        <span class="cov8" title="1">hashedPassword, err := utils.HashPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;User{
                ID:        uuid.New(),
                Username:  username,
                Email:     email,
                Password:  hashedPassword,
                CreatedAt: time.Now().UTC(),
                UpdatedAt: time.Now().UTC(),
        }, nil</span>
}

// NewUserFromData creates a User from raw data (used for DB hydration).
func NewUserFromData(
        id uuid.UUID,
        username, email, password string,
        created, updated time.Time,
) *User <span class="cov0" title="0">{
        return &amp;User{
                ID:        id,
                Username:  username,
                Email:     email,
                Password:  password,
                CreatedAt: created,
                UpdatedAt: updated,
        }
}</span>
</pre>

		<pre class="file" id="file22" style="display: none">package handler

import (
        "context"
)

// BaseHandler provides common functionality for all handlers
type BaseHandler struct {
        next OperationHandler
}

// SetNext sets the next handler in the chain
func (h *BaseHandler) SetNext(handler OperationHandler) <span class="cov8" title="1">{
        h.next = handler
}</span>

// Handle passes the request to the next handler in the chain
func (h *BaseHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        if h.next != nil </span><span class="cov8" title="1">{
                return h.next.Handle(ctx, req)
        }</span>
        <span class="cov8" title="1">return &amp;OperationResponse{}, nil</span>
}
</pre>

		<pre class="file" id="file23" style="display: none">package handler

import (
        "log/slog"

        mon "github.com/amirasaad/fintech/pkg/domain/money"
        "github.com/amirasaad/fintech/pkg/repository"
)

// ChainBuilder builds operation-specific chains
type ChainBuilder struct {
        uow       repository.UnitOfWork
        converter mon.CurrencyConverter
        logger    *slog.Logger
}

// NewChainBuilder creates a new chain builder
func NewChainBuilder(uow repository.UnitOfWork, converter mon.CurrencyConverter, logger *slog.Logger) *ChainBuilder <span class="cov8" title="1">{
        return &amp;ChainBuilder{
                uow:       uow,
                converter: converter,
                logger:    logger,
        }
}</span>

// BuildDepositChain builds a chain for deposit operations
func (b *ChainBuilder) BuildDepositChain() OperationHandler <span class="cov8" title="1">{
        validation := &amp;ValidationHandler{
                uow:    b.uow,
                logger: b.logger,
        }
        moneyCreation := &amp;MoneyCreationHandler{
                logger: b.logger,
        }
        currencyConversion := &amp;CurrencyConversionHandler{
                converter: b.converter,
                logger:    b.logger,
        }
        domainOperation := &amp;DepositOperationHandler{
                logger: b.logger,
        }
        persistence := &amp;DepositPersistenceHandler{
                uow:    b.uow,
                logger: b.logger,
        }

        // Chain them together
        validation.SetNext(moneyCreation)
        moneyCreation.SetNext(currencyConversion)
        currencyConversion.SetNext(domainOperation)
        domainOperation.SetNext(persistence)

        return validation
}</span>

// BuildWithdrawChain builds a chain for withdraw operations
func (b *ChainBuilder) BuildWithdrawChain() OperationHandler <span class="cov8" title="1">{
        validation := &amp;ValidationHandler{
                uow:    b.uow,
                logger: b.logger,
        }
        moneyCreation := &amp;MoneyCreationHandler{
                logger: b.logger,
        }
        currencyConversion := &amp;CurrencyConversionHandler{
                converter: b.converter,
                logger:    b.logger,
        }
        domainOperation := &amp;WithdrawOperationHandler{
                logger: b.logger,
        }
        persistence := &amp;WithdrawPersistenceHandler{
                uow:    b.uow,
                logger: b.logger,
        }

        // Chain them together
        validation.SetNext(moneyCreation)
        moneyCreation.SetNext(currencyConversion)
        currencyConversion.SetNext(domainOperation)
        domainOperation.SetNext(persistence)

        return validation
}</span>

// BuildTransferChain builds a chain for transfer operations
func (b *ChainBuilder) BuildTransferChain() OperationHandler <span class="cov8" title="1">{
        validation := &amp;TransferValidationHandler{
                uow:    b.uow,
                logger: b.logger,
        }
        moneyCreation := &amp;MoneyCreationHandler{
                logger: b.logger,
        }
        currencyConversion := &amp;CurrencyConversionHandler{
                converter: b.converter,
                logger:    b.logger,
        }
        domainOperation := &amp;TransferOperationHandler{
                logger: b.logger,
        }
        persistence := &amp;TransferPersistenceHandler{
                uow:    b.uow,
                logger: b.logger,
        }

        // Chain them together
        validation.SetNext(moneyCreation)
        moneyCreation.SetNext(currencyConversion)
        currencyConversion.SetNext(domainOperation)
        domainOperation.SetNext(persistence)

        return validation
}</span>
</pre>

		<pre class="file" id="file24" style="display: none">package handler

import (
        "context"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/account"
        mon "github.com/amirasaad/fintech/pkg/domain/money"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// AccountChain provides a simplified interface for executing account operations
type AccountChain struct {
        builder *ChainBuilder
}

// NewAccountChain creates a new account chain with the given dependencies
func NewAccountChain(uow repository.UnitOfWork, converter mon.CurrencyConverter, logger *slog.Logger) *AccountChain <span class="cov0" title="0">{
        return &amp;AccountChain{
                builder: NewChainBuilder(uow, converter, logger),
        }
}</span>

// Deposit executes a deposit operation using the chain of responsibility pattern
func (c *AccountChain) Deposit(ctx context.Context, userID, accountID uuid.UUID, amount float64, currencyCode currency.Code, moneySource, paymentID string) (*OperationResponse, error) <span class="cov0" title="0">{
        chain := c.builder.BuildDepositChain()

        req := &amp;OperationRequest{
                UserID:       userID,
                AccountID:    accountID,
                PaymentID:    paymentID,
                Amount:       amount,
                CurrencyCode: currencyCode,
                Operation:    OperationDeposit,
                MoneySource:  moneySource,
        }

        return chain.Handle(ctx, req)
}</span>

// Withdraw executes a withdraw operation to an external target using the chain of responsibility pattern
func (c *AccountChain) Withdraw(ctx context.Context, userID, accountID uuid.UUID, amount float64, currencyCode currency.Code, externalTarget ExternalTarget, paymentID string) (*OperationResponse, error) <span class="cov0" title="0">{
        chain := c.builder.BuildWithdrawChain()

        req := &amp;OperationRequest{
                UserID:         userID,
                AccountID:      accountID,
                PaymentID:      paymentID,
                Amount:         amount,
                CurrencyCode:   currencyCode,
                Operation:      OperationWithdraw,
                MoneySource:    "External",
                ExternalTarget: &amp;externalTarget,
        }

        return chain.Handle(ctx, req)
}</span>

// Transfer executes a transfer operation using the chain of responsibility pattern
func (c *AccountChain) Transfer(ctx context.Context, senderUserID, receiverUserID, sourceAccountID, destAccountID uuid.UUID, amount float64, currencyCode currency.Code) (*OperationResponse, error) <span class="cov0" title="0">{
        chain := c.builder.BuildTransferChain()

        req := &amp;OperationRequest{
                UserID:        senderUserID,
                DestUserID:    receiverUserID,
                AccountID:     sourceAccountID,
                DestAccountID: destAccountID,
                Amount:        amount,
                CurrencyCode:  currencyCode,
                Operation:     OperationTransfer,
                MoneySource:   string(account.MoneySourceInternal),
        }

        return chain.Handle(ctx, req)
}</span>
</pre>

		<pre class="file" id="file25" style="display: none">package handler

import (
        "context"
        "log/slog"

        account "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/repository"
)

// DepositPersistenceHandler handles the persistence of deposit operations.
// It updates the account and creates the deposit transaction record.
type DepositPersistenceHandler struct {
        BaseHandler
        uow    repository.UnitOfWork
        logger *slog.Logger
}

// Handle processes deposit events, updates the account, and creates the deposit transaction record.
func (h *DepositPersistenceHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger
        events := req.Account.PullEvents()
        var transactions []*account.Transaction

        if len(events) == 0 </span><span class="cov0" title="0">{
                logger.Error("DepositPersistenceHandler: no events found on account")
                return &amp;OperationResponse{Error: context.Canceled}, nil
        }</span>

        <span class="cov8" title="1">if err := h.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("DepositPersistenceHandler failed: AccountRepository error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">if err = repo.Update(req.Account); err != nil </span><span class="cov0" title="0">{
                        logger.Error("DepositPersistenceHandler failed: account update error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">txRepo, err := uow.TransactionRepository()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("DepositPersistenceHandler failed: TransactionRepository error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">for _, evt := range events </span><span class="cov8" title="1">{
                        e, ok := evt.(account.DepositRequestedEvent) //nolint:go-critic
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Replace inline transaction construction with factory helper
                        <span class="cov8" title="1">tx := NewDepositTransaction(e)
                        if err := txRepo.Create(tx, req.ConvInfo, ""); err != nil </span><span class="cov0" title="0">{
                                logger.Error("DepositPersistenceHandler failed: transaction create error", "error", err)
                                return err
                        }</span>
                        <span class="cov8" title="1">transactions = append(transactions, tx)</span>
                }
                <span class="cov8" title="1">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">logger.Info("DepositPersistenceHandler: persistence completed successfully")

        return &amp;OperationResponse{
                Transactions: transactions,
                ConvInfo:     req.ConvInfo,
        }, nil</span>
}
</pre>

		<pre class="file" id="file26" style="display: none">package handler

import (
        "context"
        "log/slog"

        mon "github.com/amirasaad/fintech/pkg/domain/money"
)

// MoneyCreationHandler creates a Money object from the request amount and currency
type MoneyCreationHandler struct {
        BaseHandler
        logger *slog.Logger
}

// Handle creates a Money object and passes the request to the next handler
func (h *MoneyCreationHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger.With("amount", req.Amount, "currency", req.CurrencyCode)

        money, err := mon.New(req.Amount, req.CurrencyCode)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("MoneyCreationHandler failed: invalid money", "error", err)
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">req.Money = money
        logger.Info("MoneyCreationHandler: money created successfully")

        return h.BaseHandler.Handle(ctx, req)</span>
}

// CurrencyConversionHandler handles currency conversion if needed
type CurrencyConversionHandler struct {
        BaseHandler
        converter mon.CurrencyConverter
        logger    *slog.Logger
}

// Handle converts currency if needed and passes the request to the next handler
func (h *CurrencyConversionHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger.With("fromCurrency", req.Money.Currency(), "toCurrency", req.Account.Balance.Currency())

        if req.Money.Currency() == req.Account.Balance.Currency() </span><span class="cov8" title="1">{
                req.ConvertedMoney = req.Money
                logger.Info("CurrencyConversionHandler: no conversion needed")
                return h.BaseHandler.Handle(ctx, req)
        }</span>

        <span class="cov8" title="1">convInfo, err := h.converter.Convert(req.Money.AmountFloat(), string(req.Money.Currency()), string(req.Account.Balance.Currency()))
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("CurrencyConversionHandler failed: conversion error", "error", err)
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">convertedMoney, err := mon.New(convInfo.ConvertedAmount, req.Account.Balance.Currency())
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("CurrencyConversionHandler failed: converted money creation error", "error", err)
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">req.ConvertedMoney = convertedMoney
        if req.Operation == OperationTransfer </span><span class="cov0" title="0">{
                req.ConvInfoOut = convInfo
                req.ConvInfoIn = convInfo
        }</span> else<span class="cov8" title="1"> {
                req.ConvInfo = convInfo
        }</span>
        <span class="cov8" title="1">logger.Info("CurrencyConversionHandler: conversion completed", "rate", convInfo.ConversionRate)

        return h.BaseHandler.Handle(ctx, req)</span>
}
</pre>

		<pre class="file" id="file27" style="display: none">package handler

import (
        "context"
        "log/slog"
        "strings"

        "github.com/amirasaad/fintech/pkg/domain/account"
)

// DepositOperationHandler executes deposit domain operations
type DepositOperationHandler struct {
        BaseHandler
        logger *slog.Logger
}

// Handle executes the deposit domain operation
func (h *DepositOperationHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger.With("operation", "deposit")

        err := req.Account.Deposit(req.UserID, req.ConvertedMoney, account.MoneySource(req.MoneySource), req.PaymentID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("DepositOperationHandler failed: domain operation error", "error", err)
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">logger.Info("DepositOperationHandler: domain operation completed")
        return h.BaseHandler.Handle(ctx, req)</span>
}

// WithdrawOperationHandler executes withdraw domain operations
type WithdrawOperationHandler struct {
        BaseHandler
        logger *slog.Logger
}

func maskExternalTarget(target *ExternalTarget) string <span class="cov8" title="1">{
        if target == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">if target.BankAccountNumber != "" </span><span class="cov8" title="1">{
                return maskString(target.BankAccountNumber)
        }</span>
        <span class="cov0" title="0">if target.ExternalWalletAddress != "" </span><span class="cov0" title="0">{
                return maskString(target.ExternalWalletAddress)
        }</span>
        <span class="cov0" title="0">if target.RoutingNumber != "" </span><span class="cov0" title="0">{
                return maskString(target.RoutingNumber)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func maskString(s string) string <span class="cov8" title="1">{
        if len(s) &lt;= 4 </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov8" title="1">return strings.Repeat("*", len(s)-4) + s[len(s)-4:]</span>
}

// Handle executes the withdraw domain operation
func (h *WithdrawOperationHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger.With("operation", "withdraw")

        // Enforce that ExternalTarget is present for withdrawals
        if req.ExternalTarget == nil || (req.ExternalTarget.BankAccountNumber == "" &amp;&amp; req.ExternalTarget.RoutingNumber == "" &amp;&amp; req.ExternalTarget.ExternalWalletAddress == "") </span><span class="cov0" title="0">{
                logger.Error("WithdrawOperationHandler: missing or invalid external target")
                return &amp;OperationResponse{Error: account.ErrAccountNotFound}, nil // Use a more specific error if desired
        }</span>
        <span class="cov8" title="1">logger.Info("WithdrawOperationHandler: external target details", "bank_account_number", req.ExternalTarget.BankAccountNumber, "routing_number", req.ExternalTarget.RoutingNumber, "external_wallet_address", req.ExternalTarget.ExternalWalletAddress)
        req.ExternalTargetMasked = maskExternalTarget(req.ExternalTarget)

        err := req.Account.Withdraw(req.UserID, req.ConvertedMoney, *req.ExternalTarget, req.PaymentID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("WithdrawOperationHandler failed: domain operation error", "error", err)
                return &amp;OperationResponse{Error: err}, nil
        }</span>
        <span class="cov8" title="1">req.Amount = req.ConvertedMoney.Negate().AmountFloat()

        logger.Info("WithdrawOperationHandler: domain operation completed")
        return h.BaseHandler.Handle(ctx, req)</span>
}

// TransferOperationHandler executes transfer domain operations
type TransferOperationHandler struct {
        BaseHandler
        logger *slog.Logger
}

// Handle executes the transfer domain operation
func (h *TransferOperationHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger.With("operation", "transfer")

        err := req.Account.Transfer(req.UserID, req.DestUserID, req.DestAccount, req.ConvertedMoney, account.MoneySourceInternal)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("TransferOperationHandler failed: domain operation error", "error", err)
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">logger.Info("TransferOperationHandler: domain operation completed")
        return h.BaseHandler.Handle(ctx, req)</span>
}
</pre>

		<pre class="file" id="file28" style="display: none">package handler

import (
        "time"

        "github.com/amirasaad/fintech/pkg/currency"
        account "github.com/amirasaad/fintech/pkg/domain/account"
        money "github.com/amirasaad/fintech/pkg/domain/money"
        "github.com/google/uuid"
)

// NewDepositTransaction creates a deposit transaction record
func NewDepositTransaction(e account.DepositRequestedEvent) *account.Transaction <span class="cov8" title="1">{
        moneyVal, _ := money.New(e.Amount, currency.Code(e.Currency))
        return &amp;account.Transaction{
                ID:          uuid.New(),
                AccountID:   uuid.MustParse(e.AccountID),
                UserID:      uuid.MustParse(e.UserID),
                PaymentID:   e.PaymentID,
                Amount:      moneyVal,
                MoneySource: e.Source,
                Status:      account.TransactionStatusInitiated,
                CreatedAt:   time.Now().UTC(),
        }
}</span>

// NewWithdrawTransaction creates a withdrawal transaction record
func NewWithdrawTransaction(e account.WithdrawRequestedEvent, extTarget *account.ExternalTarget) *account.Transaction <span class="cov8" title="1">{
        moneyVal, _ := money.New(e.Amount, currency.Code(e.Currency))
        return &amp;account.Transaction{
                ID:             uuid.New(),
                AccountID:      uuid.MustParse(e.AccountID),
                UserID:         uuid.MustParse(e.UserID),
                PaymentID:      e.PaymentID,
                Amount:         moneyVal.Negate(), // NEGATE for withdraw
                Status:         account.TransactionStatusInitiated,
                ExternalTarget: account.ExternalTarget(*extTarget),
                CreatedAt:      time.Now().UTC(),
        }
}</span>

// NewTransferTransactions creates both outgoing and incoming transfer transaction records
func NewTransferTransactions(e account.TransferRequestedEvent) (outTx, inTx *account.Transaction) <span class="cov8" title="1">{
        moneyVal, _ := money.New(e.Amount, currency.Code(e.Currency))
        outTx = &amp;account.Transaction{
                ID:          uuid.New(),
                AccountID:   e.SourceAccountID,
                UserID:      e.SenderUserID,
                Amount:      moneyVal.Negate(),
                MoneySource: e.Source,
                Status:      account.TransactionStatusInitiated,
                CreatedAt:   time.Now().UTC(),
        }
        inTx = &amp;account.Transaction{
                ID:          uuid.New(),
                AccountID:   e.DestAccountID,
                UserID:      e.ReceiverUserID,
                Amount:      moneyVal,
                MoneySource: e.Source,
                Status:      account.TransactionStatusInitiated,
                CreatedAt:   time.Now().UTC(),
        }
        return
}</span>
</pre>

		<pre class="file" id="file29" style="display: none">package handler

import (
        "context"
        "log/slog"

        account "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/repository"
)

// TransferPersistenceHandler handles the persistence of transfer operations.
// It updates both source and destination account balances and creates both transaction records.
type TransferPersistenceHandler struct {
        BaseHandler
        uow    repository.UnitOfWork
        logger *slog.Logger
}

// Handle processes transfer events, updates both accounts, and creates both transaction records.
func (h *TransferPersistenceHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger
        events := req.Account.PullEvents()
        var transactions []*account.Transaction
        var transactionOut *account.Transaction
        var transactionIn *account.Transaction

        if len(events) == 0 </span><span class="cov0" title="0">{
                logger.Error("TransferPersistenceHandler: no events found on account")
                return &amp;OperationResponse{Error: context.Canceled}, nil
        }</span>

        <span class="cov8" title="1">if err := h.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("TransferPersistenceHandler failed: AccountRepository error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">txRepo, err := uow.TransactionRepository()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("TransferPersistenceHandler failed: TransactionRepository error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">for _, evt := range events </span><span class="cov8" title="1">{
                        e, ok := evt.(account.TransferRequestedEvent) //nolint:go-critic
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Replace inline transaction construction with factory helper
                        <span class="cov8" title="1">transactionOut, transactionIn = NewTransferTransactions(e)
                        if err := txRepo.Create(transactionOut, req.ConvInfo, ""); err != nil </span><span class="cov0" title="0">{
                                logger.Error("TransferPersistenceHandler failed: outgoing transaction create error", "error", err)
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := txRepo.Create(transactionIn, req.ConvInfo, ""); err != nil </span><span class="cov0" title="0">{
                                logger.Error("TransferPersistenceHandler failed: incoming transaction create error", "error", err)
                                return err
                        }</span>
                        <span class="cov8" title="1">transactions = append(transactions, transactionOut, transactionIn)

                        // Unified balance update for transfer
                        sourceAcc, err := repo.Get(e.SourceAccountID)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("TransferPersistenceHandler failed: source account fetch error", "error", err)
                                return err
                        }</span>
                        <span class="cov8" title="1">destAcc, err := repo.Get(e.DestAccountID)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("TransferPersistenceHandler failed: destination account fetch error", "error", err)
                                return err
                        }</span>
                        <span class="cov8" title="1">sourceAcc.Balance, err = sourceAcc.Balance.Subtract(transactionOut.Amount)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("TransferPersistenceHandler failed: source balance update error", "error", err)
                                return err
                        }</span>
                        <span class="cov8" title="1">destAcc.Balance, err = destAcc.Balance.Add(transactionIn.Amount)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("TransferPersistenceHandler failed: destination balance update error", "error", err)
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := repo.Update(sourceAcc); err != nil </span><span class="cov0" title="0">{
                                logger.Error("TransferPersistenceHandler failed: source account update error", "error", err)
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := repo.Update(destAcc); err != nil </span><span class="cov0" title="0">{
                                logger.Error("TransferPersistenceHandler failed: destination account update error", "error", err)
                                return err
                        }</span>
                        // End unified balance update
                }
                <span class="cov8" title="1">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">logger.Info("TransferPersistenceHandler: persistence completed successfully")

        return &amp;OperationResponse{
                Transactions:   transactions,
                TransactionOut: transactionOut,
                TransactionIn:  transactionIn,
                ConvInfo:       req.ConvInfo,
        }, nil</span>
}
</pre>

		<pre class="file" id="file30" style="display: none">package handler

import (
        "context"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/repository"
)

// ValidationHandler validates that the account exists and belongs to the user
type ValidationHandler struct {
        BaseHandler
        uow    repository.UnitOfWork
        logger *slog.Logger
}

// Handle validates the account and passes the request to the next handler
func (h *ValidationHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger.With("userID", req.UserID, "accountID", req.AccountID)
        logger.Info("AccountValidationHandler: starting")

        repo, err := h.uow.AccountRepository()
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("AccountValidationHandler failed: repository error", "error", err)
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">acc, err := repo.Get(req.AccountID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("AccountValidationHandler failed: account not found", "error", err)
                return &amp;OperationResponse{Error: account.ErrAccountNotFound}, nil
        }</span>

        <span class="cov8" title="1">if acc.UserID != req.UserID </span><span class="cov0" title="0">{
                logger.Error("AccountValidationHandler failed: user unauthorized", "accountUserID", acc.UserID)
                return &amp;OperationResponse{Error: user.ErrUserUnauthorized}, nil
        }</span>

        <span class="cov8" title="1">req.Account = acc
        logger.Info("AccountValidationHandler: account validated successfully")

        return h.BaseHandler.Handle(ctx, req)</span>
}

// TransferValidationHandler validates both source and destination accounts for transfers
type TransferValidationHandler struct {
        BaseHandler
        uow    repository.UnitOfWork
        logger *slog.Logger
}

// Handle validates both accounts and passes the request to the next handler
func (h *TransferValidationHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger.With("userID", req.UserID, "sourceAccountID", req.AccountID, "destAccountID", req.DestAccountID)
        logger.Info("TransferValidationHandler: starting")

        repo, err := h.uow.AccountRepository()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("TransferValidationHandler failed: repository error", "error", err)
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        // Get and validate source account
        <span class="cov8" title="1">sourceAccount, err := repo.Get(req.AccountID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("TransferValidationHandler failed: source account not found", "error", err)
                return &amp;OperationResponse{Error: account.ErrAccountNotFound}, nil
        }</span>

        <span class="cov8" title="1">if sourceAccount.UserID != req.UserID </span><span class="cov0" title="0">{
                logger.Error("TransferValidationHandler failed: user unauthorized for source account", "accountUserID", sourceAccount.UserID)
                return &amp;OperationResponse{Error: user.ErrUserUnauthorized}, nil
        }</span>

        // Get and validate destination account
        <span class="cov8" title="1">destAccount, err := repo.Get(req.DestAccountID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("TransferValidationHandler failed: destination account not found", "error", err)
                return &amp;OperationResponse{Error: account.ErrAccountNotFound}, nil
        }</span>

        <span class="cov8" title="1">req.Account = sourceAccount
        req.DestAccount = destAccount
        logger.Info("TransferValidationHandler: both accounts validated successfully")

        return h.BaseHandler.Handle(ctx, req)</span>
}
</pre>

		<pre class="file" id="file31" style="display: none">package handler

import (
        "context"
        "log/slog"

        account "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/repository"
)

// WithdrawPersistenceHandler handles the persistence of withdraw operations.
// It updates the account and creates the withdrawal transaction record.
type WithdrawPersistenceHandler struct {
        BaseHandler
        uow    repository.UnitOfWork
        logger *slog.Logger
}

// Handle processes withdraw events, updates the account, and creates the withdrawal transaction record.
func (h *WithdrawPersistenceHandler) Handle(ctx context.Context, req *OperationRequest) (*OperationResponse, error) <span class="cov8" title="1">{
        logger := h.logger
        events := req.Account.PullEvents()
        var transactions []*account.Transaction

        if len(events) == 0 </span><span class="cov0" title="0">{
                logger.Error("WithdrawPersistenceHandler: no events found on account")
                return &amp;OperationResponse{Error: context.Canceled}, nil
        }</span>

        <span class="cov8" title="1">if err := h.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("WithdrawPersistenceHandler failed: AccountRepository error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">if err = repo.Update(req.Account); err != nil </span><span class="cov0" title="0">{
                        logger.Error("WithdrawPersistenceHandler failed: account update error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">txRepo, err := uow.TransactionRepository()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("WithdrawPersistenceHandler failed: TransactionRepository error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">for _, evt := range events </span><span class="cov8" title="1">{
                        e, ok := evt.(account.WithdrawRequestedEvent) //nolint:go-critic
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Replace inline transaction construction with factory helper
                        <span class="cov8" title="1">tx := NewWithdrawTransaction(e, req.ExternalTarget)
                        if err := txRepo.Create(tx, req.ConvInfo, maskExternalTarget(req.ExternalTarget)); err != nil </span><span class="cov0" title="0">{
                                logger.Error("WithdrawPersistenceHandler failed: transaction create error", "error", err)
                                return err
                        }</span>
                        <span class="cov8" title="1">transactions = append(transactions, tx)</span>
                }
                <span class="cov8" title="1">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                return &amp;OperationResponse{Error: err}, nil
        }</span>

        <span class="cov8" title="1">logger.Info("WithdrawPersistenceHandler: persistence completed successfully")

        return &amp;OperationResponse{
                Transactions: transactions,
                ConvInfo:     req.ConvInfo,
        }, nil</span>
}
</pre>

		<pre class="file" id="file32" style="display: none">package middleware

import (
        "github.com/amirasaad/fintech/pkg/config"
        jwtware "github.com/gofiber/contrib/jwt"
        "github.com/gofiber/fiber/v2"
)

// JwtProtected protect routes
func JwtProtected(cfg config.JwtConfig) fiber.Handler <span class="cov8" title="1">{
        return jwtware.New(jwtware.Config{
                SigningKey:   jwtware.SigningKey{Key: []byte(cfg.Secret)},
                ErrorHandler: jwtError,
        })
}</span>

func jwtError(c *fiber.Ctx, err error) error <span class="cov8" title="1">{
        if err.Error() == "Missing or malformed JWT" </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusBadRequest).
                        JSON(fiber.Map{"status": "error", "message": "Missing or malformed JWT", "data": nil})

        }</span>
        <span class="cov8" title="1">return c.Status(fiber.StatusUnauthorized).
                JSON(fiber.Map{"status": "error", "message": "Invalid or expired JWT", "data": nil})</span>
}
</pre>

		<pre class="file" id="file33" style="display: none">package registry

import (
        "context"
        "fmt"
        "sync"
        "time"
)

// EnhancedRegistry provides a full-featured registry implementation
type EnhancedRegistry struct {
        config      RegistryConfig
        entities    map[string]Entity
        mu          sync.RWMutex
        observers   []RegistryObserver
        validator   RegistryValidator
        cache       RegistryCache
        persistence RegistryPersistence
        metrics     RegistryMetrics
        health      RegistryHealth
        eventBus    RegistryEventBus
}

// NewEnhancedRegistry creates a new enhanced registry
func NewEnhancedRegistry(config RegistryConfig) *EnhancedRegistry <span class="cov8" title="1">{
        return &amp;EnhancedRegistry{
                config:    config,
                entities:  make(map[string]Entity),
                observers: make([]RegistryObserver, 0),
        }
}</span>

// WithValidator sets the validator for the registry
func (r *EnhancedRegistry) WithValidator(validator RegistryValidator) *EnhancedRegistry <span class="cov8" title="1">{
        r.validator = validator
        return r
}</span>

// WithCache sets the cache for the registry
func (r *EnhancedRegistry) WithCache(cache RegistryCache) *EnhancedRegistry <span class="cov8" title="1">{
        r.cache = cache
        return r
}</span>

// WithPersistence sets the persistence layer for the registry
func (r *EnhancedRegistry) WithPersistence(persistence RegistryPersistence) *EnhancedRegistry <span class="cov0" title="0">{
        r.persistence = persistence
        return r
}</span>

// WithMetrics sets the metrics collector for the registry
func (r *EnhancedRegistry) WithMetrics(metrics RegistryMetrics) *EnhancedRegistry <span class="cov8" title="1">{
        r.metrics = metrics
        return r
}</span>

// WithHealth sets the health checker for the registry
func (r *EnhancedRegistry) WithHealth(health RegistryHealth) *EnhancedRegistry <span class="cov0" title="0">{
        r.health = health
        return r
}</span>

// WithEventBus sets the event bus for the registry
func (r *EnhancedRegistry) WithEventBus(eventBus RegistryEventBus) *EnhancedRegistry <span class="cov8" title="1">{
        r.eventBus = eventBus
        return r
}</span>

// Register adds or updates an entity in the registry
func (r *EnhancedRegistry) Register(ctx context.Context, entity Entity) error <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if r.metrics != nil </span><span class="cov8" title="1">{
                        r.metrics.RecordLatency("register", time.Since(start))
                }</span>
        }()

        // Validate entity if validator is set
        <span class="cov8" title="1">if r.validator != nil </span><span class="cov8" title="1">{
                if err := r.validator.Validate(ctx, entity); err != nil </span><span class="cov8" title="1">{
                        if r.metrics != nil </span><span class="cov0" title="0">{
                                r.metrics.IncrementError()
                        }</span>
                        <span class="cov8" title="1">return fmt.Errorf("validation failed: %w", err)</span>
                }
        }

        // Check max entities limit
        <span class="cov8" title="1">if r.config.MaxEntities &gt; 0 </span><span class="cov0" title="0">{
                r.mu.RLock()
                currentCount := len(r.entities)
                r.mu.RUnlock()
                if currentCount &gt;= r.config.MaxEntities </span><span class="cov0" title="0">{
                        if r.metrics != nil </span><span class="cov0" title="0">{
                                r.metrics.IncrementError()
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("registry is full (max entities: %d)", r.config.MaxEntities)</span>
                }
        }

        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()

        // Check if entity already exists
        _, exists := r.entities[entity.ID()]
        r.entities[entity.ID()] = entity

        // Update cache if available
        if r.cache != nil </span><span class="cov8" title="1">{
                r.cache.Set(ctx, entity) //nolint:errcheck
        }</span>

        // Update metrics
        <span class="cov8" title="1">if r.metrics != nil </span><span class="cov8" title="1">{
                r.metrics.IncrementRegistration()
                r.metrics.SetEntityCount(len(r.entities))
                if entity.Active() </span><span class="cov8" title="1">{
                        activeCount := r.countActiveLocked()
                        r.metrics.SetActiveCount(activeCount)
                }</span>
        }

        // Publish event
        <span class="cov8" title="1">if r.eventBus != nil </span><span class="cov8" title="1">{
                eventType := EventEntityRegistered
                if exists </span><span class="cov0" title="0">{
                        eventType = EventEntityUpdated
                }</span>
                <span class="cov8" title="1">event := RegistryEvent{
                        Type:      eventType,
                        EntityID:  entity.ID(),
                        Entity:    entity,
                        Timestamp: time.Now(),
                }
                r.eventBus.Publish(ctx, event)</span> //nolint:errcheck
        }

        // Notify observers
        <span class="cov8" title="1">for _, observer := range r.observers </span><span class="cov0" title="0">{
                if exists </span><span class="cov0" title="0">{
                        observer.OnEntityUpdated(ctx, entity)
                }</span> else<span class="cov0" title="0"> {
                        observer.OnEntityRegistered(ctx, entity)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Get retrieves an entity by ID
func (r *EnhancedRegistry) Get(ctx context.Context, id string) (Entity, error) <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if r.metrics != nil </span><span class="cov8" title="1">{
                        r.metrics.RecordLatency("get", time.Since(start))
                }</span>
        }()

        // Try cache first
        <span class="cov8" title="1">if r.cache != nil </span><span class="cov0" title="0">{
                if entity, found := r.cache.Get(ctx, id); found </span><span class="cov0" title="0">{
                        if r.metrics != nil </span><span class="cov0" title="0">{
                                r.metrics.IncrementLookup()
                        }</span>
                        <span class="cov0" title="0">return entity, nil</span>
                }
        }

        <span class="cov8" title="1">r.mu.RLock()
        entity, exists := r.entities[id]
        r.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                if r.metrics != nil </span><span class="cov0" title="0">{
                        r.metrics.IncrementError()
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("entity not found: %s", id)</span>
        }

        // Update cache
        <span class="cov8" title="1">if r.cache != nil </span><span class="cov0" title="0">{
                r.cache.Set(ctx, entity) //nolint:errcheck
        }</span>

        <span class="cov8" title="1">if r.metrics != nil </span><span class="cov8" title="1">{
                r.metrics.IncrementLookup()
        }</span>

        <span class="cov8" title="1">return entity, nil</span>
}

// Unregister removes an entity from the registry
func (r *EnhancedRegistry) Unregister(ctx context.Context, id string) error <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if r.metrics != nil </span><span class="cov8" title="1">{
                        r.metrics.RecordLatency("unregister", time.Since(start))
                }</span>
        }()

        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.entities[id]; !exists </span><span class="cov0" title="0">{
                if r.metrics != nil </span><span class="cov0" title="0">{
                        r.metrics.IncrementError()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("entity not found: %s", id)</span>
        }

        <span class="cov8" title="1">delete(r.entities, id)

        // Remove from cache
        if r.cache != nil </span><span class="cov0" title="0">{
                r.cache.Delete(ctx, id) //nolint:errcheck
        }</span>

        // Update metrics
        <span class="cov8" title="1">if r.metrics != nil </span><span class="cov8" title="1">{
                r.metrics.IncrementUnregistration()
                r.metrics.SetEntityCount(len(r.entities))
                activeCount := r.countActiveLocked()
                r.metrics.SetActiveCount(activeCount)
        }</span>

        // Publish event
        <span class="cov8" title="1">if r.eventBus != nil </span><span class="cov8" title="1">{
                event := RegistryEvent{
                        Type:      EventEntityUnregistered,
                        EntityID:  id,
                        Timestamp: time.Now(),
                }
                r.eventBus.Publish(ctx, event) //nolint:errcheck
        }</span>

        // Notify observers
        <span class="cov8" title="1">for _, observer := range r.observers </span><span class="cov0" title="0">{
                observer.OnEntityUnregistered(ctx, id)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsRegistered checks if an entity is registered
func (r *EnhancedRegistry) IsRegistered(ctx context.Context, id string) bool <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        _, exists := r.entities[id]
        return exists
}</span>

// List returns all entities
func (r *EnhancedRegistry) List(ctx context.Context) ([]Entity, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0, len(r.entities))
        for _, entity := range r.entities </span><span class="cov8" title="1">{
                entities = append(entities, entity)
        }</span>
        <span class="cov8" title="1">return entities, nil</span>
}

// ListActive returns all active entities
func (r *EnhancedRegistry) ListActive(ctx context.Context) ([]Entity, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0)
        for _, entity := range r.entities </span><span class="cov0" title="0">{
                if entity.Active() </span><span class="cov0" title="0">{
                        entities = append(entities, entity)
                }</span>
        }
        <span class="cov0" title="0">return entities, nil</span>
}

// ListByMetadata returns entities with specific metadata
func (r *EnhancedRegistry) ListByMetadata(ctx context.Context, key, value string) ([]Entity, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0)
        for _, entity := range r.entities </span><span class="cov0" title="0">{
                if metadata := entity.Metadata(); metadata != nil </span><span class="cov0" title="0">{
                        if val, exists := metadata[key]; exists &amp;&amp; val == value </span><span class="cov0" title="0">{
                                entities = append(entities, entity)
                        }</span>
                }
        }
        <span class="cov0" title="0">return entities, nil</span>
}

// Count returns the total number of entities
func (r *EnhancedRegistry) Count(ctx context.Context) (int, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return len(r.entities), nil
}</span>

// CountActive returns the number of active entities
func (r *EnhancedRegistry) CountActive(ctx context.Context) (int, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.countActiveLocked(), nil
}</span>

// countActiveLocked is a helper method that assumes the lock is already held
func (r *EnhancedRegistry) countActiveLocked() int <span class="cov8" title="1">{
        count := 0
        for _, entity := range r.entities </span><span class="cov8" title="1">{
                if entity.Active() </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// GetMetadata retrieves specific metadata for an entity
func (r *EnhancedRegistry) GetMetadata(ctx context.Context, id, key string) (string, error) <span class="cov8" title="1">{
        entity, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">metadata := entity.Metadata()
        if val, exists := metadata[key]; exists </span><span class="cov8" title="1">{
                return val, nil
        }</span>

        <span class="cov8" title="1">return "", fmt.Errorf("metadata key not found: %s", key)</span>
}

// SetMetadata sets specific metadata for an entity
func (r *EnhancedRegistry) SetMetadata(ctx context.Context, id, key, value string) error <span class="cov8" title="1">{
        entity, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate metadata if validator is set
        <span class="cov8" title="1">if r.validator != nil </span><span class="cov0" title="0">{
                metadata := entity.Metadata()
                metadata[key] = value
                if err := r.validator.ValidateMetadata(ctx, metadata); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("metadata validation failed: %w", err)
                }</span>
        }

        // Update the entity's metadata
        <span class="cov8" title="1">metadata := entity.Metadata()
        metadata[key] = value

        // Re-register the entity to update it
        return r.Register(ctx, entity)</span>
}

// RemoveMetadata removes specific metadata from an entity
func (r *EnhancedRegistry) RemoveMetadata(ctx context.Context, id, key string) error <span class="cov8" title="1">{
        entity, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">metadata := entity.Metadata()
        delete(metadata, key)

        // Re-register the entity to update it
        return r.Register(ctx, entity)</span>
}

// Activate activates an entity
func (r *EnhancedRegistry) Activate(ctx context.Context, id string) error <span class="cov0" title="0">{
        entity, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create a new entity with active status
        // Note: This is a simplified approach - in a real implementation,
        // you might want to make the Entity interface mutable or use a different approach
        <span class="cov0" title="0">baseEntity := &amp;BaseEntity{
                BEId:        entity.ID(),
                BEName:      entity.Name(),
                BEActive:    true,
                BEMetadata:  entity.Metadata(),
                BECreatedAt: entity.CreatedAt(),
                BEUpdatedAt: entity.UpdatedAt(),
        }

        return r.Register(ctx, baseEntity)</span>
}

// Deactivate deactivates an entity
func (r *EnhancedRegistry) Deactivate(ctx context.Context, id string) error <span class="cov0" title="0">{
        entity, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create a new entity with inactive status
        <span class="cov0" title="0">baseEntity := &amp;BaseEntity{
                BEId:        entity.ID(),
                BEName:      entity.Name(),
                BEActive:    false,
                BEMetadata:  entity.Metadata(),
                BECreatedAt: entity.CreatedAt(),
                BEUpdatedAt: entity.UpdatedAt(),
        }

        return r.Register(ctx, baseEntity)</span>
}

// Search performs a simple search on entity names
func (r *EnhancedRegistry) Search(ctx context.Context, query string) ([]Entity, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0)
        for _, entity := range r.entities </span><span class="cov8" title="1">{
                if contains(entity.Name(), query) </span><span class="cov8" title="1">{
                        entities = append(entities, entity)
                }</span>
        }
        <span class="cov8" title="1">return entities, nil</span>
}

// SearchByMetadata searches entities by metadata
func (r *EnhancedRegistry) SearchByMetadata(ctx context.Context, metadata map[string]string) ([]Entity, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0)
        for _, entity := range r.entities </span><span class="cov8" title="1">{
                entityMetadata := entity.Metadata()
                matches := true
                for key, value := range metadata </span><span class="cov8" title="1">{
                        if val, exists := entityMetadata[key]; !exists || val != value </span><span class="cov8" title="1">{
                                matches = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if matches </span><span class="cov8" title="1">{
                        entities = append(entities, entity)
                }</span>
        }
        <span class="cov8" title="1">return entities, nil</span>
}

// AddObserver adds an observer to the registry
func (r *EnhancedRegistry) AddObserver(observer RegistryObserver) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.observers = append(r.observers, observer)
}</span>

// RemoveObserver removes an observer from the registry
func (r *EnhancedRegistry) RemoveObserver(observer RegistryObserver) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        for i, obs := range r.observers </span><span class="cov0" title="0">{
                if obs == observer </span><span class="cov0" title="0">{
                        r.observers = append(r.observers[:i], r.observers[i+1:]...)
                        break</span>
                }
        }
}

// contains is a helper function for string search
func contains(s, substr string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr ||
                (len(s) &gt; len(substr) &amp;&amp; (s[:len(substr)] == substr ||
                        s[len(s)-len(substr):] == substr ||
                        containsSubstring(s, substr))))
}</span>

// containsSubstring is a helper function for substring search
func containsSubstring(s, substr string) bool <span class="cov8" title="1">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>

		<pre class="file" id="file34" style="display: none">package registry

import (
        "context"
        "fmt"
        "time"
)

// RegistryFactoryImpl implements RegistryFactory
type RegistryFactoryImpl struct{}

// NewRegistryFactory creates a new registry factory
func NewRegistryFactory() RegistryFactory <span class="cov8" title="1">{
        return &amp;RegistryFactoryImpl{}
}</span>

// Create creates a basic registry with the given configuration
func (f *RegistryFactoryImpl) Create(ctx context.Context, config RegistryConfig) (RegistryProvider, error) <span class="cov8" title="1">{
        registry := NewEnhancedRegistry(config)

        // Add default implementations if not provided
        if config.EnableValidation </span><span class="cov8" title="1">{
                registry.WithValidator(NewSimpleValidator())
        }</span>

        <span class="cov8" title="1">if config.CacheSize &gt; 0 </span><span class="cov8" title="1">{
                registry.WithCache(NewMemoryCache(config.CacheTTL))
        }</span>

        <span class="cov8" title="1">if config.EnableEvents </span><span class="cov8" title="1">{
                registry.WithEventBus(NewSimpleEventBus())
        }</span>

        <span class="cov8" title="1">return registry, nil</span>
}

// CreateWithPersistence creates a registry with persistence
func (f *RegistryFactoryImpl) CreateWithPersistence(ctx context.Context, config RegistryConfig, persistence RegistryPersistence) (RegistryProvider, error) <span class="cov0" title="0">{
        registry := NewEnhancedRegistry(config)

        // Add persistence
        registry.WithPersistence(persistence)

        // Load existing entities
        if entities, err := persistence.Load(ctx); err == nil </span><span class="cov0" title="0">{
                for _, entity := range entities </span><span class="cov0" title="0">{
                        if err := registry.Register(ctx, entity); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to load entity %s: %w", entity.ID(), err)
                        }</span>
                }
        }

        // Add other default implementations
        <span class="cov0" title="0">if config.EnableValidation </span><span class="cov0" title="0">{
                registry.WithValidator(NewSimpleValidator())
        }</span>

        <span class="cov0" title="0">if config.CacheSize &gt; 0 </span><span class="cov0" title="0">{
                registry.WithCache(NewMemoryCache(config.CacheTTL))
        }</span>

        <span class="cov0" title="0">if config.EnableEvents </span><span class="cov0" title="0">{
                registry.WithEventBus(NewSimpleEventBus())
        }</span>

        <span class="cov0" title="0">return registry, nil</span>
}

// CreateWithCache creates a registry with custom cache
func (f *RegistryFactoryImpl) CreateWithCache(ctx context.Context, config RegistryConfig, cache RegistryCache) (RegistryProvider, error) <span class="cov0" title="0">{
        registry := NewEnhancedRegistry(config)

        // Add custom cache
        registry.WithCache(cache)

        // Add other default implementations
        if config.EnableValidation </span><span class="cov0" title="0">{
                registry.WithValidator(NewSimpleValidator())
        }</span>

        <span class="cov0" title="0">if config.EnableEvents </span><span class="cov0" title="0">{
                registry.WithEventBus(NewSimpleEventBus())
        }</span>

        <span class="cov0" title="0">return registry, nil</span>
}

// CreateWithMetrics creates a registry with metrics
func (f *RegistryFactoryImpl) CreateWithMetrics(ctx context.Context, config RegistryConfig, metrics RegistryMetrics) (RegistryProvider, error) <span class="cov8" title="1">{
        registry := NewEnhancedRegistry(config)

        // Add metrics
        registry.WithMetrics(metrics)

        // Add other default implementations
        if config.EnableValidation </span><span class="cov8" title="1">{
                registry.WithValidator(NewSimpleValidator())
        }</span>

        <span class="cov8" title="1">if config.CacheSize &gt; 0 </span><span class="cov8" title="1">{
                registry.WithCache(NewMemoryCache(config.CacheTTL))
        }</span>

        <span class="cov8" title="1">if config.EnableEvents </span><span class="cov8" title="1">{
                registry.WithEventBus(NewSimpleEventBus())
        }</span>

        <span class="cov8" title="1">return registry, nil</span>
}

// CreateFullFeatured creates a registry with all features enabled
func (f *RegistryFactoryImpl) CreateFullFeatured(ctx context.Context, config RegistryConfig) (RegistryProvider, error) <span class="cov0" title="0">{
        registry := NewEnhancedRegistry(config)

        // Add all implementations
        registry.WithValidator(NewSimpleValidator())
        registry.WithCache(NewMemoryCache(config.CacheTTL))
        registry.WithMetrics(NewSimpleMetrics())
        registry.WithHealth(NewSimpleHealth())
        registry.WithEventBus(NewSimpleEventBus())

        // Add persistence if enabled
        if config.EnablePersistence </span><span class="cov0" title="0">{
                persistence := NewFilePersistence(config.PersistencePath)
                registry.WithPersistence(persistence)

                // Load existing entities
                if entities, err := persistence.Load(ctx); err == nil </span><span class="cov0" title="0">{
                        for _, entity := range entities </span><span class="cov0" title="0">{
                                if err := registry.Register(ctx, entity); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to load entity %s: %w", entity.ID(), err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return registry, nil</span>
}

// CreateForTesting creates a registry optimized for testing
func (f *RegistryFactoryImpl) CreateForTesting(ctx context.Context) (RegistryProvider, error) <span class="cov0" title="0">{
        config := RegistryConfig{
                Name:             "test-registry",
                MaxEntities:      1000,
                EnableEvents:     false,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }

        registry := NewEnhancedRegistry(config)
        registry.WithValidator(NewSimpleValidator())

        return registry, nil
}</span>

// CreateForProduction creates a registry optimized for production use
func (f *RegistryFactoryImpl) CreateForProduction(ctx context.Context, name string, persistencePath string) (RegistryProvider, error) <span class="cov0" title="0">{
        config := RegistryConfig{
                Name:              name,
                MaxEntities:       10000,
                EnableEvents:      true,
                EnableValidation:  true,
                CacheSize:         1000,
                CacheTTL:          5 * time.Minute,
                EnablePersistence: true,
                PersistencePath:   persistencePath,
                AutoSaveInterval:  30 * time.Second,
        }

        return f.CreateFullFeatured(ctx, config)
}</span>

// CreateForDevelopment creates a registry optimized for development
func (f *RegistryFactoryImpl) CreateForDevelopment(ctx context.Context, name string) (RegistryProvider, error) <span class="cov0" title="0">{
        config := RegistryConfig{
                Name:             name,
                MaxEntities:      1000,
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }

        registry := NewEnhancedRegistry(config)
        registry.WithValidator(NewSimpleValidator())
        registry.WithMetrics(NewSimpleMetrics())
        registry.WithEventBus(NewSimpleEventBus())

        return registry, nil
}</span>

// Convenience functions for common registry creation patterns

// NewBasicRegistry creates a basic registry with default settings
func NewBasicRegistry() RegistryProvider <span class="cov8" title="1">{
        factory := NewRegistryFactory()
        config := RegistryConfig{
                Name:             "basic-registry",
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }

        registry, _ := factory.Create(context.Background(), config)
        return registry
}</span>

// NewPersistentRegistry creates a registry with file persistence
func NewPersistentRegistry(filePath string) (RegistryProvider, error) <span class="cov0" title="0">{
        factory := NewRegistryFactory()
        config := RegistryConfig{
                Name:              "persistent-registry",
                EnableEvents:      true,
                EnableValidation:  true,
                CacheSize:         100,
                CacheTTL:          time.Minute,
                EnablePersistence: true,
                PersistencePath:   filePath,
                AutoSaveInterval:  time.Minute,
        }

        persistence := NewFilePersistence(filePath)
        return factory.CreateWithPersistence(context.Background(), config, persistence)
}</span>

// NewCachedRegistry creates a registry with enhanced caching
func NewCachedRegistry(cacheSize int, cacheTTL time.Duration) RegistryProvider <span class="cov0" title="0">{
        factory := NewRegistryFactory()
        config := RegistryConfig{
                Name:             "cached-registry",
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        cacheSize,
                CacheTTL:         cacheTTL,
        }

        registry, _ := factory.Create(context.Background(), config)
        return registry
}</span>

// NewMonitoredRegistry creates a registry with metrics and monitoring
func NewMonitoredRegistry(name string) RegistryProvider <span class="cov8" title="1">{
        factory := NewRegistryFactory()
        config := RegistryConfig{
                Name:             name,
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }

        metrics := NewSimpleMetrics()
        registry, _ := factory.CreateWithMetrics(context.Background(), config, metrics)
        return registry
}</span>

// BuildRegistry creates a registry with the built configuration
func (b *RegistryBuilder) BuildRegistry() (RegistryProvider, error) <span class="cov8" title="1">{
        factory := NewRegistryFactory()
        return factory.Create(context.Background(), b.Build())
}</span>
</pre>

		<pre class="file" id="file35" style="display: none">package registry

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "sync"
        "time"
)

// MemoryCache implements RegistryCache using in-memory storage
type MemoryCache struct {
        cache map[string]cacheEntry
        mu    sync.RWMutex
        ttl   time.Duration
}

type cacheEntry struct {
        entity    Entity
        expiresAt time.Time
}

// NewMemoryCache creates a new memory cache
func NewMemoryCache(ttl time.Duration) *MemoryCache <span class="cov8" title="1">{
        cache := &amp;MemoryCache{
                cache: make(map[string]cacheEntry),
                ttl:   ttl,
        }

        // Start cleanup goroutine
        go cache.cleanup()

        return cache
}</span>

// Get retrieves an entity from cache
func (c *MemoryCache) Get(ctx context.Context, id string) (Entity, bool) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        entry, exists := c.cache[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Check if expired
        <span class="cov8" title="1">if time.Now().After(entry.expiresAt) </span><span class="cov8" title="1">{
                delete(c.cache, id)
                return nil, false
        }</span>

        <span class="cov8" title="1">return entry.entity, true</span>
}

// Set stores an entity in cache
func (c *MemoryCache) Set(ctx context.Context, entity Entity) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.cache[entity.ID()] = cacheEntry{
                entity:    entity,
                expiresAt: time.Now().Add(c.ttl),
        }

        return nil
}</span>

// Delete removes an entity from cache
func (c *MemoryCache) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.cache, id)
        return nil
}</span>

// Clear removes all entities from cache
func (c *MemoryCache) Clear(ctx context.Context) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.cache = make(map[string]cacheEntry)
        return nil
}</span>

// Size returns the number of cached entities
func (c *MemoryCache) Size() int <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        return len(c.cache)
}</span>

// cleanup removes expired entries
func (c *MemoryCache) cleanup() <span class="cov8" title="1">{
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                c.mu.Lock()
                now := time.Now()
                for id, entry := range c.cache </span><span class="cov0" title="0">{
                        if now.After(entry.expiresAt) </span><span class="cov0" title="0">{
                                delete(c.cache, id)
                        }</span>
                }
                <span class="cov0" title="0">c.mu.Unlock()</span>
        }
}

// FilePersistence implements RegistryPersistence using file storage
type FilePersistence struct {
        filePath string
        mu       sync.Mutex
}

// NewFilePersistence creates a new file persistence layer
func NewFilePersistence(filePath string) *FilePersistence <span class="cov8" title="1">{
        return &amp;FilePersistence{
                filePath: filePath,
        }
}</span>

// Save persists entities to file
func (p *FilePersistence) Save(ctx context.Context, entities []Entity) error <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Convert entities to serializable format
        data := make([]map[string]interface{}, len(entities))
        for i, entity := range entities </span><span class="cov8" title="1">{
                data[i] = map[string]interface{}{
                        "id":         entity.ID(),
                        "name":       entity.Name(),
                        "active":     entity.Active(),
                        "metadata":   entity.Metadata(),
                        "created_at": entity.CreatedAt(),
                        "updated_at": entity.UpdatedAt(),
                }
        }</span>

        // Marshal to JSON
        <span class="cov8" title="1">jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal entities: %w", err)
        }</span>

        // Write to file
        <span class="cov8" title="1">if err := os.WriteFile(p.filePath, jsonData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Load loads entities from file
func (p *FilePersistence) Load(ctx context.Context) ([]Entity, error) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Check if file exists
        if _, err := os.Stat(p.filePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return []Entity{}, nil
        }</span>

        // Read file
        <span class="cov8" title="1">data, err := os.ReadFile(p.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        // Unmarshal JSON
        <span class="cov8" title="1">var rawData []map[string]interface{}
        if err := json.Unmarshal(data, &amp;rawData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal data: %w", err)
        }</span>

        // Convert to entities
        <span class="cov8" title="1">entities := make([]Entity, len(rawData))
        for i, raw := range rawData </span><span class="cov8" title="1">{
                // Parse timestamps
                createdAt, _ := time.Parse(time.RFC3339, raw["created_at"].(string))
                updatedAt, _ := time.Parse(time.RFC3339, raw["updated_at"].(string))

                // Parse metadata
                metadata := make(map[string]string)
                if rawMetadata, ok := raw["metadata"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        for k, v := range rawMetadata </span><span class="cov0" title="0">{
                                if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                                        metadata[k] = str
                                }</span>
                        }
                }

                <span class="cov8" title="1">entities[i] = &amp;BaseEntity{
                        BEId:        raw["id"].(string),
                        BEName:      raw["name"].(string),
                        BEActive:    raw["active"].(bool),
                        BEMetadata:  metadata,
                        BECreatedAt: createdAt,
                        BEUpdatedAt: updatedAt,
                }</span>
        }

        <span class="cov8" title="1">return entities, nil</span>
}

// Delete removes the persistence file
func (p *FilePersistence) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        // For file persistence, we don't delete individual entities
        // The entire file is rewritten on save
        return nil
}</span>

// Clear removes the persistence file
func (p *FilePersistence) Clear(ctx context.Context) error <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        return os.Remove(p.filePath)
}</span>

// SimpleMetrics implements RegistryMetrics using simple counters
type SimpleMetrics struct {
        registrations   int64
        unregistrations int64
        lookups         int64
        errors          int64
        entityCount     int
        activeCount     int
        latencies       map[string][]time.Duration
        mu              sync.RWMutex
}

// NewSimpleMetrics creates a new simple metrics collector
func NewSimpleMetrics() *SimpleMetrics <span class="cov8" title="1">{
        return &amp;SimpleMetrics{
                latencies: make(map[string][]time.Duration),
        }
}</span>

// IncrementRegistration increments the registration counter
func (m *SimpleMetrics) IncrementRegistration() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.registrations++
}</span>

// IncrementUnregistration increments the unregistration counter
func (m *SimpleMetrics) IncrementUnregistration() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.unregistrations++
}</span>

// IncrementLookup increments the lookup counter
func (m *SimpleMetrics) IncrementLookup() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.lookups++
}</span>

// IncrementError increments the error counter
func (m *SimpleMetrics) IncrementError() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.errors++
}</span>

// SetEntityCount sets the entity count
func (m *SimpleMetrics) SetEntityCount(count int) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.entityCount = count
}</span>

// SetActiveCount sets the active entity count
func (m *SimpleMetrics) SetActiveCount(count int) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.activeCount = count
}</span>

// RecordLatency records operation latency
func (m *SimpleMetrics) RecordLatency(operation string, duration time.Duration) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.latencies[operation] == nil </span><span class="cov8" title="1">{
                m.latencies[operation] = make([]time.Duration, 0)
        }</span>
        <span class="cov8" title="1">m.latencies[operation] = append(m.latencies[operation], duration)

        // Keep only last 100 latencies per operation
        if len(m.latencies[operation]) &gt; 100 </span><span class="cov0" title="0">{
                m.latencies[operation] = m.latencies[operation][len(m.latencies[operation])-100:]
        }</span>
}

// GetStats returns current metrics statistics
func (m *SimpleMetrics) GetStats() map[string]interface{} <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        stats := map[string]interface{}{
                "registrations":   m.registrations,
                "unregistrations": m.unregistrations,
                "lookups":         m.lookups,
                "errors":          m.errors,
                "entity_count":    m.entityCount,
                "active_count":    m.activeCount,
                "latencies":       m.latencies,
        }

        return stats
}</span>

// SimpleEventBus implements RegistryEventBus using in-memory event handling
type SimpleEventBus struct {
        observers []RegistryObserver
        mu        sync.RWMutex
}

// NewSimpleEventBus creates a new simple event bus
func NewSimpleEventBus() *SimpleEventBus <span class="cov8" title="1">{
        return &amp;SimpleEventBus{
                observers: make([]RegistryObserver, 0),
        }
}</span>

// Subscribe adds an observer to the event bus
func (b *SimpleEventBus) Subscribe(observer RegistryObserver) error <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        b.observers = append(b.observers, observer)
        return nil
}</span>

// Unsubscribe removes an observer from the event bus
func (b *SimpleEventBus) Unsubscribe(observer RegistryObserver) error <span class="cov0" title="0">{
        b.mu.Lock()
        defer b.mu.Unlock()

        for i, obs := range b.observers </span><span class="cov0" title="0">{
                if obs == observer </span><span class="cov0" title="0">{
                        b.observers = append(b.observers[:i], b.observers[i+1:]...)
                        break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Publish publishes an event to all observers
func (b *SimpleEventBus) Publish(ctx context.Context, event RegistryEvent) error <span class="cov8" title="1">{
        b.mu.RLock()
        observers := make([]RegistryObserver, len(b.observers))
        copy(observers, b.observers)
        b.mu.RUnlock()

        for _, observer := range observers </span><span class="cov8" title="1">{
                switch event.Type </span>{
                case EventEntityRegistered:<span class="cov8" title="1">
                        observer.OnEntityRegistered(ctx, event.Entity)</span>
                case EventEntityUnregistered:<span class="cov8" title="1">
                        observer.OnEntityUnregistered(ctx, event.EntityID)</span>
                case EventEntityUpdated:<span class="cov0" title="0">
                        observer.OnEntityUpdated(ctx, event.Entity)</span>
                case EventEntityActivated:<span class="cov0" title="0">
                        observer.OnEntityActivated(ctx, event.EntityID)</span>
                case EventEntityDeactivated:<span class="cov0" title="0">
                        observer.OnEntityDeactivated(ctx, event.EntityID)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// SimpleValidator implements RegistryValidator with basic validation
type SimpleValidator struct {
        requiredMetadata  []string
        forbiddenMetadata []string
        validators        map[string]func(string) error
}

// NewSimpleValidator creates a new simple validator
func NewSimpleValidator() *SimpleValidator <span class="cov8" title="1">{
        return &amp;SimpleValidator{
                requiredMetadata:  make([]string, 0),
                forbiddenMetadata: make([]string, 0),
                validators:        make(map[string]func(string) error),
        }
}</span>

// WithRequiredMetadata sets required metadata fields
func (v *SimpleValidator) WithRequiredMetadata(fields []string) *SimpleValidator <span class="cov0" title="0">{
        v.requiredMetadata = fields
        return v
}</span>

// WithForbiddenMetadata sets forbidden metadata fields
func (v *SimpleValidator) WithForbiddenMetadata(fields []string) *SimpleValidator <span class="cov0" title="0">{
        v.forbiddenMetadata = fields
        return v
}</span>

// WithValidator adds a custom validator for a metadata field
func (v *SimpleValidator) WithValidator(field string, validator func(string) error) *SimpleValidator <span class="cov0" title="0">{
        v.validators[field] = validator
        return v
}</span>

// Validate validates an entity
func (v *SimpleValidator) Validate(ctx context.Context, entity Entity) error <span class="cov8" title="1">{
        // Validate required fields
        if entity.ID() == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("entity ID cannot be empty")
        }</span>
        <span class="cov8" title="1">if entity.Name() == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("entity name cannot be empty")
        }</span>

        // Validate metadata
        <span class="cov8" title="1">return v.ValidateMetadata(ctx, entity.Metadata())</span>
}

// ValidateMetadata validates entity metadata
func (v *SimpleValidator) ValidateMetadata(ctx context.Context, metadata map[string]string) error <span class="cov8" title="1">{
        // Check required metadata
        for _, required := range v.requiredMetadata </span><span class="cov0" title="0">{
                if _, exists := metadata[required]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("required metadata field missing: %s", required)
                }</span>
        }

        // Check forbidden metadata
        <span class="cov8" title="1">for _, forbidden := range v.forbiddenMetadata </span><span class="cov0" title="0">{
                if _, exists := metadata[forbidden]; exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("forbidden metadata field present: %s", forbidden)
                }</span>
        }

        // Run custom validators
        <span class="cov8" title="1">for field, validator := range v.validators </span><span class="cov0" title="0">{
                if value, exists := metadata[field]; exists </span><span class="cov0" title="0">{
                        if err := validator(value); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("validation failed for field %s: %w", field, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// SimpleHealth implements RegistryHealth with basic health checking
type SimpleHealth struct {
        lastError error
        mu        sync.RWMutex
}

// NewSimpleHealth creates a new simple health checker
func NewSimpleHealth() *SimpleHealth <span class="cov0" title="0">{
        return &amp;SimpleHealth{}
}</span>

// IsHealthy checks if the registry is healthy
func (h *SimpleHealth) IsHealthy(ctx context.Context) bool <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        return h.lastError == nil
}</span>

// GetHealthStatus returns the health status
func (h *SimpleHealth) GetHealthStatus(ctx context.Context) map[string]interface{} <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        status := map[string]interface{}{
                "healthy":   h.lastError == nil,
                "timestamp": time.Now(),
        }

        if h.lastError != nil </span><span class="cov0" title="0">{
                status["last_error"] = h.lastError.Error()
        }</span>

        <span class="cov0" title="0">return status</span>
}

// GetLastError returns the last error
func (h *SimpleHealth) GetLastError() error <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        return h.lastError
}</span>

// SetError sets the last error
func (h *SimpleHealth) SetError(err error) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        h.lastError = err
}</span>

// ClearError clears the last error
func (h *SimpleHealth) ClearError() <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        h.lastError = nil
}</span>
</pre>

		<pre class="file" id="file36" style="display: none">package registry

import (
        "context"
        "time"
)

// Entity represents any entity that can be registered
type Entity interface {
        ID() string
        Name() string
        Active() bool
        Metadata() map[string]string
        CreatedAt() time.Time
        UpdatedAt() time.Time
}

// RegistryProvider defines the interface for registry implementations
type RegistryProvider interface {
        // Core operations
        Register(ctx context.Context, entity Entity) error
        Get(ctx context.Context, id string) (Entity, error)
        Unregister(ctx context.Context, id string) error
        IsRegistered(ctx context.Context, id string) bool

        // Listing operations
        List(ctx context.Context) ([]Entity, error)
        ListActive(ctx context.Context) ([]Entity, error)
        ListByMetadata(ctx context.Context, key, value string) ([]Entity, error)

        // Counting operations
        Count(ctx context.Context) (int, error)
        CountActive(ctx context.Context) (int, error)

        // Metadata operations
        GetMetadata(ctx context.Context, id, key string) (string, error)
        SetMetadata(ctx context.Context, id, key, value string) error
        RemoveMetadata(ctx context.Context, id, key string) error

        // Lifecycle operations
        Activate(ctx context.Context, id string) error
        Deactivate(ctx context.Context, id string) error

        // Search operations
        Search(ctx context.Context, query string) ([]Entity, error)
        SearchByMetadata(ctx context.Context, metadata map[string]string) ([]Entity, error)
}

// RegistryObserver defines the interface for registry event observers
type RegistryObserver interface {
        OnEntityRegistered(ctx context.Context, entity Entity)
        OnEntityUnregistered(ctx context.Context, id string)
        OnEntityUpdated(ctx context.Context, entity Entity)
        OnEntityActivated(ctx context.Context, id string)
        OnEntityDeactivated(ctx context.Context, id string)
}

// RegistryEvent represents a registry event
type RegistryEvent struct {
        Type      string                 `json:"type"`
        EntityID  string                 `json:"entity_id"`
        Entity    Entity                 `json:"entity,omitempty"`
        Timestamp time.Time              `json:"timestamp"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// RegistryEventType constants
const (
        EventEntityRegistered   = "entity_registered"
        EventEntityUnregistered = "entity_unregistered"
        EventEntityUpdated      = "entity_updated"
        EventEntityActivated    = "entity_activated"
        EventEntityDeactivated  = "entity_deactivated"
)

// RegistryEventBus defines the interface for registry event handling
type RegistryEventBus interface {
        Subscribe(observer RegistryObserver) error
        Unsubscribe(observer RegistryObserver) error
        Publish(ctx context.Context, event RegistryEvent) error
}

// RegistryConfig holds configuration for registry implementations
type RegistryConfig struct {
        // General settings
        Name             string        `json:"name"`
        MaxEntities      int           `json:"max_entities"`
        DefaultTTL       time.Duration `json:"default_ttl"`
        EnableEvents     bool          `json:"enable_events"`
        EnableValidation bool          `json:"enable_validation"`

        // Performance settings
        CacheSize         int           `json:"cache_size"`
        CacheTTL          time.Duration `json:"cache_ttl"`
        EnableCompression bool          `json:"enable_compression"`

        // Persistence settings
        EnablePersistence bool          `json:"enable_persistence"`
        PersistencePath   string        `json:"persistence_path"`
        AutoSaveInterval  time.Duration `json:"auto_save_interval"`

        // Validation settings
        RequiredMetadata   []string                      `json:"required_metadata"`
        ForbiddenMetadata  []string                      `json:"forbidden_metadata"`
        MetadataValidators map[string]func(string) error `json:"-"`
}

// RegistryValidator defines the interface for entity validation
type RegistryValidator interface {
        Validate(ctx context.Context, entity Entity) error
        ValidateMetadata(ctx context.Context, metadata map[string]string) error
}

// RegistryPersistence defines the interface for registry persistence
type RegistryPersistence interface {
        Save(ctx context.Context, entities []Entity) error
        Load(ctx context.Context) ([]Entity, error)
        Delete(ctx context.Context, id string) error
        Clear(ctx context.Context) error
}

// RegistryCache defines the interface for registry caching
type RegistryCache interface {
        Get(ctx context.Context, id string) (Entity, bool)
        Set(ctx context.Context, entity Entity) error
        Delete(ctx context.Context, id string) error
        Clear(ctx context.Context) error
        Size() int
}

// RegistryMetrics defines the interface for registry metrics
type RegistryMetrics interface {
        IncrementRegistration()
        IncrementUnregistration()
        IncrementLookup()
        IncrementError()
        SetEntityCount(count int)
        SetActiveCount(count int)
        RecordLatency(operation string, duration time.Duration)
}

// RegistryHealth defines the interface for registry health checks
type RegistryHealth interface {
        IsHealthy(ctx context.Context) bool
        GetHealthStatus(ctx context.Context) map[string]interface{}
        GetLastError() error
}

// RegistryFactory defines the interface for creating registry instances
type RegistryFactory interface {
        Create(ctx context.Context, config RegistryConfig) (RegistryProvider, error)
        CreateWithPersistence(ctx context.Context, config RegistryConfig, persistence RegistryPersistence) (RegistryProvider, error)
        CreateWithCache(ctx context.Context, config RegistryConfig, cache RegistryCache) (RegistryProvider, error)
        CreateWithMetrics(ctx context.Context, config RegistryConfig, metrics RegistryMetrics) (RegistryProvider, error)
}

// BaseEntity provides a default implementation of the Entity interface
type BaseEntity struct {
        BEId        string            `json:"id"`
        BEName      string            `json:"name"`
        BEActive    bool              `json:"active"`
        BEMetadata  map[string]string `json:"metadata,omitempty"`
        BECreatedAt time.Time         `json:"created_at"`
        BEUpdatedAt time.Time         `json:"updated_at"`
}

// Property-style getter methods to implement Entity interface
func (e *BaseEntity) ID() string   <span class="cov8" title="1">{ return e.BEId }</span>
func (e *BaseEntity) Name() string <span class="cov8" title="1">{ return e.BEName }</span>
func (e *BaseEntity) Active() bool <span class="cov8" title="1">{ return e.BEActive }</span>
func (e *BaseEntity) Metadata() map[string]string <span class="cov8" title="1">{
        if e.BEMetadata == nil </span><span class="cov0" title="0">{
                e.BEMetadata = make(map[string]string)
        }</span>
        <span class="cov8" title="1">return e.BEMetadata</span>
}
func (e *BaseEntity) CreatedAt() time.Time <span class="cov8" title="1">{ return e.BECreatedAt }</span>
func (e *BaseEntity) UpdatedAt() time.Time <span class="cov8" title="1">{ return e.BEUpdatedAt }</span>

// Add a compile-time check to ensure BaseEntity implements the Entity interface.
var _ Entity = (*BaseEntity)(nil)

// NewBaseEntity creates a new base entity
func NewBaseEntity(id, name string) *BaseEntity <span class="cov8" title="1">{
        now := time.Now()
        return &amp;BaseEntity{
                BEId:        id,
                BEName:      name,
                BEActive:    true,
                BEMetadata:  make(map[string]string),
                BECreatedAt: now,
                BEUpdatedAt: now,
        }
}</span>

// RegistryBuilder provides a fluent interface for building registry configurations
type RegistryBuilder struct {
        config RegistryConfig
}

// NewRegistryBuilder creates a new registry builder
func NewRegistryBuilder() *RegistryBuilder <span class="cov8" title="1">{
        return &amp;RegistryBuilder{
                config: RegistryConfig{
                        EnableEvents:     true,
                        EnableValidation: true,
                        CacheSize:        1000,
                        CacheTTL:         5 * time.Minute,
                },
        }
}</span>

// WithName sets the registry name
func (b *RegistryBuilder) WithName(name string) *RegistryBuilder <span class="cov8" title="1">{
        b.config.Name = name
        return b
}</span>

// WithMaxEntities sets the maximum number of entities
func (b *RegistryBuilder) WithMaxEntities(max int) *RegistryBuilder <span class="cov8" title="1">{
        b.config.MaxEntities = max
        return b
}</span>

// WithDefaultTTL sets the default TTL for entities
func (b *RegistryBuilder) WithDefaultTTL(ttl time.Duration) *RegistryBuilder <span class="cov0" title="0">{
        b.config.DefaultTTL = ttl
        return b
}</span>

// WithCache sets cache configuration
func (b *RegistryBuilder) WithCache(size int, ttl time.Duration) *RegistryBuilder <span class="cov8" title="1">{
        b.config.CacheSize = size
        b.config.CacheTTL = ttl
        return b
}</span>

// WithPersistence enables persistence with the given path
func (b *RegistryBuilder) WithPersistence(path string, interval time.Duration) *RegistryBuilder <span class="cov8" title="1">{
        b.config.EnablePersistence = true
        b.config.PersistencePath = path
        b.config.AutoSaveInterval = interval
        return b
}</span>

// WithValidation sets validation configuration
func (b *RegistryBuilder) WithValidation(required, forbidden []string) *RegistryBuilder <span class="cov8" title="1">{
        b.config.RequiredMetadata = required
        b.config.ForbiddenMetadata = forbidden
        return b
}</span>

// Build returns the built configuration
func (b *RegistryBuilder) Build() RegistryConfig <span class="cov8" title="1">{
        return b.config
}</span>
</pre>

		<pre class="file" id="file37" style="display: none">package registry

import (
        "sync"
)

// Meta represents generic metadata that can be associated with any entity
type Meta struct {
        // Generic fields that can be used by any registry
        ID       string            `json:"id"`
        Name     string            `json:"name"`
        Active   bool              `json:"active"`
        Metadata map[string]string `json:"metadata,omitempty"`
}

// Registry is a generic, thread-safe registry for managing any type of entity
type Registry struct {
        entities map[string]Meta
        mu       sync.RWMutex
}

// NewRegistry creates a new empty registry
func NewRegistry() *Registry <span class="cov8" title="1">{
        return &amp;Registry{
                entities: make(map[string]Meta),
        }
}</span>

// Register adds or updates an entity in the registry
func (r *Registry) Register(id string, meta Meta) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        meta.ID = id // Ensure ID is set
        r.entities[id] = meta
}</span>

// Get returns entity metadata for the given ID
// Returns empty Meta if the entity is not found
func (r *Registry) Get(id string) Meta <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if meta, exists := r.entities[id]; exists </span><span class="cov8" title="1">{
                return meta
        }</span>

        // Return empty meta for unknown entities
        <span class="cov8" title="1">return Meta{ID: id, Active: false}</span>
}

// IsRegistered checks if an entity ID is registered
func (r *Registry) IsRegistered(id string) bool <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        _, exists := r.entities[id]
        return exists
}</span>

// ListRegistered returns a list of all registered entity IDs
func (r *Registry) ListRegistered() []string <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        ids := make([]string, 0, len(r.entities))
        for id := range r.entities </span><span class="cov8" title="1">{
                ids = append(ids, id)
        }</span>
        <span class="cov8" title="1">return ids</span>
}

// ListActive returns a list of all active entity IDs
func (r *Registry) ListActive() []string <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        ids := make([]string, 0)
        for id, meta := range r.entities </span><span class="cov8" title="1">{
                if meta.Active </span><span class="cov8" title="1">{
                        ids = append(ids, id)
                }</span>
        }
        <span class="cov8" title="1">return ids</span>
}

// Unregister removes an entity from the registry
func (r *Registry) Unregister(id string) bool <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.entities[id]; exists </span><span class="cov8" title="1">{
                delete(r.entities, id)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Count returns the total number of registered entities
func (r *Registry) Count() int <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return len(r.entities)
}</span>

// GetMetadata returns a specific metadata value for an entity
func (r *Registry) GetMetadata(id, key string) (string, bool) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if meta, exists := r.entities[id]; exists </span><span class="cov8" title="1">{
                if meta.Metadata != nil </span><span class="cov8" title="1">{
                        value, found := meta.Metadata[key]
                        return value, found
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

// SetMetadata sets a specific metadata value for an entity
func (r *Registry) SetMetadata(id, key, value string) bool <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if meta, exists := r.entities[id]; exists </span><span class="cov8" title="1">{
                if meta.Metadata == nil </span><span class="cov8" title="1">{
                        meta.Metadata = make(map[string]string)
                }</span>
                <span class="cov8" title="1">meta.Metadata[key] = value
                r.entities[id] = meta
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Global registry instance for convenience
var globalRegistry = NewRegistry()

// Global convenience functions
func Register(id string, meta Meta) <span class="cov8" title="1">{
        globalRegistry.Register(id, meta)
}</span>

func Get(id string) Meta <span class="cov8" title="1">{
        return globalRegistry.Get(id)
}</span>

func IsRegistered(id string) bool <span class="cov8" title="1">{
        return globalRegistry.IsRegistered(id)
}</span>

func ListRegistered() []string <span class="cov8" title="1">{
        return globalRegistry.ListRegistered()
}</span>

func ListActive() []string <span class="cov8" title="1">{
        return globalRegistry.ListActive()
}</span>

func Unregister(id string) bool <span class="cov8" title="1">{
        return globalRegistry.Unregister(id)
}</span>

func Count() int <span class="cov8" title="1">{
        return globalRegistry.Count()
}</span>

func GetMetadata(id, key string) (string, bool) <span class="cov8" title="1">{
        return globalRegistry.GetMetadata(id, key)
}</span>

func SetMetadata(id, key, value string) bool <span class="cov8" title="1">{
        return globalRegistry.SetMetadata(id, key, value)
}</span>
</pre>

		<pre class="file" id="file38" style="display: none">// Package account provides business logic for interacting with domain entities such as accounts and transactions.
// It defines the Service struct and its methods for creating accounts, depositing and withdrawing funds,
// retrieving account details, listing transactions, and checking account balances.
//
// The service layer follows clean architecture principles and uses the decorator pattern for transaction management.
// All business operations are wrapped with automatic transaction management, error recovery, and structured logging.
package account

import (
        "context"
        "errors"
        "time"

        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/handler"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// Service provides business logic for account operations including creation, deposits, withdrawals, and balance inquiries.
type Service struct {
        deps         config.Deps
        accountChain *Chain
}

// NewService creates a new Service with the provided dependencies.
func NewService(deps config.Deps) *Service <span class="cov8" title="1">{
        accountChain := NewChain(deps)
        return &amp;Service{
                accountChain: accountChain,
                deps:         deps,
        }
}</span>

// CreateAccount creates a new account for the specified user in a transaction.
func (s *Service) CreateAccount(ctx context.Context, userID uuid.UUID) (a *account.Account, err error) <span class="cov8" title="1">{
        uow := s.deps.Uow
        err = uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">a, err = account.New().WithUserID(userID).Build()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return repo.Create(a)</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                a = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// CreateAccountWithCurrency creates a new account for the specified user with a specific currency.
// This method allows creating accounts in different currencies, which is useful for multi-currency
// applications where users may need accounts in various currencies.
//
// The operation is wrapped with automatic transaction management and includes comprehensive
// error handling and logging.
//
// Parameters:
//   - userID: The UUID of the user who will own the account
//   - currencyCode: The ISO 4217 currency code for the account (e.g., "USD", "EUR", "JPY")
//
// Returns:
//   - A pointer to the created account with the specified currency
//   - An error if the operation fails (e.g., invalid currency, user not found, database error)
//
// The method validates the currency code and ensures it's supported by the system.
// If the currency is not supported, an appropriate domain error is returned.
//
// Example:
//
//        account, err := service.CreateAccountWithCurrency(userID, currency.Code("EUR"))
//        if err != nil {
//            log.Error("Failed to create EUR account", "error", err)
//            return
//        }
//        log.Info("EUR account created", "accountID", account.ID, "currency", account.Currency)
func (s *Service) CreateAccountWithCurrency(
        userID uuid.UUID,
        currencyCode currency.Code,
) (acct *account.Account, err error) <span class="cov0" title="0">{
        logger := s.deps.Logger.With("userID", userID, "currency", currencyCode)
        logger.Info("CreateAccountWithCurrency started")
        uow := s.deps.Uow
        err = uow.Do(context.Background(), func(uow repository.UnitOfWork) error </span><span class="cov0" title="0">{
                repo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("CreateAccountWithCurrency failed: AccountRepository error", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">acct, err = account.New().
                        WithUserID(userID).
                        WithCurrency(currencyCode).
                        Build()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("CreateAccountWithCurrency failed: domain error", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">if err = repo.Create(acct); err != nil </span><span class="cov0" title="0">{
                        logger.Error("CreateAccountWithCurrency failed: repo create error", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                acct = nil
                logger.Error("CreateAccountWithCurrency failed: transaction error", "error", err)
                return
        }</span>
        <span class="cov0" title="0">logger.Info("CreateAccountWithCurrency successful", "accountID", acct.ID)
        return</span>
}

// Deposit adds funds to the specified account and creates a transaction record.
// The method supports multi-currency deposits with automatic currency conversion
// when the deposit currency differs from the account currency.
//
// The operation is wrapped with automatic transaction management and includes
// comprehensive validation, error handling, and logging.
//
// Key Features:
// - Multi-currency support with real-time conversion
// - Automatic transaction record creation
// - Comprehensive validation (positive amounts, valid currencies)
// - User authorization checks
// - Detailed logging for observability
//
// Parameters:
//   - userID: The UUID of the user making the deposit (must own the account)
//   - accountID: The UUID of the account to deposit into
//   - amount: The amount to deposit (must be positive)
//   - currencyCode: The ISO 4217 currency code of the deposit amount
//
// Returns:
//   - A pointer to the created transaction record
//   - A pointer to conversion information (if currency conversion occurred)
//   - An error if the operation fails
//
// Currency Conversion:
// If the deposit currency differs from the account currency, the system will:
// 1. Fetch real-time exchange rates from the configured provider
// 2. Convert the amount to the account's currency
// 3. Store conversion details for audit purposes
// 4. Update the account balance with the converted amount
//
// Error Scenarios:
// - Account not found: Returns domain.ErrAccountNotFound
// - User not authorized: Returns domain.ErrUserUnauthorized
// - Invalid amount: Returns domain.ErrTransactionAmountMustBePositive
// - Invalid currency: Returns domain.ErrInvalidCurrencyCode
// - Insufficient funds: Returns domain.ErrInsufficientFunds
// - Conversion failure: Returns conversion service error
//
// Example:
//
//        tx, convInfo, err := service.Deposit(userID, accountID, 100.0, currency.Code("EUR"))
//        if err != nil {
//            log.Error("Deposit failed", "error", err)
//            return
//        }
//        if convInfo != nil {
//            log.Info("Currency conversion applied",
//                "originalAmount", convInfo.OriginalAmount,
//                "convertedAmount", convInfo.ConvertedAmount,
//                "rate", convInfo.ConversionRate)
//        }
func (s *Service) Deposit(
        userID, accountID uuid.UUID,
        amount float64,
        currencyCode currency.Code,
        moneySource string,
) (*PaymentProcessingRequest, error) <span class="cov8" title="1">{
        if amount &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("amount must be positive")
        }</span>
        // Initiate payment with provider
        <span class="cov8" title="1">paymentID := ""
        if s.deps.PaymentProvider != nil </span><span class="cov8" title="1">{
                pid, err := s.deps.PaymentProvider.InitiatePayment(context.Background(), userID, accountID, amount, string(currencyCode))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">paymentID = pid</span>
        }
        // Publish event with paymentID
        <span class="cov8" title="1">evt := account.DepositRequestedEvent{
                EventID:   uuid.New(),
                AccountID: accountID.String(),
                UserID:    userID.String(),
                Amount:    amount,
                Currency:  string(currencyCode),
                Source:    account.MoneySource(moneySource),
                Timestamp: time.Now().Unix(),
                PaymentID: paymentID,
        }
        err := s.deps.EventBus.Publish(evt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;PaymentProcessingRequest{PaymentID: paymentID}, nil</span>
}

// Withdraw removes funds from the specified account to an external target and creates a transaction record.
func (s *Service) Withdraw(
        userID, accountID uuid.UUID,
        amount float64,
        currencyCode currency.Code,
        externalTarget handler.ExternalTarget,
) (*PaymentProcessingRequest, error) <span class="cov8" title="1">{
        if amount &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("amount must be positive")
        }</span>
        // Initiate payment with provider
        <span class="cov8" title="1">paymentID := ""
        if s.deps.PaymentProvider != nil </span><span class="cov8" title="1">{
                pid, err := s.deps.PaymentProvider.InitiatePayment(context.Background(), userID, accountID, amount, string(currencyCode))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">paymentID = pid</span>
        }
        // Publish event with paymentID
        <span class="cov8" title="1">evt := account.WithdrawRequestedEvent{
                EventID:   uuid.New(),
                AccountID: accountID.String(),
                UserID:    userID.String(),
                Amount:    amount,
                Currency:  string(currencyCode),
                Target:    account.ExternalTarget(externalTarget),
                Timestamp: time.Now().Unix(),
                PaymentID: paymentID,
        }
        err := s.deps.EventBus.Publish(evt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;PaymentProcessingRequest{PaymentID: paymentID}, nil</span>
}

// Transfer moves funds from one account to another account.
func (s *Service) Transfer(
        userID uuid.UUID,
        sourceAccountID, destAccountID uuid.UUID,
        amount float64,
        currencyCode currency.Code,
) error <span class="cov8" title="1">{
        if amount &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("amount must be positive")
        }</span>
        // Only emit and publish event
        <span class="cov8" title="1">evt := account.TransferRequestedEvent{
                EventID:         uuid.New(),
                SourceAccountID: sourceAccountID,
                DestAccountID:   destAccountID,
                SenderUserID:    userID,
                Amount:          amount,
                Currency:        string(currencyCode),
                Source:          account.MoneySourceInternal,
                Timestamp:       time.Now().Unix(),
        }
        return s.deps.EventBus.Publish(evt)</span>
}

// UpdateTransactionStatusByPaymentID updates the status of a transaction identified by its payment ID.
// If the status is "completed", it also updates the account balance accordingly.
func (s *Service) UpdateTransactionStatusByPaymentID(paymentID, status string) error <span class="cov0" title="0">{
        // Use a unit of work for atomicity
        return s.deps.Uow.Do(context.Background(), func(uow repository.UnitOfWork) error </span><span class="cov0" title="0">{
                txRepo, err := uow.TransactionRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">accRepo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">tx, err := txRepo.GetByPaymentID(paymentID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // Only update account if status is changing to completed and wasn't already completed
                <span class="cov0" title="0">if status == "completed" &amp;&amp; tx.Status != account.TransactionStatusCompleted </span><span class="cov0" title="0">{
                        acc, err := accRepo.Get(tx.AccountID)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">newBalance, errAdd := acc.Balance.Add(tx.Amount)
                        if errAdd != nil </span><span class="cov0" title="0">{
                                return errAdd
                        }</span>
                        <span class="cov0" title="0">acc.Balance = newBalance

                        if err := accRepo.Update(acc); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">tx.Status = account.TransactionStatus(status)
                return txRepo.Update(tx)</span>
        })
}
</pre>

		<pre class="file" id="file39" style="display: none">package account

import (
        "context"

        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/handler"
        "github.com/google/uuid"
)

// Chain provides a simplified interface for executing account operations
type Chain struct {
        chain *handler.AccountChain
}

// NewChain creates a new account chain with the given dependencies
func NewChain(deps config.Deps) *Chain <span class="cov8" title="1">{
        return &amp;Chain{
                chain: handler.NewAccountChain(deps.Uow, deps.CurrencyConverter, deps.Logger),
        }
}</span>

// Deposit executes a deposit operation using the chain of responsibility pattern
func (c *Chain) Deposit(ctx context.Context, userID, accountID uuid.UUID, amount float64, currencyCode currency.Code, moneySource, paymentID string) (*handler.OperationResponse, error) <span class="cov0" title="0">{
        return c.chain.Deposit(ctx, userID, accountID, amount, currencyCode, moneySource, paymentID)
}</span>

// Withdraw executes a withdraw operation to an external target using the chain of responsibility pattern
func (c *Chain) Withdraw(ctx context.Context, userID, accountID uuid.UUID, amount float64, currencyCode currency.Code, externalTarget handler.ExternalTarget, paymentID string) (*handler.OperationResponse, error) <span class="cov0" title="0">{
        // Add a new WithdrawExternal method to AccountChain to support this
        return c.chain.Withdraw(ctx, userID, accountID, amount, currencyCode, externalTarget, paymentID)
}</span>

// Transfer executes a transfer operation using the chain of responsibility pattern
func (c *Chain) Transfer(ctx context.Context, senderUserID, receiverUserID, sourceAccountID, destAccountID uuid.UUID, amount float64, currencyCode currency.Code) (*handler.OperationResponse, error) <span class="cov0" title="0">{
        return c.chain.Transfer(ctx, senderUserID, receiverUserID, sourceAccountID, destAccountID, amount, currencyCode)
}</span>

// OperationHandler defines the interface for handling account operations in the chain
type OperationHandler = handler.OperationHandler

// OperationRequest contains all the data needed for account operations
type OperationRequest = handler.OperationRequest

// OperationResponse contains the result of an account operation
type OperationResponse = handler.OperationResponse
</pre>

		<pre class="file" id="file40" style="display: none">package account

import (
        "context"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// GetAccount retrieves an account by ID for the specified user.
func (s *Service) GetAccount(
        userID, accountID uuid.UUID,
) (
        account *account.Account,
        err error,
) <span class="cov8" title="1">{
        err = s.deps.Uow.Do(context.Background(), func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">account, err = repo.Get(accountID)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                account = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetTransactions retrieves all transactions for a specific account.
func (s *Service) GetTransactions(
        userID, accountID uuid.UUID,
) (
        transactions []*account.Transaction,
        err error,
) <span class="cov8" title="1">{
        err = s.deps.Uow.Do(context.Background(), func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                // First, validate that the account exists and belongs to the user
                accountRepo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">_, err = accountRepo.Get(accountID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Then, get the transactions
                <span class="cov8" title="1">transactionRepo, err := uow.TransactionRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">transactions, err = transactionRepo.List(userID, accountID)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                transactions = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetBalance retrieves the current balance of an account for the specified user.
func (s *Service) GetBalance(
        userID, accountID uuid.UUID,
) (
        balance float64,
        err error,
) <span class="cov8" title="1">{
        err = s.deps.Uow.Do(context.Background(), func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.AccountRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">account, err := repo.Get(accountID)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">balance, err = account.GetBalance(userID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                balance = 0
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>

		<pre class="file" id="file41" style="display: none">package auth

import (
        "context"
        "errors"
        "log/slog"
        "time"

        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/amirasaad/fintech/pkg/utils"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

type contextKey string

const userContextKey contextKey = "user"

type AuthStrategy interface {
        Login(ctx context.Context, identity, password string) (*domain.User, error)
        GetCurrentUserID(ctx context.Context) (uuid.UUID, error)
        GenerateToken(user *domain.User) (string, error)
}

type AuthService struct {
        uow      repository.UnitOfWork
        strategy AuthStrategy
        logger   *slog.Logger
}

func NewAuthService(
        uow repository.UnitOfWork,
        strategy AuthStrategy,
        logger *slog.Logger,
) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{uow: uow, strategy: strategy, logger: logger}
}</span>

func NewBasicAuthService(uow repository.UnitOfWork, logger *slog.Logger) *AuthService <span class="cov8" title="1">{
        return NewAuthService(uow, &amp;BasicAuthStrategy{uow: uow, logger: logger}, logger)
}</span>

func (s *AuthService) CheckPasswordHash(
        password, hash string,
) bool <span class="cov8" title="1">{
        s.logger.Info("CheckPasswordHash called")
        valid := utils.CheckPasswordHash(password, hash)
        if !valid </span><span class="cov8" title="1">{
                s.logger.Error("Password hash check failed", "valid", valid)
        }</span>
        <span class="cov8" title="1">return valid</span>
}

func (s *AuthService) ValidEmail(email string) bool <span class="cov8" title="1">{
        s.logger.Info("ValidEmail called", "email", email)
        return utils.IsEmail(email)
}</span>

func (s *AuthService) GetCurrentUserId(
        token *jwt.Token,
) (userID uuid.UUID, err error) <span class="cov8" title="1">{
        s.logger.Info("GetCurrentUserId called")
        userID, err = s.strategy.GetCurrentUserID(context.WithValue(context.TODO(), userContextKey, token))
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("GetCurrentUserId failed", "error", err)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (s *AuthService) Login(
        ctx context.Context,
        identity, password string,
) (u *domain.User, err error) <span class="cov8" title="1">{
        s.logger.Info("Login called", "identity", identity)
        u, err = s.strategy.Login(ctx, identity, password)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Login failed", "identity", identity, "error", err)
                return
        }</span>
        <span class="cov8" title="1">if u == nil </span><span class="cov8" title="1">{
                err = domain.ErrUserUnauthorized
                s.logger.Error("Login failed", "identity", identity, "error", "user is nil")
                return
        }</span>
        <span class="cov8" title="1">s.logger.Info("Login successful", "userID", u.ID)
        return</span>
}

func (s *AuthService) GenerateToken(user *domain.User) (string, error) <span class="cov0" title="0">{
        s.logger.Info("GenerateToken called", "userID", user.ID)
        token, err := s.strategy.GenerateToken(user)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("GenerateToken failed", "userID", user.ID, "error", err)
                return "", err
        }</span>
        <span class="cov0" title="0">s.logger.Info("GenerateToken successful", "userID", user.ID)
        return token, nil</span>
}

// JWTAuthStrategy implements AuthStrategy for JWT-based authentication
type JWTAuthStrategy struct {
        uow    repository.UnitOfWork
        cfg    config.JwtConfig
        logger *slog.Logger
}

func NewJWTAuthStrategy(
        uow repository.UnitOfWork,
        cfg config.JwtConfig,
        logger *slog.Logger,
) *JWTAuthStrategy <span class="cov8" title="1">{
        return &amp;JWTAuthStrategy{uow: uow, cfg: cfg, logger: logger}
}</span>
func (s *JWTAuthStrategy) GenerateToken(user *domain.User) (string, error) <span class="cov0" title="0">{
        s.logger.Info("GenerateToken called", "userID", user.ID)
        token := jwt.New(jwt.SigningMethodHS256)
        claims := token.Claims.(jwt.MapClaims)
        claims["username"] = user.Username
        claims["email"] = user.Email
        claims["user_id"] = user.ID.String()
        claims["exp"] = time.Now().Add(s.cfg.Expiry).Unix()
        tokenString, err := token.SignedString([]byte(s.cfg.Secret))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("GenerateToken failed", "userID", user.ID, "error", err)
                return "", err
        }</span>
        <span class="cov0" title="0">s.logger.Info("GenerateToken successful", "userID", user.ID)
        return tokenString, nil</span>
}

func (s *JWTAuthStrategy) Login(
        ctx context.Context,
        identity, password string,
) (
        u *domain.User,
        err error,
) <span class="cov0" title="0">{
        s.logger.Info("Login called", "identity", identity)
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov0" title="0">{
                repo, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if utils.IsEmail(identity) </span><span class="cov0" title="0">{
                        u, err = repo.GetByEmail(identity)
                }</span> else<span class="cov0" title="0"> {
                        u, err = repo.GetByUsername(identity)
                }</span>
                <span class="cov0" title="0">const dummyHash = "$2a$10$7zFqzDbD3RrlkMTczbXG9OWZ0FLOXjIxXzSZ.QZxkVXjXcx7QZQiC"
                if err != nil </span><span class="cov0" title="0">{
                        return domain.ErrUserUnauthorized
                }</span>
                <span class="cov0" title="0">if u == nil </span><span class="cov0" title="0">{
                        utils.CheckPasswordHash(password, dummyHash)
                        return domain.ErrUserUnauthorized
                }</span>
                <span class="cov0" title="0">if !utils.CheckPasswordHash(password, u.Password) </span><span class="cov0" title="0">{
                        return domain.ErrUserUnauthorized
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return</span>
}

func (s *JWTAuthStrategy) GetCurrentUserID(
        ctx context.Context,
) (userID uuid.UUID, err error) <span class="cov8" title="1">{
        token, ok := ctx.Value(userContextKey).(*jwt.Token)
        if !ok || token == nil </span><span class="cov0" title="0">{
                s.logger.Error("GetCurrentUserID failed", "error", domain.ErrUserUnauthorized)
                err = domain.ErrUserUnauthorized
                return
        }</span>
        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov8" title="1">{
                s.logger.Error("GetCurrentUserID failed", "error", domain.ErrUserUnauthorized)
                err = domain.ErrUserUnauthorized
                return
        }</span>
        <span class="cov8" title="1">userIDRaw, ok := claims["user_id"].(string)
        if !ok </span><span class="cov8" title="1">{
                s.logger.Error("GetCurrentUserID failed", "error", domain.ErrUserUnauthorized)
                err = domain.ErrUserUnauthorized
                return
        }</span>
        <span class="cov0" title="0">userID, err = uuid.Parse(userIDRaw)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("GetCurrentUserID failed", "error", err)
        }</span>
        <span class="cov0" title="0">return</span>
}

// BasicAuthStrategy implements AuthStrategy for CLI (no JWT, just password check)
type BasicAuthStrategy struct {
        uow    repository.UnitOfWork
        logger *slog.Logger
}

func (s *BasicAuthStrategy) Login(
        ctx context.Context,
        identity, password string,
) (
        user *domain.User,
        err error,
) <span class="cov8" title="1">{
        s.logger.Info("Login called", "identity", identity)
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if utils.IsEmail(identity) </span><span class="cov0" title="0">{
                        user, err = repo.GetByEmail(identity)
                }</span> else<span class="cov8" title="1"> {
                        user, err = repo.GetByUsername(identity)
                }</span>
                <span class="cov8" title="1">const dummyHash = "$2a$10$7zFqzDbD3RrlkMTczbXG9OWZ0FLOXjIxXzSZ.QZxkVXjXcx7QZQiC"
                if err != nil </span><span class="cov0" title="0">{
                        return domain.ErrUserUnauthorized
                }</span>
                <span class="cov8" title="1">if user == nil </span><span class="cov0" title="0">{
                        utils.CheckPasswordHash(password, dummyHash)
                        return errors.New("invalid credentials")
                }</span>
                <span class="cov8" title="1">if !utils.CheckPasswordHash(password, user.Password) </span><span class="cov0" title="0">{
                        return errors.New("invalid credentials")
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return</span>
}

func (s *BasicAuthStrategy) GetCurrentUserID(ctx context.Context) (uuid.UUID, error) <span class="cov0" title="0">{
        s.logger.Info("GetCurrentUserID called")
        return uuid.Nil, nil
}</span>

func (s *BasicAuthStrategy) GenerateToken(user *domain.User) (string, error) <span class="cov0" title="0">{
        s.logger.Info("GenerateToken called", "userID", user.ID)
        return "", nil // No token for basic auth
}</span>
</pre>

		<pre class="file" id="file42" style="display: none">package currency

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/currency"
)

// CurrencyService provides business logic for currency operations
type CurrencyService struct {
        registry *currency.CurrencyRegistry
        logger   *slog.Logger
}

// NewCurrencyService creates a new currency service
func NewCurrencyService(registry *currency.CurrencyRegistry, logger *slog.Logger) *CurrencyService <span class="cov8" title="1">{
        return &amp;CurrencyService{
                registry: registry,
                logger:   logger,
        }
}</span>

// GetCurrency retrieves currency information by code
func (s *CurrencyService) GetCurrency(ctx context.Context, code string) (currency.CurrencyMeta, error) <span class="cov8" title="1">{
        return s.registry.Get(code)
}</span>

// ListSupportedCurrencies returns all supported currency codes
func (s *CurrencyService) ListSupportedCurrencies(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        return s.registry.ListSupported()
}</span>

// ListAllCurrencies returns all registered currencies with full metadata
func (s *CurrencyService) ListAllCurrencies(ctx context.Context) ([]currency.CurrencyMeta, error) <span class="cov8" title="1">{
        return s.registry.ListAll()
}</span>

// RegisterCurrency registers a new currency
func (s *CurrencyService) RegisterCurrency(ctx context.Context, meta currency.CurrencyMeta) error <span class="cov8" title="1">{
        return s.registry.Register(meta)
}</span>

// UnregisterCurrency removes a currency from the registry
func (s *CurrencyService) UnregisterCurrency(ctx context.Context, code string) error <span class="cov8" title="1">{
        return s.registry.Unregister(code)
}</span>

// ActivateCurrency activates a currency
func (s *CurrencyService) ActivateCurrency(ctx context.Context, code string) error <span class="cov8" title="1">{
        return s.registry.Activate(code)
}</span>

// DeactivateCurrency deactivates a currency
func (s *CurrencyService) DeactivateCurrency(ctx context.Context, code string) error <span class="cov8" title="1">{
        return s.registry.Deactivate(code)
}</span>

// IsCurrencySupported checks if a currency is supported
func (s *CurrencyService) IsCurrencySupported(ctx context.Context, code string) bool <span class="cov8" title="1">{
        return s.registry.IsSupported(code)
}</span>

// SearchCurrencies searches for currencies by name
func (s *CurrencyService) SearchCurrencies(ctx context.Context, query string) ([]currency.CurrencyMeta, error) <span class="cov8" title="1">{
        return s.registry.Search(query)
}</span>

// SearchCurrenciesByRegion searches for currencies by region
func (s *CurrencyService) SearchCurrenciesByRegion(ctx context.Context, region string) ([]currency.CurrencyMeta, error) <span class="cov8" title="1">{
        return s.registry.SearchByRegion(region)
}</span>

// GetCurrencyStatistics returns currency statistics
func (s *CurrencyService) GetCurrencyStatistics(ctx context.Context) (map[string]interface{}, error) <span class="cov8" title="1">{
        total, err := s.registry.Count()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total count: %w", err)
        }</span>

        <span class="cov8" title="1">active, err := s.registry.CountActive()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active count: %w", err)
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "total_currencies":    total,
                "active_currencies":   active,
                "inactive_currencies": total - active,
        }, nil</span>
}

// ValidateCurrencyCode validates a currency code format
func (s *CurrencyService) ValidateCurrencyCode(ctx context.Context, code string) error <span class="cov8" title="1">{
        if !currency.IsValidCodeFormat(code) </span><span class="cov8" title="1">{
                return currency.ErrInvalidCurrencyCode
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetDefaultCurrency returns the default currency information
func (s *CurrencyService) GetDefaultCurrency(ctx context.Context) (currency.CurrencyMeta, error) <span class="cov8" title="1">{
        return s.registry.Get(currency.DefaultCurrency)
}</span>

// GetRegistry returns the underlying currency registry
func (s *CurrencyService) GetRegistry() *currency.CurrencyRegistry <span class="cov8" title="1">{
        return s.registry
}</span>
</pre>

		<pre class="file" id="file43" style="display: none">package currency

import (
        "github.com/amirasaad/fintech/pkg/domain"
)

// CurrencyConverter defines the interface for converting amounts between currencies.
type CurrencyConverter interface {
        // Convert converts an amount from one currency to another.
        // Returns the converted amount and the rate used, or an error if conversion is not possible.
        Convert(amount float64, from, to string) (*domain.ConversionInfo, error)
}

// StubCurrencyConverter is a simple implementation that returns the same amount (1:1 conversion).
type StubCurrencyConverter struct {
        rates map[string]map[string]float64
}

// NewStubCurrencyConverter creates a new StubCurrencyConverter with an empty rates map.
func NewStubCurrencyConverter() *StubCurrencyConverter <span class="cov0" title="0">{
        return &amp;StubCurrencyConverter{rates: map[string]map[string]float64{
                "USD": {
                        "EUR": 0.84,
                        "GBP": 0.76,
                        "JPY": 0.0027,
                },
                "EUR": {
                        "USD": 1.19,
                        "GBP": 0.90,
                        "JPY": 0.0024,
                },
                "GBP": {
                        "USD": 1.32,
                        "EUR": 1.11,
                        "JPY": 0.0024,
                },
                "JPY": {
                        "USD": 0.0027,
                        "EUR": 0.0024,
                        "GBP": 0.0024,
                },
        }}
}</span>

func (s *StubCurrencyConverter) Convert(amount float64, from, to string) (*domain.ConversionInfo, error) <span class="cov0" title="0">{
        rate := s.rates[from][to]
        return &amp;domain.ConversionInfo{
                OriginalAmount:    amount,
                OriginalCurrency:  from,
                ConvertedAmount:   amount * rate,
                ConvertedCurrency: to,
                ConversionRate:    rate,
        }, nil
}</span>
</pre>

		<pre class="file" id="file44" style="display: none">// Package user provides business logic for user management operations.
// It uses the decorator pattern for transaction management and includes comprehensive logging.
package user

import (
        "context"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// Service provides business logic for user operations including creation, updates, and deletion.
type Service struct {
        uow    repository.UnitOfWork
        logger *slog.Logger
}

// NewService creates a new Service with a UnitOfWork and logger.
func NewService(
        deps config.Deps,
) *Service <span class="cov8" title="1">{
        return &amp;Service{
                uow:    deps.Uow,
                logger: deps.Logger,
        }
}</span>

// CreateUser creates a new user account in a transaction.
func (s *Service) CreateUser(
        ctx context.Context,
        username, email, password string,
) (u *user.User, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u, err = user.NewUser(username, email, password)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return repo.Create(u)</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                u = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetUser retrieves a user by ID in a transaction.
func (s *Service) GetUser(ctx context.Context, userID string) (u *user.User, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">uid, parseErr := uuid.Parse(userID)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return parseErr
                }</span>
                <span class="cov8" title="1">u, err = repo.Get(uid)
                return err</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                u = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetUserByEmail retrieves a user by email in a transaction.
func (s *Service) GetUserByEmail(ctx context.Context, email string) (u *user.User, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u, err = repo.GetByEmail(email)
                return err</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                u = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetUserByUsername retrieves a user by username in a transaction.
func (s *Service) GetUserByUsername(ctx context.Context, username string) (u *user.User, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u, err = repo.GetByUsername(username)
                return err</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                u = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// UpdateUser updates user information in a transaction.
func (s *Service) UpdateUser(ctx context.Context, userID string, updateFn func(u *user.User) error) (err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">uid, parseErr := uuid.Parse(userID)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return parseErr
                }</span>
                <span class="cov8" title="1">u, err := repo.Get(uid)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if u == nil </span><span class="cov0" title="0">{
                        return user.ErrUserNotFound
                }</span>
                <span class="cov8" title="1">if err = updateFn(u); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return repo.Update(u)</span>
        })
        <span class="cov8" title="1">return</span>
}

// DeleteUser deletes a user account in a transaction.
func (s *Service) DeleteUser(ctx context.Context, userID string) (err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">uid, parseErr := uuid.Parse(userID)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return parseErr
                }</span>
                <span class="cov8" title="1">return repo.Delete(uid)</span>
        })
        <span class="cov8" title="1">return</span>
}

// ValidUser validates user credentials in a transaction.
func (s *Service) ValidUser(ctx context.Context, userID string, password string) (valid bool, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repo, err := uow.UserRepository()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">uid, parseErr := uuid.Parse(userID)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return parseErr
                }</span>
                <span class="cov8" title="1">valid = repo.Valid(uid, password)
                return nil</span>
        })
        <span class="cov8" title="1">return</span>
}
</pre>

		<pre class="file" id="file45" style="display: none">package utils

import (
        "net/mail"

        "golang.org/x/crypto/bcrypt"
)

// HashPassword hashes a plain password using bcrypt with cost 14.
func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        return hashPassword(password)
}</span>

func hashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

// CheckPasswordHash compares a plain password with a bcrypt hash.
func CheckPasswordHash(password, hash string) bool <span class="cov0" title="0">{
        return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) == nil
}</span>

// IsEmail returns true if the string is a valid email address.
func IsEmail(email string) bool <span class="cov0" title="0">{
        _, err := mail.ParseAddress(email)
        return err == nil
}</span>
</pre>

		<pre class="file" id="file46" style="display: none">package account

import (
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/handler"
        "github.com/amirasaad/fintech/pkg/middleware"
        accountsvc "github.com/amirasaad/fintech/pkg/service/account"
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

// Routes registers HTTP routes for account-related operations using the Fiber web framework.
// It sets up endpoints for creating accounts, depositing and withdrawing funds, retrieving account balances,
// and listing account transactions. All routes are protected by authentication middleware and require a valid user context.
//
// Routes:
//   - POST   /account                   : Create a new account for the authenticated user.
//   - POST   /account/:id/deposit       : Deposit funds into the specified account.
//   - POST   /account/:id/withdraw      : Withdraw funds from the specified account.
//   - GET    /account/:id/balance       : Retrieve the balance of the specified account.
//   - GET    /account/:id/transactions  : List transactions for the specified account.
func Routes(app *fiber.App, accountSvc *accountsvc.Service, authSvc *authsvc.AuthService, cfg *config.AppConfig) <span class="cov8" title="1">{
        app.Post("/account", middleware.JwtProtected(cfg.Jwt), CreateAccount(accountSvc, authSvc))
        app.Post("/account/:id/deposit", middleware.JwtProtected(cfg.Jwt), Deposit(accountSvc, authSvc))
        app.Post("/account/:id/withdraw", middleware.JwtProtected(cfg.Jwt), Withdraw(accountSvc, authSvc))
        app.Post("/account/:id/transfer", middleware.JwtProtected(cfg.Jwt), Transfer(accountSvc, authSvc))
        app.Get("/account/:id/balance", middleware.JwtProtected(cfg.Jwt), GetBalance(accountSvc, authSvc))
        app.Get("/account/:id/transactions", middleware.JwtProtected(cfg.Jwt), GetTransactions(accountSvc, authSvc))
}</span>

// CreateAccount returns a Fiber handler for creating a new account for the current user.
// It extracts the user ID from the request context, initializes the account service using the provided
// UnitOfWork factory, and attempts to create a new account. On success, it returns the created account as JSON.
// On failure, it logs the error and returns an appropriate error response.
// @Summary Create a new account
// @Description Creates a new account for the authenticated user. You can specify the currency for the account. Returns the created account details.
// @Tags accounts
// @Accept json
// @Produce json
// @Success 201 {object} common.Response "Account created successfully"
// @Failure 400 {object} common.ProblemDetails "Invalid request"
// @Failure 401 {object} common.ProblemDetails "Unauthorized"
// @Failure 429 {object} common.ProblemDetails "Too many requests"
// @Failure 500 {object} common.ProblemDetails "Internal server error"
// @Router /account [post]
// @Security Bearer
func CreateAccount(
        accountSvc *accountsvc.Service,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                log.Infof("Creating new account")
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov8" title="1">input, err := common.BindAndValidate[CreateAccountRequest](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">currencyCode := currency.USD
                if input.Currency != "" </span><span class="cov8" title="1">{
                        currencyCode = currency.Code(input.Currency)
                }</span>
                <span class="cov8" title="1">a, err := accountSvc.CreateAccountWithCurrency(userID, currencyCode)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to create account: %v", err)
                        return common.ProblemDetailsJSON(c, "Failed to create account", err)
                }</span>
                <span class="cov8" title="1">log.Infof("Account created: %+v", a)
                return common.SuccessResponseJSON(c, fiber.StatusCreated, "Account created", a)</span>
        }
}

// Deposit returns a Fiber handler for depositing an amount into a user's account.
// It expects a UnitOfWork factory function as a dependency for transactional operations.
// The handler parses the current user ID from the request context, validates the account ID from the URL,
// and parses the deposit amount from the request body. If successful, it performs the deposit operation
// using the AccountService and returns the transaction as JSON. On error, it logs the issue and returns
// an appropriate JSON error response.
// @Summary Deposit funds into an account
// @Description Adds funds to the specified account. Specify the amount, currency, and optional money source. Returns the transaction details.
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Param request body DepositRequest true "Deposit details"
// @Success 200 {object} common.Response "Deposit successful"
// @Failure 400 {object} common.ProblemDetails "Invalid request"
// @Failure 401 {object} common.ProblemDetails "Unauthorized"
// @Failure 429 {object} common.ProblemDetails "Too many requests"
// @Failure 500 {object} common.ProblemDetails "Internal server error"
// @Router /account/{id}/deposit [post]
// @Security Bearer
func Deposit(
        accountSvc *accountsvc.Service,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                log.Infof("Deposit handler: called for account %s", c.Params("id"))
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov8" title="1">accountID, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for deposit: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid account ID", err, "Account ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">input, err := common.BindAndValidate[DepositRequest](c)
                if input == nil </span><span class="cov0" title="0">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">currencyCode := currency.USD
                if input.Currency != "" </span><span class="cov8" title="1">{
                        currencyCode = currency.Code(input.Currency)
                }</span>
                <span class="cov8" title="1">log.Infof("Deposit handler: calling service for user %s, account %s, amount %v, currency %s, money_source %s", userID, accountID, input.Amount, currencyCode, input.MoneySource)
                payment, err := accountSvc.Deposit(userID, accountID, input.Amount, currencyCode, input.MoneySource)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to deposit", err)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusAccepted, "Deposit request is being processed. Your deposit is being started and will be completed soon.", payment)</span>
        }
}

// Withdraw returns a Fiber handler for processing account withdrawal requests.
// It expects a UnitOfWork factory function as a dependency for transactional operations.
//
// The handler performs the following steps:
//  1. Retrieves the current user ID from the request context.
//  2. Parses the account ID from the route parameters.
//  3. Parses the withdrawal amount from the request body.
//  4. Calls the AccountService.Withdraw method to process the withdrawal.
//  5. Returns the transaction details as a JSON response on success.
//
// Error responses are returned in JSON format with appropriate status codes
// if any step fails (e.g., invalid user ID, invalid account ID, parsing errors, or withdrawal errors).
// @Summary Withdraw funds from an account
// @Description Withdraws a specified amount from the user's account. Specify the amount and currency. Returns the transaction details.
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Param request body WithdrawRequest true "Withdrawal details"
// @Success 200 {object} common.Response "Withdrawal successful"
// @Failure 400 {object} common.ProblemDetails "Invalid request"
// @Failure 401 {object} common.ProblemDetails "Unauthorized"
// @Failure 429 {object} common.ProblemDetails "Too many requests"
// @Failure 500 {object} common.ProblemDetails "Internal server error"
// @Router /account/{id}/withdraw [post]
// @Security Bearer
func Withdraw(
        accountSvc *accountsvc.Service,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov8" title="1">accountID, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for withdrawal: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid account ID", err, "Account ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">input, err := common.BindAndValidate[WithdrawRequest](c)
                if input == nil </span><span class="cov0" title="0">{
                        return err // error response already written
                }</span>
                // Validate that at least one field in ExternalTarget is present
                <span class="cov8" title="1">if input.ExternalTarget.BankAccountNumber == "" &amp;&amp; input.ExternalTarget.RoutingNumber == "" &amp;&amp; input.ExternalTarget.ExternalWalletAddress == "" </span><span class="cov8" title="1">{
                        return common.ProblemDetailsJSON(c, "Invalid external target", nil, "At least one external target field must be provided", fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">currencyCode := currency.Code("USD")
                if input.Currency != "" </span><span class="cov8" title="1">{
                        currencyCode = currency.Code(input.Currency)
                }</span>
                <span class="cov8" title="1">handlerTarget := handler.ExternalTarget{
                        BankAccountNumber:     input.ExternalTarget.BankAccountNumber,
                        RoutingNumber:         input.ExternalTarget.RoutingNumber,
                        ExternalWalletAddress: input.ExternalTarget.ExternalWalletAddress,
                }
                payment, err := accountSvc.Withdraw(userID, accountID, input.Amount, currencyCode, handlerTarget)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to withdraw", err)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusAccepted, "Withdrawal request is being processed. Your withdrawal is being started and will be completed soon.", payment)</span>
        }
}

// Transfer returns a Fiber handler for transferring funds between accounts.
// @Summary Transfer funds between accounts
// @Description Transfers a specified amount from one account to another. Specify the source and destination account IDs, amount, and currency. Returns the transaction details.
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Source Account ID"
// @Param request body TransferRequest true "Transfer details"
// @Success 200 {object} common.Response "Transfer successful"
// @Failure 400 {object} common.ProblemDetails "Invalid request"
// @Failure 401 {object} common.ProblemDetails "Unauthorized"
// @Failure 422 {object} common.ProblemDetails "Unprocessable entity"
// @Failure 429 {object} common.ProblemDetails "Too many requests"
// @Failure 500 {object} common.ProblemDetails "Internal server error"
// @Router /account/{id}/transfer [post]
// @Security Bearer
func Transfer(accountSvc *accountsvc.Service, authSvc *authsvc.AuthService) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                log.Infof("Transfer handler: called for account %s", c.Params("id"))
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov8" title="1">sourceAccountID, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid source account ID for transfer: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid account ID", err, "Account ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">input, err := common.BindAndValidate[TransferRequest](c)
                if input == nil </span><span class="cov0" title="0">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">destAccountID, err := uuid.Parse(input.DestinationAccountID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid destination account ID for transfer: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid destination account ID", err, "Destination Account ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">currencyCode := currency.USD
                if input.Currency != "" </span><span class="cov8" title="1">{
                        currencyCode = currency.Code(input.Currency)
                }</span>
                <span class="cov8" title="1">log.Infof("Transfer handler: calling service for user %s, source account %s, dest account %s, amount %v, currency %s", userID, sourceAccountID, destAccountID, input.Amount, currencyCode)
                err = accountSvc.Transfer(userID, sourceAccountID, destAccountID, input.Amount, currencyCode)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to transfer", err, err.Error())
                }</span>
                <span class="cov8" title="1">resp := fiber.Map{}
                return common.SuccessResponseJSON(c, fiber.StatusAccepted, "Transfer request is being processed. Your transfer is being started and will be completed soon.", resp)</span>
        }
}

// GetTransactions returns a Fiber handler that retrieves the list of transactions for a specific account.
// It expects a UnitOfWork factory function as a dependency for service instantiation.
// The handler extracts the current user ID from the request context and parses the account ID from the URL parameters.
// On success, it returns the transactions as a JSON response. On error, it logs the error and returns an appropriate JSON error response.
// @Summary Get account transactions
// @Description Retrieves a list of transactions for the specified account. Returns an array of transaction details.
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Success 200 {object} common.Response "Transactions fetched"
// @Failure 400 {object} common.ProblemDetails "Invalid request"
// @Failure 401 {object} common.ProblemDetails "Unauthorized"
// @Failure 429 {object} common.ProblemDetails "Too many requests"
// @Failure 500 {object} common.ProblemDetails "Internal server error"
// @Router /account/{id}/transactions [get]
// @Security Bearer
func GetTransactions(
        accountSvc *accountsvc.Service,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov0" title="0">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov0" title="0">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for transactions: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid account ID", err, "Account ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">tx, err := accountSvc.GetTransactions(userID, id)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to list transactions for account ID %s: %v", id, err)
                        return common.ProblemDetailsJSON(c, "Failed to list transactions", err)
                }</span>
                <span class="cov0" title="0">dtos := make([]*TransactionDTO, 0, len(tx))
                for _, t := range tx </span><span class="cov0" title="0">{
                        dtos = append(dtos, ToTransactionDTO(t))
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Transactions fetched", dtos)</span>
        }
}

// GetBalance returns a Fiber handler for retrieving the balance of a specific account.
// It expects a UnitOfWork factory function as a dependency for service instantiation.
// The handler extracts the current user ID from the request context and parses the account ID from the URL parameters.
// On success, it returns the account balance as a JSON response. On error, it logs the error and returns an appropriate JSON error response.
// @Summary Get account balance
// @Description Retrieves the current balance for the specified account. Returns the balance amount and currency.
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Success 200 {object} common.Response "Balance fetched"
// @Failure 400 {object} common.ProblemDetails "Invalid request"
// @Failure 401 {object} common.ProblemDetails "Unauthorized"
// @Failure 429 {object} common.ProblemDetails "Too many requests"
// @Failure 500 {object} common.ProblemDetails "Internal server error"
// @Router /account/{id}/balance [get]
// @Security Bearer
func GetBalance(
        accountSvc *accountsvc.Service,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for balance: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid account ID", err, "Account ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>

                <span class="cov8" title="1">balance, err := accountSvc.GetBalance(userID, id)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to fetch balance for account ID %s: %v", id, err)
                        return common.ProblemDetailsJSON(c, "Failed to fetch balance", err)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusOK, "Balance fetched", fiber.Map{"balance": balance})</span>
        }
}
</pre>

		<pre class="file" id="file47" style="display: none">package account

import (
        "github.com/amirasaad/fintech/pkg/domain"
)

// CreateAccountRequest represents the request body for creating a new account.
type CreateAccountRequest struct {
        Currency string `json:"currency" validate:"omitempty,len=3,uppercase,alpha"`
}

// DepositRequest represents the request body for depositing funds into an account.
type DepositRequest struct {
        Amount      float64 `json:"amount" xml:"amount" form:"amount" validate:"required,gt=0"`
        Currency    string  `json:"currency" validate:"omitempty,len=3,uppercase"`
        MoneySource string  `json:"money_source" validate:"required,min=2,max=64"`
}

// ExternalTarget represents the destination for an external withdrawal, such as a bank account or wallet.
type ExternalTarget struct {
        BankAccountNumber     string `json:"bank_account_number,omitempty" validate:"omitempty,min=6,max=34"`
        RoutingNumber         string `json:"routing_number,omitempty" validate:"omitempty,min=6,max=12"`
        ExternalWalletAddress string `json:"external_wallet_address,omitempty" validate:"omitempty,min=6,max=128"`
}

// WithdrawRequest represents the request body for withdrawing funds from an account.
type WithdrawRequest struct {
        Amount         float64        `json:"amount" xml:"amount" form:"amount" validate:"required,gt=0"`
        Currency       string         `json:"currency" validate:"omitempty,len=3,uppercase"`
        ExternalTarget ExternalTarget `json:"external_target" validate:"required"`
}

// TransferRequest represents the request body for transferring funds between accounts.
type TransferRequest struct {
        Amount               float64 `json:"amount" validate:"required,gt=0"`
        Currency             string  `json:"currency" validate:"omitempty,len=3,uppercase,alpha"`
        DestinationAccountID string  `json:"destination_account_id" validate:"required,uuid4"`
}

// TransactionDTO is the API response representation of a transaction.
type TransactionDTO struct {
        ID          string  `json:"id"`
        UserID      string  `json:"user_id"`
        AccountID   string  `json:"account_id"`
        Amount      float64 `json:"amount"`
        Balance     float64 `json:"balance"`
        CreatedAt   string  `json:"created_at"`
        Currency    string  `json:"currency"`
        MoneySource string  `json:"money_source"`
}

// ConversionInfoDTO holds conversion details for API responses.
type ConversionInfoDTO struct {
        OriginalAmount    float64 `json:"original_amount"`
        OriginalCurrency  string  `json:"original_currency"`
        ConvertedAmount   float64 `json:"converted_amount"`
        ConvertedCurrency string  `json:"converted_currency"`
        ConversionRate    float64 `json:"conversion_rate"`
}

// TransferResponseDTO is the API response for a transfer operation, containing both transactions and a single conversion_info field (like deposit/withdraw).
type TransferResponseDTO struct {
        Outgoing       *TransactionDTO    `json:"outgoing_transaction"`
        Incoming       *TransactionDTO    `json:"incoming_transaction"`
        ConversionInfo *ConversionInfoDTO `json:"conversion_info"`
}

// ToTransactionDTO maps a domain.Transaction to a TransactionDTO.
func ToTransactionDTO(tx *domain.Transaction) *TransactionDTO <span class="cov0" title="0">{
        if tx == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">dto := &amp;TransactionDTO{
                ID:          tx.ID.String(),
                UserID:      tx.UserID.String(),
                AccountID:   tx.AccountID.String(),
                Amount:      tx.Amount.AmountFloat(),
                Currency:    string(tx.Amount.Currency()),
                Balance:     tx.Balance.AmountFloat(),
                CreatedAt:   tx.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                MoneySource: string(tx.MoneySource),
        }

        return dto</span>
}

// ToConversionInfoDTO maps domain.ConversionInfo to ConversionInfoDTO.
func ToConversionInfoDTO(convInfo *domain.ConversionInfo) *ConversionInfoDTO <span class="cov0" title="0">{
        if convInfo == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;ConversionInfoDTO{
                OriginalAmount:    convInfo.OriginalAmount,
                OriginalCurrency:  convInfo.OriginalCurrency,
                ConvertedAmount:   convInfo.ConvertedAmount,
                ConvertedCurrency: convInfo.ConvertedCurrency,
                ConversionRate:    convInfo.ConversionRate,
        }</span>
}

// ToTransferResponseDTO maps domain transactions and conversion info to a TransferResponseDTO with a single conversion_info field.
func ToTransferResponseDTO(txOut, txIn *domain.Transaction, convInfo *domain.ConversionInfo) *TransferResponseDTO <span class="cov0" title="0">{
        return &amp;TransferResponseDTO{
                Outgoing:       ToTransactionDTO(txOut),
                Incoming:       ToTransactionDTO(txIn),
                ConversionInfo: ToConversionInfoDTO(convInfo),
        }
}</span>
</pre>

		<pre class="file" id="file48" style="display: none">package account

import (
        "github.com/amirasaad/fintech/pkg/service/account"
        "github.com/gofiber/fiber/v2"
)

// PaymentWebhookRequest represents the payload for a payment webhook callback.
type PaymentWebhookRequest struct {
        PaymentID string `json:"payment_id" validate:"required"`
        Status    string `json:"status" validate:"required,oneof=completed failed"`
}

// PaymentWebhookHandler handles incoming payment webhook callbacks.
func PaymentWebhookHandler(svc *account.Service) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req PaymentWebhookRequest
                if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Invalid payload"})
                }</span>
                <span class="cov0" title="0">if err := svc.UpdateTransactionStatusByPaymentID(req.PaymentID, req.Status); err != nil </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": err.Error()})
                }</span>
                <span class="cov0" title="0">return c.SendStatus(fiber.StatusOK)</span>
        }
}
</pre>

		<pre class="file" id="file49" style="display: none">package webapi

import (
        "errors"
        "strings"
        "time"

        "github.com/amirasaad/fintech/pkg/config"
        accountsvc "github.com/amirasaad/fintech/pkg/service/account"
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        currencysvc "github.com/amirasaad/fintech/pkg/service/currency"
        usersvc "github.com/amirasaad/fintech/pkg/service/user"
        "github.com/amirasaad/fintech/webapi/account"
        "github.com/amirasaad/fintech/webapi/auth"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/amirasaad/fintech/webapi/currency"
        "github.com/amirasaad/fintech/webapi/user"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/limiter"
        "github.com/gofiber/fiber/v2/middleware/recover"
        "github.com/gofiber/swagger"

        // docs are generated by Swag CLI, you have to import them.
        _ "github.com/amirasaad/fintech/docs"
)

// NewApp creates and configures a new Fiber application with all routes, middleware, and services.
// Deprecated: use app.New
func NewApp(
        accountSvc *accountsvc.Service,
        userSvc *usersvc.Service,
        authSvc *authsvc.AuthService,
        currencySvc *currencysvc.CurrencyService,
        cfg *config.AppConfig,
) *fiber.App <span class="cov8" title="1">{
        // Configure rate limits with reasonable defaults
        maxRequests := 5 // 5 requests per minute by default
        expiration := 1 * time.Minute

        // Override with config if available
        if cfg.RateLimit.MaxRequests &gt; 0 </span><span class="cov8" title="1">{
                maxRequests = cfg.RateLimit.MaxRequests
        }</span>
        <span class="cov8" title="1">if cfg.RateLimit.Window &gt; 0 </span><span class="cov8" title="1">{
                expiration = cfg.RateLimit.Window
        }</span>

        <span class="cov8" title="1">app := fiber.New(fiber.Config{
                ErrorHandler: func(c *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Internal Server Error", err)
                }</span>,
        })
        <span class="cov8" title="1">app.Get("/swagger/*", swagger.New(swagger.Config{
                TryItOutEnabled:      true,
                WithCredentials:      true,
                PersistAuthorization: true,
                OAuth2RedirectUrl:    "/auth/login",
        }))

        app.Use(limiter.New(limiter.Config{
                Max:        maxRequests,
                Expiration: expiration,
                KeyGenerator: func(c *fiber.Ctx) string </span><span class="cov8" title="1">{
                        // Use X-Forwarded-For header if available (for load balancers/proxies)
                        // Fall back to X-Real-IP, then to direct IP
                        if forwardedFor := c.Get("X-Forwarded-For"); forwardedFor != "" </span><span class="cov0" title="0">{
                                // Take the first IP in the chain
                                if commaIndex := strings.Index(forwardedFor, ","); commaIndex != -1 </span><span class="cov0" title="0">{
                                        return strings.TrimSpace(forwardedFor[:commaIndex])
                                }</span>
                                <span class="cov0" title="0">return strings.TrimSpace(forwardedFor)</span>
                        }
                        <span class="cov8" title="1">if realIP := c.Get("X-Real-IP"); realIP != "" </span><span class="cov0" title="0">{
                                return realIP
                        }</span>
                        <span class="cov8" title="1">return c.IP()</span>
                },
                LimitReached: func(c *fiber.Ctx) error <span class="cov8" title="1">{
                        return common.ProblemDetailsJSON(c, "Too Many Requests", errors.New("rate limit exceeded"), fiber.StatusTooManyRequests)
                }</span>,
        }))
        <span class="cov8" title="1">app.Use(recover.New())

        app.Get("/", func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                return c.SendString("App is working! 🚀")
        }</span>)

        <span class="cov8" title="1">app.Post("/webhook/payment", account.PaymentWebhookHandler(accountSvc))

        account.Routes(app, accountSvc, authSvc, cfg)
        user.Routes(app, userSvc, authSvc, cfg)
        auth.Routes(app, authSvc)
        currency.Routes(app, currencySvc, authSvc, cfg)

        return app</span>
}
</pre>

		<pre class="file" id="file50" style="display: none">package auth

import (
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/gofiber/fiber/v2"
)

// Routes registers HTTP routes for authentication operations.
// Sets up endpoints for user login and authentication.
func Routes(app *fiber.App, authSvc *authsvc.AuthService) <span class="cov8" title="1">{
        app.Post("/auth/login", Login(authSvc))
}</span>

// Login handles user authentication and returns a JWT token.
// @Summary User login
// @Description Authenticate user with identity (username or email) and password
// @Tags auth
// @Accept json
// @Produce json
// @Param request body LoginInput true "Login credentials"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /auth/login [post]
func Login(authSvc *authsvc.AuthService) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                input, err := common.BindAndValidate[LoginInput](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // Error already written by BindAndValidate
                }</span>
                <span class="cov8" title="1">user, err := authSvc.Login(c.Context(), input.Identity, input.Password)
                if err != nil </span><span class="cov8" title="1">{
                        // Check if it's an unauthorized error
                        if err.Error() == "user unauthorized" </span><span class="cov8" title="1">{
                                return common.ProblemDetailsJSON(c, "Invalid identity or password", nil, "Identity or password is incorrect", fiber.StatusUnauthorized)
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(c, "Internal Server Error", err)</span>
                }
                <span class="cov8" title="1">if user == nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid identity or password", nil, "Identity or password is incorrect", fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">token, err := authSvc.GenerateToken(user)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Internal Server Error", err)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusOK, "Success login", fiber.Map{"token": token})</span>
        }
}
</pre>

		<pre class="file" id="file51" style="display: none">package common

import (
        "errors"

        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/domain/common"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
)

// Response defines the standard API response structure for success cases.
type Response struct {
        Status  int    `json:"status"`         // HTTP status code
        Message string `json:"message"`        // Human-readable explanation
        Data    any    `json:"data,omitempty"` // Response data
}

// ProblemDetails follows RFC 9457 Problem Details for HTTP APIs.
type ProblemDetails struct {
        Type     string `json:"type,omitempty"`     // A URI reference that identifies the problem type
        Title    string `json:"title"`              // Short, human-readable summary
        Status   int    `json:"status"`             // HTTP status code
        Detail   string `json:"detail,omitempty"`   // Human-readable explanation
        Instance string `json:"instance,omitempty"` // URI reference that identifies the specific occurrence
        Errors   any    `json:"errors,omitempty"`   // Optional: additional error details
}

// ProblemDetailsJSON writes a problem+json error response with a status code inferred from the error (if present).
// The title is set to the error message (if error), and detail can be a string, error, or structured object.
// Optionally, a status code can be provided as the last argument (int) to override the fallback status.
func ProblemDetailsJSON(c *fiber.Ctx, title string, err error, detailOrStatus ...any) error <span class="cov0" title="0">{
        status := fiber.StatusBadRequest
        pdDetail := ""
        var pdErrors any
        var customStatus *int

        if err != nil </span><span class="cov0" title="0">{
                status = errorToStatusCode(err)
                pdDetail = err.Error()
        }</span>
        // Check for custom detail or status code in variadic args
        <span class="cov0" title="0">for _, arg := range detailOrStatus </span><span class="cov0" title="0">{
                switch v := arg.(type) </span>{
                case int:<span class="cov0" title="0">
                        customStatus = &amp;v</span>
                case string:<span class="cov0" title="0">
                        pdDetail = v</span>
                case error:<span class="cov0" title="0">
                        pdDetail = v.Error()</span>
                default:<span class="cov0" title="0">
                        pdErrors = v</span>
                }
        }
        // Use custom status if provided
        <span class="cov0" title="0">if customStatus != nil </span><span class="cov0" title="0">{
                status = *customStatus
        }</span>
        <span class="cov0" title="0">pd := ProblemDetails{
                Type:     "about:blank",
                Status:   status,
                Title:    title,
                Detail:   pdDetail,
                Errors:   pdErrors,
                Instance: c.Path(),
        }
        c.Set(fiber.HeaderContentType, "application/problem+json")
        if err := c.Status(status).JSON(pd); err != nil </span><span class="cov0" title="0">{
                log.Errorf("ProblemDetailsJSON failed: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// BindAndValidate parses the request body and validates it using go-playground/validator.
// Returns a pointer to the struct (populated), or writes an error response and returns nil.
func BindAndValidate[T any](c *fiber.Ctx) (*T, error) <span class="cov0" title="0">{
        var input T
        if err := c.BodyParser(&amp;input); err != nil </span><span class="cov0" title="0">{
                return nil, ProblemDetailsJSON(c, "Invalid request body", err, "Request body could not be parsed or has invalid types", fiber.StatusBadRequest) //nolint:errcheck
        }</span>

        <span class="cov0" title="0">validate := validator.New()
        if err := validate.Struct(input); err != nil </span><span class="cov0" title="0">{
                if ve, ok := err.(validator.ValidationErrors); ok </span><span class="cov0" title="0">{
                        details := make(map[string]string)
                        for _, fe := range ve </span><span class="cov0" title="0">{
                                field := fe.Field()
                                msg := fe.Tag()
                                details[field] = msg
                        }</span>
                        <span class="cov0" title="0">return nil, ProblemDetailsJSON(c, "Validation failed", nil, "Request validation failed", details, fiber.StatusBadRequest)</span> //nolint:errcheck
                }
                <span class="cov0" title="0">ProblemDetailsJSON(c, "Validation failed", err, "Request validation failed", fiber.StatusBadRequest) //nolint:errcheck
                return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;input, nil</span>
}

// SuccessResponseJSON writes a JSON response with the given status, message, and data using the standard Response struct.
// Use for successful API responses (e.g., 200, 201, 202).
func SuccessResponseJSON(c *fiber.Ctx, status int, message string, data any) error <span class="cov0" title="0">{
        return c.Status(status).JSON(Response{
                Status:  status,
                Message: message,
                Data:    data,
        })
}</span>

// errorToStatusCode maps domain errors to appropriate HTTP status codes.
func errorToStatusCode(err error) int <span class="cov0" title="0">{
        switch </span>{
        // Account errors
        case errors.Is(err, domain.ErrAccountNotFound):<span class="cov0" title="0">
                return fiber.StatusNotFound</span>
        case errors.Is(err, domain.ErrDepositAmountExceedsMaxSafeInt):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, domain.ErrTransactionAmountMustBePositive):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, domain.ErrWithdrawalAmountMustBePositive):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, domain.ErrInsufficientFunds):<span class="cov0" title="0">
                return fiber.StatusUnprocessableEntity</span>
        // Common errors
        case errors.Is(err, domain.ErrInvalidCurrencyCode):<span class="cov0" title="0">
                return fiber.StatusUnprocessableEntity</span>
        case errors.Is(err, common.ErrInvalidDecimalPlaces):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, common.ErrAmountExceedsMaxSafeInt):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        // Money/currency conversion errors
        case errors.Is(err, domain.ErrExchangeRateUnavailable):<span class="cov0" title="0">
                return fiber.StatusServiceUnavailable</span>
        case errors.Is(err, domain.ErrUnsupportedCurrencyPair):<span class="cov0" title="0">
                return fiber.StatusUnprocessableEntity</span>
        case errors.Is(err, domain.ErrExchangeRateExpired):<span class="cov0" title="0">
                return fiber.StatusServiceUnavailable</span>
        case errors.Is(err, domain.ErrExchangeRateInvalid):<span class="cov0" title="0">
                return fiber.StatusUnprocessableEntity</span>
        // User errors
        case errors.Is(err, user.ErrUserNotFound):<span class="cov0" title="0">
                return fiber.StatusNotFound</span>
        case errors.Is(err, user.ErrUserUnauthorized):<span class="cov0" title="0">
                return fiber.StatusUnauthorized</span>
        default:<span class="cov0" title="0">
                return fiber.StatusInternalServerError</span>
        }
}
</pre>

		<pre class="file" id="file52" style="display: none">package currency

import (
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/middleware"
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        currencysvc "github.com/amirasaad/fintech/pkg/service/currency"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/gofiber/fiber/v2"
)

// Routes registers HTTP routes for currency-related operations.
// Sets up endpoints for listing, searching, and managing currencies.
func Routes(app *fiber.App, currencySvc *currencysvc.CurrencyService, authSvc *authsvc.AuthService, cfg *config.AppConfig) <span class="cov0" title="0">{
        currencyGroup := app.Group("/api/currencies")

        // Public endpoints
        currencyGroup.Get("/", ListCurrencies(currencySvc))
        currencyGroup.Get("/supported", ListSupportedCurrencies(currencySvc))
        currencyGroup.Get("/:code", GetCurrency(currencySvc))
        currencyGroup.Get("/:code/supported", CheckCurrencySupported(currencySvc))
        currencyGroup.Get("/search", SearchCurrencies(currencySvc))
        currencyGroup.Get("/region/:region", SearchCurrenciesByRegion(currencySvc))
        currencyGroup.Get("/statistics", GetCurrencyStatistics(currencySvc))
        currencyGroup.Get("/default", GetDefaultCurrency(currencySvc))

        // Admin endpoints (require authentication)
        adminGroup := currencyGroup.Group("/admin")
        adminGroup.Post("/", middleware.JwtProtected(cfg.Jwt), RegisterCurrency(currencySvc))
        adminGroup.Delete("/:code", middleware.JwtProtected(cfg.Jwt), UnregisterCurrency(currencySvc))
        adminGroup.Put("/:code/activate", middleware.JwtProtected(cfg.Jwt), ActivateCurrency(currencySvc))
        adminGroup.Put("/:code/deactivate", middleware.JwtProtected(cfg.Jwt), DeactivateCurrency(currencySvc))
}</span>

// ListCurrencies returns a Fiber handler for listing all available currencies.
// @Summary List all currencies
// @Description Get a list of all available currencies in the system
// @Tags currencies
// @Accept json
// @Produce json
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /currency [get]
// @Security Bearer
func ListCurrencies(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                currencies, err := currencySvc.ListAllCurrencies(c.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to list currencies", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currencies fetched successfully", currencies)</span>
        }
}

// ListSupportedCurrencies returns all supported currency codes
// @Summary List supported currencies
// @Description Get all supported currency codes
// @Tags currencies
// @Accept json
// @Produce json
// @Success 200 {array} string
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/supported [get]
func ListSupportedCurrencies(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                currencies, err := currencySvc.ListSupportedCurrencies(c.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to list supported currencies", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Supported currencies fetched successfully", currencies)</span>
        }
}

// GetCurrency returns currency information by code
// @Summary Get currency by code
// @Description Get currency information by ISO 4217 code
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code (e.g., USD, EUR)"
// @Success 200 {object} currency.CurrencyMeta
// @Failure 400 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/{code} [get]
func GetCurrency(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Currency code is required", nil, "Missing currency code", fiber.StatusBadRequest)
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCurrencyCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid currency code", err, "Currency code must be a valid ISO 4217 code", fiber.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">currency, err := currencySvc.GetCurrency(c.Context(), code)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Currency not found", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currency fetched successfully", currency)</span>
        }
}

// CheckCurrencySupported checks if a currency is supported
// @Summary Check if currency is supported
// @Description Check if a currency code is supported
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code (e.g., USD, EUR)"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Router /api/currencies/{code}/supported [get]
func CheckCurrencySupported(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Currency code is required", nil)
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCurrencyCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid currency code", err)
                }</span>

                <span class="cov0" title="0">supported := currencySvc.IsCurrencySupported(c.Context(), code)
                return common.SuccessResponseJSON(c, fiber.StatusOK, "Currency support checked successfully", fiber.Map{"code": code, "supported": supported})</span>
        }
}

// SearchCurrencies searches for currencies by name
// @Summary Search currencies
// @Description Search for currencies by name
// @Tags currencies
// @Accept json
// @Produce json
// @Param q query string true "Search query"
// @Success 200 {array} currency.CurrencyMeta
// @Failure 400 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/search [get]
func SearchCurrencies(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                query := c.Query("q")
                if query == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Search query is required", nil, "Missing search query", fiber.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">currencies, err := currencySvc.SearchCurrencies(c.Context(), query)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to search currencies", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currencies searched successfully", currencies)</span>
        }
}

// SearchCurrenciesByRegion searches for currencies by region
// @Summary Search currencies by region
// @Description Search for currencies by region
// @Tags currencies
// @Accept json
// @Produce json
// @Param region path string true "Region name"
// @Success 200 {array} currency.CurrencyMeta
// @Failure 400 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/region/{region} [get]
func SearchCurrenciesByRegion(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                region := c.Params("region")
                if region == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Region is required", nil, "Missing region", fiber.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">currencies, err := currencySvc.SearchCurrenciesByRegion(c.Context(), region)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to search currencies by region", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currencies by region fetched successfully", currencies)</span>
        }
}

// GetCurrencyStatistics returns currency statistics
// @Summary Get currency statistics
// @Description Get currency registry statistics
// @Tags currencies
// @Accept json
// @Produce json
// @Success 200 {object} common.Response
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/statistics [get]
func GetCurrencyStatistics(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                stats, err := currencySvc.GetCurrencyStatistics(c.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to get currency statistics", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currency statistics fetched successfully", stats)</span>
        }
}

// GetDefaultCurrency returns the default currency information
// @Summary Get default currency
// @Description Get the default currency information
// @Tags currencies
// @Accept json
// @Produce json
// @Success 200 {object} currency.CurrencyMeta
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/default [get]
func GetDefaultCurrency(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                defaultCurrency, err := currencySvc.GetDefaultCurrency(c.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to get default currency", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Default currency fetched successfully", defaultCurrency)</span>
        }
}

// RegisterCurrency registers a new currency (admin only)
// @Summary Register currency
// @Description Register a new currency (admin only)
// @Tags currencies
// @Accept json
// @Produce json
// @Param currency body RegisterCurrencyRequest true "Currency information"
// @Success 201 {object} currency.CurrencyMeta
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 409 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/admin [post]
func RegisterCurrency(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                input, err := common.BindAndValidate[RegisterCurrencyRequest](c)
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Error already written by BindAndValidate
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err = currencySvc.ValidateCurrencyCode(c.Context(), input.Code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid currency code", err)
                }</span>

                <span class="cov0" title="0">currencyMeta := currency.CurrencyMeta{
                        Code:     input.Code,
                        Name:     input.Name,
                        Symbol:   input.Symbol,
                        Decimals: input.Decimals,
                        Country:  input.Country,
                        Region:   input.Region,
                        Active:   input.Active,
                        Metadata: input.Metadata,
                }

                if err = currencySvc.RegisterCurrency(c.Context(), currencyMeta); err != nil </span><span class="cov0" title="0">{
                        if err == currency.ErrCurrencyExists </span><span class="cov0" title="0">{
                                return common.ProblemDetailsJSON(c, "Failed to register currency", err)
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(c, "Failed to register currency", err)</span>
                }

                // Get the registered currency
                <span class="cov0" title="0">registered, err := currencySvc.GetCurrency(c.Context(), input.Code)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to retrieve registered currency", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusCreated, "Currency registered successfully", registered)</span>
        }
}

// UnregisterCurrency removes a currency from the registry (admin only)
// @Summary Unregister currency
// @Description Remove a currency from the registry (admin only)
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/admin/{code} [delete]
func UnregisterCurrency(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Currency code is required", nil)
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCurrencyCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid currency code", err)
                }</span>

                <span class="cov0" title="0">if err := currencySvc.UnregisterCurrency(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        if err == currency.ErrCurrencyNotFound </span><span class="cov0" title="0">{
                                return common.ProblemDetailsJSON(c, "Failed to unregister currency", err)
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(c, "Failed to unregister currency", err)</span>
                }
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currency unregistered successfully", fiber.Map{"code": code})</span>
        }
}

// ActivateCurrency activates a currency (admin only)
// @Summary Activate currency
// @Description Activate a currency (admin only)
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/admin/{code}/activate [put]
func ActivateCurrency(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Currency code is required", nil)
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCurrencyCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid currency code", err)
                }</span>

                <span class="cov0" title="0">if err := currencySvc.ActivateCurrency(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        if err == currency.ErrCurrencyNotFound </span><span class="cov0" title="0">{
                                return common.ProblemDetailsJSON(c, "Failed to activate currency", err)
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(c, "Failed to activate currency", err)</span>
                }
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currency activated successfully", fiber.Map{"code": code})</span>
        }
}

// DeactivateCurrency deactivates a currency (admin only)
// @Summary Deactivate currency
// @Description Deactivate a currency (admin only)
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/admin/{code}/deactivate [put]
func DeactivateCurrency(currencySvc *currencysvc.CurrencyService) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Currency code is required", nil)
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCurrencyCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid currency code", err)
                }</span>

                <span class="cov0" title="0">if err := currencySvc.DeactivateCurrency(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        if err == currency.ErrCurrencyNotFound </span><span class="cov0" title="0">{
                                return common.ProblemDetailsJSON(c, "Failed to deactivate currency", err)
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(c, "Failed to deactivate currency", err)</span>
                }
                <span class="cov0" title="0">return common.SuccessResponseJSON(c, fiber.StatusOK, "Currency deactivated successfully", fiber.Map{"code": code})</span>
        }
}
</pre>

		<pre class="file" id="file53" style="display: none">package testutils

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "net/http/httptest"
        "os"
        "path/filepath"
        "runtime"
        "time"

        "github.com/amirasaad/fintech/app"
        "github.com/amirasaad/fintech/infra/eventbus"
        "github.com/amirasaad/fintech/infra/provider"
        infrarepo "github.com/amirasaad/fintech/infra/repository"
        fixturescurrency "github.com/amirasaad/fintech/internal/fixtures/currency"
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/currency"
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/webapi/common"

        "github.com/gofiber/fiber/v2"
        "github.com/golang-migrate/migrate/v4"
        migratepostgres "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file" // required for file-based migrations in tests
        "github.com/google/uuid"
        "github.com/stretchr/testify/suite"
        "github.com/testcontainers/testcontainers-go"
        tcpostgres "github.com/testcontainers/testcontainers-go/modules/postgres"
        "github.com/testcontainers/testcontainers-go/wait"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

// E2ETestSuite provides a test suite with a real Postgres database using Testcontainers
type E2ETestSuite struct {
        suite.Suite
        pgContainer *tcpostgres.PostgresContainer
        db          *gorm.DB
        app         *fiber.App
        cfg         *config.AppConfig
}

// BeforeEachTest runs before each test in the E2ETestSuite. It enables parallel test execution.
func (s *E2ETestSuite) BeforeEachTest() <span class="cov0" title="0">{
        s.T().Parallel()
}</span>

// SetupSuite initializes the test suite with a real Postgres database
func (s *E2ETestSuite) SetupSuite() <span class="cov0" title="0">{
        ctx := context.Background()

        // Start Postgres container
        pg, err := tcpostgres.Run(
                ctx,
                "postgres:15-alpine",
                tcpostgres.WithDatabase("testdb"),
                tcpostgres.WithUsername("test"),
                tcpostgres.WithPassword("test"),
                testcontainers.WithWaitStrategy(
                        wait.ForLog("database system is ready to accept connections").
                                WithOccurrence(2).WithStartupTimeout(30*time.Second),
                ),
        )
        s.Require().NoError(err)
        s.pgContainer = pg

        // Get connection string and connect to database
        dsn, err := pg.ConnectionString(ctx, "sslmode=disable")
        s.Require().NoError(err)

        s.db, err = gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        s.Require().NoError(err)

        // Run migrations
        sqlDB, err := s.db.DB()
        s.Require().NoError(err)

        driver, err := migratepostgres.WithInstance(sqlDB, &amp;migratepostgres.Config{})
        s.Require().NoError(err)

        _, filename, _, _ := runtime.Caller(0)
        migrationsPath := filepath.Join(filepath.Dir(filename), "../../internal/migrations")

        m, err := migrate.NewWithDatabaseInstance("file://"+migrationsPath, "postgres", driver)
        s.Require().NoError(err)

        err = m.Up()
        if err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                s.Require().NoError(err)
        }</span>

        // Load config
        <span class="cov0" title="0">cfgPath, err := s.findEnvTest()
        s.Require().NoError(err)
        s.cfg, err = config.LoadAppConfig(slog.Default(), cfgPath)
        s.Require().NoError(err)
        s.cfg.DB.Url = dsn

        // Setup services and app
        s.setupApp()</span>
        // log.SetOutput(io.Discard)
}

// TearDownSuite cleans up the test suite resources
func (s *E2ETestSuite) TearDownSuite() <span class="cov0" title="0">{
        ctx := context.Background()
        if s.pgContainer != nil </span><span class="cov0" title="0">{
                _ = s.pgContainer.Terminate(ctx)
        }</span>
}

// setupApp creates all services and the test app
func (s *E2ETestSuite) setupApp() <span class="cov0" title="0">{
        // Create deps
        uow := infrarepo.NewUoW(s.db)
        logger := slog.Default()
        currencyConverter := provider.NewStubCurrencyConverter()

        // Setup currency service
        ctx := context.Background()
        currencyRegistry, err := currency.NewRegistry(ctx)
        s.Require().NoError(err)

        // Load currency fixtures
        _, filename, _, _ := runtime.Caller(0)
        fixturePath := filepath.Join(filepath.Dir(filename), "../../internal/fixtures/currency/meta.csv")
        metas, err := fixturescurrency.LoadCurrencyMetaCSV(fixturePath)
        s.Require().NoError(err)

        for _, meta := range metas </span><span class="cov0" title="0">{
                s.Require().NoError(currencyRegistry.Register(meta))
        }</span>

        // Create test app
        <span class="cov0" title="0">s.app = app.New(
                config.Deps{
                        CurrencyConverter: currencyConverter,
                        CurrencyRegistry:  currencyRegistry,
                        Uow:               uow,
                        PaymentProvider:   provider.NewMockPaymentProvider(),
                        EventBus:          eventbus.NewMemoryEventBus(),
                        Logger:            logger,
                        Config:            s.cfg,
                },
        )</span>
}

// findEnvTest searches for the nearest .env.test file
func (s *E2ETestSuite) findEnvTest() (string, error) <span class="cov0" title="0">{
        startDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">curr := startDir
        for </span><span class="cov0" title="0">{
                candidate := filepath.Join(curr, ".env.test")
                if _, err = os.Stat(candidate); err == nil </span><span class="cov0" title="0">{
                        return candidate, nil
                }</span>
                <span class="cov0" title="0">parent := filepath.Dir(curr)
                if parent == curr </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">curr = parent</span>
        }
        <span class="cov0" title="0">return "", os.ErrNotExist</span>
}

// MakeRequest is a helper for making HTTP requests in tests
func (s *E2ETestSuite) MakeRequest(method, path, body, token string) *http.Response <span class="cov0" title="0">{
        var req *http.Request
        if body != "" </span><span class="cov0" title="0">{
                req = httptest.NewRequest(method, path, bytes.NewBufferString(body))
                req.Header.Set("Content-Type", "application/json")
        }</span> else<span class="cov0" title="0"> {
                req = httptest.NewRequest(method, path, nil)
        }</span>
        <span class="cov0" title="0">if token != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+token)
        }</span>
        <span class="cov0" title="0">resp, err := s.app.Test(req, 1000000)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return resp</span>
}

// CreateTestUser creates a unique test user via the POST /user/ endpoint
func (s *E2ETestSuite) CreateTestUser() *domain.User <span class="cov0" title="0">{
        randomID := uuid.New().String()[:8]
        username := fmt.Sprintf("testuser_%s", randomID)
        email := fmt.Sprintf("test_%s@example.com", randomID)

        // Create user via HTTP POST request
        createUserBody := fmt.Sprintf(`{"username":"%s","email":"%s","password":"password123"}`, username, email)
        resp := s.MakeRequest("POST", "/user", createUserBody, "")

        if resp.StatusCode != 201 </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Expected 201 Created for user creation, got %d", resp.StatusCode))</span>
        }

        // Parse response to get the created user
        <span class="cov0" title="0">var response common.Response
        err := json.NewDecoder(resp.Body).Decode(&amp;response)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Extract user data from response
        <span class="cov0" title="0">if userData, ok := response.Data.(map[string]any); ok </span><span class="cov0" title="0">{
                userIDStr, ok := userData["id"].(string)
                if !ok </span><span class="cov0" title="0">{
                        panic("User ID should be present in response")</span>
                }

                <span class="cov0" title="0">userID, err := uuid.Parse(userIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">return &amp;domain.User{
                        ID:       userID,
                        Username: username,
                        Email:    email,
                        Password: "password123",
                }</span>
        }

        // Fallback: create user directly
        <span class="cov0" title="0">testUser, err := user.NewUser(username, email, "password123")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return testUser</span>
}

// LoginUser makes an actual HTTP request to login and returns the JWT token
func (s *E2ETestSuite) LoginUser(testUser *domain.User) string <span class="cov0" title="0">{
        loginBody := fmt.Sprintf(`{"identity":"%s","password":"password123"}`, testUser.Email)
        resp := s.MakeRequest("POST", "/auth/login", loginBody, "")

        var response common.Response
        err := json.NewDecoder(resp.Body).Decode(&amp;response)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Extract token from response
        <span class="cov0" title="0">var token string
        if dataMap, ok := response.Data.(map[string]any); ok </span><span class="cov0" title="0">{
                if tokenInterface, exists := dataMap["token"]; exists </span><span class="cov0" title="0">{
                        token = tokenInterface.(string)
                }</span>
        } else<span class="cov0" title="0"> if dataMap, ok := response.Data.(map[string]string); ok </span><span class="cov0" title="0">{
                token = dataMap["token"]
        }</span>

        <span class="cov0" title="0">if token == "" </span><span class="cov0" title="0">{
                panic("No token found in response")</span>
        }
        <span class="cov0" title="0">return token</span>
}
</pre>

		<pre class="file" id="file54" style="display: none">package user

import (
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/middleware"
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        usersvc "github.com/amirasaad/fintech/pkg/service/user"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

// Routes registers HTTP routes for user-related operations.
// Sets up endpoints for user creation, retrieval, update, and deletion.
func Routes(app *fiber.App, userSvc *usersvc.Service, authSvc *authsvc.AuthService, cfg *config.AppConfig) <span class="cov8" title="1">{
        app.Get("/user/:id", middleware.JwtProtected(cfg.Jwt), GetUser(userSvc))
        app.Post("/user", CreateUser(userSvc))
        app.Put("/user/:id", middleware.JwtProtected(cfg.Jwt), UpdateUser(userSvc, authSvc))
        app.Delete("/user/:id", middleware.JwtProtected(cfg.Jwt), DeleteUser(userSvc, authSvc))
}</span>

// GetUser returns a Fiber handler for retrieving a user by ID.
// @Summary Get user by ID
// @Description Retrieve a user by their ID
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Router /user/{id} [get]
// @Security Bearer
func GetUser(userSvc *usersvc.Service) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid user ID: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err, "User ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">user, err := userSvc.GetUser(c.Context(), id.String())
                if err != nil || user == nil </span><span class="cov8" title="1">{
                        // Generic error for not found to prevent user enumeration
                        return common.ProblemDetailsJSON(c, "Invalid credentials", nil, fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusOK, "User found", user)</span>
        }
}

// CreateUser creates a new user account.
// @Summary Create a new user
// @Description Create a new user account with username, email, and password
// @Tags users
// @Accept json
// @Produce json
// @Param request body NewUser true "User creation data"
// @Success 201 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /user [post]
func CreateUser(userSvc *usersvc.Service) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                input, err := common.BindAndValidate[NewUser](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">if len(input.Password) &gt; 72 </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid request body", nil, "Password too long")
                }</span>
                <span class="cov8" title="1">user, err := userSvc.CreateUser(c.Context(), input.Username, input.Email, input.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Couldn't create user", err)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusCreated, "Created user", user)</span>
        }
}

// UpdateUser updates user information.
// @Summary Update user
// @Description Update user information by ID
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Param request body UpdateUserInput true "User update data"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /user/{id} [put]
// @Security Bearer
func UpdateUser(
        userSvc *usersvc.Service,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                input, err := common.BindAndValidate[UpdateUserInput](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid user ID: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err, "User ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context", fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">if id != userID </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Forbidden", nil, "You are not allowed to update this user", fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">err = userSvc.UpdateUser(c.Context(), id.String(), func(u *user.User) error </span><span class="cov8" title="1">{
                        u.Names = input.Names
                        return nil
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        // Generic error for update failure
                        return common.ProblemDetailsJSON(c, "Invalid credentials", nil, fiber.StatusUnauthorized)
                }</span>
                // Get the updated user to return in response
                <span class="cov8" title="1">updatedUser, err := userSvc.GetUser(c.Context(), id.String())
                if err != nil || updatedUser == nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Invalid credentials", nil, fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusOK, "User updated successfully", updatedUser)</span>
        }
}

// DeleteUser deletes a user account.
// @Summary Delete user
// @Description Delete a user account by ID with password confirmation
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Param request body PasswordInput true "Password confirmation"
// @Success 204 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /user/{id} [delete]
// @Security Bearer
func DeleteUser(
        userSvc *usersvc.Service,
        authSvc *authsvc.AuthService,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                input, err := common.BindAndValidate[PasswordInput](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid user ID: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err, "User ID must be a valid UUID", fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context", fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">if id != userID </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Forbidden", nil, "You are not allowed to update this user", fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">isValid, err := userSvc.ValidUser(c.Context(), id.String(), input.Password)
                if err != nil </span><span class="cov0" title="0">{
                        // If this is a DB/internal error, return 500
                        return common.ProblemDetailsJSON(c, "Failed to validate user", err, fiber.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">if !isValid </span><span class="cov8" title="1">{
                        // Invalid password or user not found
                        return common.ProblemDetailsJSON(c, "Invalid credentials", nil, fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">err = userSvc.DeleteUser(c.Context(), id.String())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to delete user", err, fiber.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusNoContent, "User successfully deleted", nil)</span>
        }
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
