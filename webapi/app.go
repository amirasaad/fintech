package webapi

import (
	"errors"
	"strings"
	"time"

	"github.com/amirasaad/fintech/pkg/config"
	accountsvc "github.com/amirasaad/fintech/pkg/service/account"
	authsvc "github.com/amirasaad/fintech/pkg/service/auth"
	currencysvc "github.com/amirasaad/fintech/pkg/service/currency"
	usersvc "github.com/amirasaad/fintech/pkg/service/user"
	"github.com/amirasaad/fintech/webapi/account"
	"github.com/amirasaad/fintech/webapi/auth"
	"github.com/amirasaad/fintech/webapi/common"
	"github.com/amirasaad/fintech/webapi/currency"
	"github.com/amirasaad/fintech/webapi/user"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/limiter"
	"github.com/gofiber/fiber/v2/middleware/recover"
	"github.com/gofiber/swagger"

	// docs are generated by Swag CLI, you have to import them.
	_ "github.com/amirasaad/fintech/docs"
)

func NewApp(
	accountSvc *accountsvc.AccountService,
	userSvc *usersvc.UserService,
	authSvc *authsvc.AuthService,
	currencySvc *currencysvc.CurrencyService,
	cfg *config.AppConfig,
) *fiber.App {
	// Configure rate limits with reasonable defaults
	maxRequests := 5 // 5 requests per minute by default
	expiration := 1 * time.Minute

	// Override with config if available
	if cfg.RateLimit.MaxRequests > 0 {
		maxRequests = cfg.RateLimit.MaxRequests
	}
	if cfg.RateLimit.Window > 0 {
		expiration = cfg.RateLimit.Window
	}

	app := fiber.New(fiber.Config{
		ErrorHandler: func(c *fiber.Ctx, err error) error {
			return common.ProblemDetailsJSON(c, "Internal Server Error", err)
		},
	})
	app.Get("/swagger/*", swagger.New(swagger.Config{
		TryItOutEnabled:      true,
		WithCredentials:      true,
		PersistAuthorization: true,
		OAuth2RedirectUrl:    "/auth/login",
	}))

	app.Use(limiter.New(limiter.Config{
		Max:        maxRequests,
		Expiration: expiration,
		KeyGenerator: func(c *fiber.Ctx) string {
			// Use X-Forwarded-For header if available (for load balancers/proxies)
			// Fall back to X-Real-IP, then to direct IP
			if forwardedFor := c.Get("X-Forwarded-For"); forwardedFor != "" {
				// Take the first IP in the chain
				if commaIndex := strings.Index(forwardedFor, ","); commaIndex != -1 {
					return strings.TrimSpace(forwardedFor[:commaIndex])
				}
				return strings.TrimSpace(forwardedFor)
			}
			if realIP := c.Get("X-Real-IP"); realIP != "" {
				return realIP
			}
			return c.IP()
		},
		LimitReached: func(c *fiber.Ctx) error {
			return common.ProblemDetailsJSON(c, "Too Many Requests", errors.New("rate limit exceeded"), fiber.StatusTooManyRequests)
		},
	}))
	app.Use(recover.New())

	app.Get("/", func(c *fiber.Ctx) error {
		return c.SendString("App is working! ðŸš€")
	})

	account.Routes(app, accountSvc, authSvc, cfg)
	user.Routes(app, userSvc, authSvc, cfg)
	auth.Routes(app, authSvc)
	currency.Routes(app, currencySvc, authSvc, cfg)

	return app
}
