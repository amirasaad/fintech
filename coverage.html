
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>caching: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/amirasaad/fintech/infra/caching/exchange_cache.go (0.0%)</option>

				<option value="file1">github.com/amirasaad/fintech/infra/database.go (0.0%)</option>

				<option value="file2">github.com/amirasaad/fintech/infra/eventbus/memory.go (0.0%)</option>

				<option value="file3">github.com/amirasaad/fintech/infra/eventbus/redis.go (72.6%)</option>

				<option value="file4">github.com/amirasaad/fintech/infra/eventbus/stream_map.go (87.5%)</option>

				<option value="file5">github.com/amirasaad/fintech/infra/initializer/initializer.go (0.0%)</option>

				<option value="file6">github.com/amirasaad/fintech/infra/initializer/registry_provider.go (0.0%)</option>

				<option value="file7">github.com/amirasaad/fintech/infra/initializer/setuplogger.go (0.0%)</option>

				<option value="file8">github.com/amirasaad/fintech/infra/provider/exchangerate_api.go (0.0%)</option>

				<option value="file9">github.com/amirasaad/fintech/infra/provider/mock_exchange_rate.go (0.0%)</option>

				<option value="file10">github.com/amirasaad/fintech/infra/provider/mock_payment.go (0.0%)</option>

				<option value="file11">github.com/amirasaad/fintech/infra/provider/stripe_payment.go (0.0%)</option>

				<option value="file12">github.com/amirasaad/fintech/infra/provider/types.go (0.0%)</option>

				<option value="file13">github.com/amirasaad/fintech/infra/repository/account/model.go (0.0%)</option>

				<option value="file14">github.com/amirasaad/fintech/infra/repository/account/repository.go (0.0%)</option>

				<option value="file15">github.com/amirasaad/fintech/infra/repository/transaction/model.go (0.0%)</option>

				<option value="file16">github.com/amirasaad/fintech/infra/repository/transaction/repository.go (0.0%)</option>

				<option value="file17">github.com/amirasaad/fintech/infra/repository/uow.go (0.0%)</option>

				<option value="file18">github.com/amirasaad/fintech/infra/repository/user/model.go (0.0%)</option>

				<option value="file19">github.com/amirasaad/fintech/infra/repository/user/repository.go (0.0%)</option>

				<option value="file20">github.com/amirasaad/fintech/pkg/app/app.go (0.0%)</option>

				<option value="file21">github.com/amirasaad/fintech/pkg/app/setup_eventbus.go (0.0%)</option>

				<option value="file22">github.com/amirasaad/fintech/pkg/config/load.go (0.0%)</option>

				<option value="file23">github.com/amirasaad/fintech/pkg/config/utils.go (0.0%)</option>

				<option value="file24">github.com/amirasaad/fintech/pkg/currency/currency.go (60.6%)</option>

				<option value="file25">github.com/amirasaad/fintech/pkg/domain/account/account.go (75.4%)</option>

				<option value="file26">github.com/amirasaad/fintech/pkg/domain/account/transaction.go (0.0%)</option>

				<option value="file27">github.com/amirasaad/fintech/pkg/domain/events/common_factory.go (100.0%)</option>

				<option value="file28">github.com/amirasaad/fintech/pkg/domain/events/conversion.go (12.5%)</option>

				<option value="file29">github.com/amirasaad/fintech/pkg/domain/events/conversion_factory.go (0.0%)</option>

				<option value="file30">github.com/amirasaad/fintech/pkg/domain/events/deposit.go (80.0%)</option>

				<option value="file31">github.com/amirasaad/fintech/pkg/domain/events/deposit_factory.go (0.0%)</option>

				<option value="file32">github.com/amirasaad/fintech/pkg/domain/events/event_type.go (100.0%)</option>

				<option value="file33">github.com/amirasaad/fintech/pkg/domain/events/fees.go (0.0%)</option>

				<option value="file34">github.com/amirasaad/fintech/pkg/domain/events/fees_factory.go (0.0%)</option>

				<option value="file35">github.com/amirasaad/fintech/pkg/domain/events/payment.go (0.0%)</option>

				<option value="file36">github.com/amirasaad/fintech/pkg/domain/events/payment_factory.go (0.0%)</option>

				<option value="file37">github.com/amirasaad/fintech/pkg/domain/events/transfer.go (0.0%)</option>

				<option value="file38">github.com/amirasaad/fintech/pkg/domain/events/transfer_factory.go (0.0%)</option>

				<option value="file39">github.com/amirasaad/fintech/pkg/domain/events/types.go (0.0%)</option>

				<option value="file40">github.com/amirasaad/fintech/pkg/domain/events/withdraw.go (0.0%)</option>

				<option value="file41">github.com/amirasaad/fintech/pkg/domain/events/withdraw_factory.go (0.0%)</option>

				<option value="file42">github.com/amirasaad/fintech/pkg/domain/types.go (0.0%)</option>

				<option value="file43">github.com/amirasaad/fintech/pkg/domain/user/user.go (66.7%)</option>

				<option value="file44">github.com/amirasaad/fintech/pkg/exchange/core/errors.go (0.0%)</option>

				<option value="file45">github.com/amirasaad/fintech/pkg/exchange/service/service.go (0.0%)</option>

				<option value="file46">github.com/amirasaad/fintech/pkg/handler/account/deposit/currency_converted.go (0.0%)</option>

				<option value="file47">github.com/amirasaad/fintech/pkg/handler/account/deposit/requested.go (0.0%)</option>

				<option value="file48">github.com/amirasaad/fintech/pkg/handler/account/transfer/completed.go (0.0%)</option>

				<option value="file49">github.com/amirasaad/fintech/pkg/handler/account/transfer/currency_converted.go (57.9%)</option>

				<option value="file50">github.com/amirasaad/fintech/pkg/handler/account/transfer/requested.go (78.8%)</option>

				<option value="file51">github.com/amirasaad/fintech/pkg/handler/account/withdraw/currency_converted.go (0.0%)</option>

				<option value="file52">github.com/amirasaad/fintech/pkg/handler/account/withdraw/requested.go (0.0%)</option>

				<option value="file53">github.com/amirasaad/fintech/pkg/handler/common/common.go (0.0%)</option>

				<option value="file54">github.com/amirasaad/fintech/pkg/handler/conversion/currency_converted.go (100.0%)</option>

				<option value="file55">github.com/amirasaad/fintech/pkg/handler/conversion/factories.go (100.0%)</option>

				<option value="file56">github.com/amirasaad/fintech/pkg/handler/conversion/requested.go (89.2%)</option>

				<option value="file57">github.com/amirasaad/fintech/pkg/handler/conversion/test_helpers.go (0.0%)</option>

				<option value="file58">github.com/amirasaad/fintech/pkg/handler/fees/calculated.go (75.0%)</option>

				<option value="file59">github.com/amirasaad/fintech/pkg/handler/fees/calculator.go (72.5%)</option>

				<option value="file60">github.com/amirasaad/fintech/pkg/handler/payment/completed.go (70.6%)</option>

				<option value="file61">github.com/amirasaad/fintech/pkg/handler/payment/failed.go (72.4%)</option>

				<option value="file62">github.com/amirasaad/fintech/pkg/handler/payment/initiated.go (100.0%)</option>

				<option value="file63">github.com/amirasaad/fintech/pkg/handler/payment/processed.go (29.4%)</option>

				<option value="file64">github.com/amirasaad/fintech/pkg/handler/payment/test_helpers.go (93.5%)</option>

				<option value="file65">github.com/amirasaad/fintech/pkg/handler/testutils/test_helper.go (0.0%)</option>

				<option value="file66">github.com/amirasaad/fintech/pkg/mapper/mapper.go (0.0%)</option>

				<option value="file67">github.com/amirasaad/fintech/pkg/middleware/auth.go (100.0%)</option>

				<option value="file68">github.com/amirasaad/fintech/pkg/money/money.go (65.1%)</option>

				<option value="file69">github.com/amirasaad/fintech/pkg/money/v2/currency.go (75.0%)</option>

				<option value="file70">github.com/amirasaad/fintech/pkg/money/v2/money.go (50.0%)</option>

				<option value="file71">github.com/amirasaad/fintech/pkg/provider/cache.go (0.0%)</option>

				<option value="file72">github.com/amirasaad/fintech/pkg/provider/util.go (0.0%)</option>

				<option value="file73">github.com/amirasaad/fintech/pkg/queries/account.go (0.0%)</option>

				<option value="file74">github.com/amirasaad/fintech/pkg/registry/deprecated.go (33.3%)</option>

				<option value="file75">github.com/amirasaad/fintech/pkg/registry/enhanced_registry.go (48.9%)</option>

				<option value="file76">github.com/amirasaad/fintech/pkg/registry/factory.go (31.6%)</option>

				<option value="file77">github.com/amirasaad/fintech/pkg/registry/implementations.go (60.6%)</option>

				<option value="file78">github.com/amirasaad/fintech/pkg/registry/implementations/base_entity.go (0.0%)</option>

				<option value="file79">github.com/amirasaad/fintech/pkg/registry/interface.go (30.2%)</option>

				<option value="file80">github.com/amirasaad/fintech/pkg/registry/redis_helpers.go (0.0%)</option>

				<option value="file81">github.com/amirasaad/fintech/pkg/registry/registry.go (95.8%)</option>

				<option value="file82">github.com/amirasaad/fintech/pkg/service/account/account.go (86.0%)</option>

				<option value="file83">github.com/amirasaad/fintech/pkg/service/account/queries.go (73.7%)</option>

				<option value="file84">github.com/amirasaad/fintech/pkg/service/auth/auth.go (45.1%)</option>

				<option value="file85">github.com/amirasaad/fintech/pkg/service/checkout/service.go (67.2%)</option>

				<option value="file86">github.com/amirasaad/fintech/pkg/service/currency/service.go (81.6%)</option>

				<option value="file87">github.com/amirasaad/fintech/pkg/service/exchange/service.go (14.7%)</option>

				<option value="file88">github.com/amirasaad/fintech/pkg/service/user/user.go (66.3%)</option>

				<option value="file89">github.com/amirasaad/fintech/pkg/utils/utils.go (100.0%)</option>

				<option value="file90">github.com/amirasaad/fintech/webapi/account/account.go (47.4%)</option>

				<option value="file91">github.com/amirasaad/fintech/webapi/account/dto.go (0.0%)</option>

				<option value="file92">github.com/amirasaad/fintech/webapi/auth/auth.go (81.2%)</option>

				<option value="file93">github.com/amirasaad/fintech/webapi/checkout/checkout.go (61.1%)</option>

				<option value="file94">github.com/amirasaad/fintech/webapi/common/utils.go (0.0%)</option>

				<option value="file95">github.com/amirasaad/fintech/webapi/currency/currency.go (0.0%)</option>

				<option value="file96">github.com/amirasaad/fintech/webapi/currency/dto.go (0.0%)</option>

				<option value="file97">github.com/amirasaad/fintech/webapi/payment/stripe_webhook.go (0.0%)</option>

				<option value="file98">github.com/amirasaad/fintech/webapi/testutils/testutils.go (0.0%)</option>

				<option value="file99">github.com/amirasaad/fintech/webapi/user/user.go (70.5%)</option>

				<option value="file100">github.com/amirasaad/fintech/webapi/webapi.go (78.6%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package caching

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/amirasaad/fintech/pkg/registry"
)

// ExchangeCache handles bulk caching of exchange rates
// in the infrastructure layer
type ExchangeCache struct {
        exchangeRegistry registry.Provider
        logger           *slog.Logger
        cacheTTL         time.Duration
}

// NewExchangeCache creates a new ExchangeCache instance
func NewExchangeCache(
        exchangeRegistry registry.Provider,
        logger *slog.Logger,
        cacheTTL time.Duration,
) *ExchangeCache <span class="cov0" title="0">{
        return &amp;ExchangeCache{
                exchangeRegistry: exchangeRegistry,
                logger:           logger,
                cacheTTL:         cacheTTL,
        }
}</span>

// CacheRates caches multiple exchange rates in a single operation
func (c *ExchangeCache) CacheRates(
        ctx context.Context,
        rates map[string]*provider.ExchangeInfo,
        source string,
) error <span class="cov0" title="0">{
        if len(rates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var firstErr error
        count := 0
        for to, rate := range rates </span><span class="cov0" title="0">{
                if rate == nil </span><span class="cov0" title="0">{
                        c.logger.Error("Skipping nil rate", "to", to)
                        continue</span>
                }

                // Create cache entry
                <span class="cov0" title="0">cacheKey := fmt.Sprintf("%s:%s", rate.OriginalCurrency, to)
                cacheEntry := &amp;exchangeRateInfo{
                        BaseEntity: *registry.NewBaseEntity(cacheKey, cacheKey),
                        From:       rate.OriginalCurrency,
                        To:         to,
                        Rate:       rate.ConversionRate,
                        Source:     source,
                        Timestamp:  time.Now().UTC(),
                }

                // Save to registry
                if err := c.exchangeRegistry.Register(ctx, cacheEntry); err != nil </span><span class="cov0" title="0">{
                        c.logger.Error("Failed to cache rate",
                                "from", rate.OriginalCurrency,
                                "to", to,
                                "error", err)
                        continue</span>
                }

                // Cache the inverse rate as well
                <span class="cov0" title="0">inverseRate := 1 / rate.ConversionRate
                inverseKey := fmt.Sprintf("%s:%s", to, rate.OriginalCurrency)
                inverseEntry := &amp;exchangeRateInfo{
                        BaseEntity: *registry.NewBaseEntity(inverseKey, inverseKey),
                        From:       to,
                        To:         rate.OriginalCurrency,
                        Rate:       inverseRate,
                        Source:     source,
                        Timestamp:  time.Now().UTC(),
                }

                if err := c.exchangeRegistry.Register(ctx, inverseEntry); err != nil </span><span class="cov0" title="0">{
                        c.logger.Error("Failed to cache inverse rate",
                                "from", to,
                                "to", rate.OriginalCurrency,
                                "error", err)
                }</span>
        }

        // Update last updated timestamp
        <span class="cov0" title="0">lastUpdated := &amp;exchangeRateInfo{
                BaseEntity: *registry.NewBaseEntity("exr:last_updated", "exr:last_updated"),
                Timestamp:  time.Now().UTC(),
        }

        if err := c.exchangeRegistry.Register(ctx, lastUpdated); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to update last_updated timestamp", "error", err)
                firstErr = fmt.Errorf("failed to update last_updated timestamp: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Successfully cached exchange rates",
                "num_rates", count,
                "source", source,
        )

        return firstErr</span>
}

// exchangeRateInfo is a private type used for caching exchange rates
// It implements registry.Entity
// This is a copy of the ExchangeRateInfo from the exchange package
type exchangeRateInfo struct {
        registry.BaseEntity
        From      string
        To        string
        Rate      float64
        Source    string
        Timestamp time.Time
}

// ID returns the unique identifier for the rate info
func (e *exchangeRateInfo) ID() string <span class="cov0" title="0">{
        return e.BaseEntity.ID()
}</span>

// Name returns a human-readable name for the rate info
func (e *exchangeRateInfo) Name() string <span class="cov0" title="0">{
        return e.BaseEntity.Name()
}</span>
</pre>

		<pre class="file" id="file1" style="display: none">package infra

import (
        "errors"
        "time"

        "github.com/amirasaad/fintech/pkg/config"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

// Add appEnv as a parameter for dependency-injected environment
func NewDBConnection(
        cnf *config.DB,
        appEnv string,
) (*gorm.DB, error) <span class="cov0" title="0">{
        databaseUrl := cnf.Url
        if databaseUrl == "" </span><span class="cov0" title="0">{
                return nil, errors.New("DATABASE_URL is not set")
        }</span>

        <span class="cov0" title="0">var logMode logger.LogLevel
        if appEnv == "development" </span><span class="cov0" title="0">{
                logMode = logger.Info
        }</span> else<span class="cov0" title="0"> {
                logMode = logger.Silent
        }</span>

        <span class="cov0" title="0">connection, err := gorm.Open(postgres.Open(databaseUrl), &amp;gorm.Config{
                Logger:                 logger.Default.LogMode(logMode),
                SkipDefaultTransaction: true})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sqlDB, err := connection.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(25)
        sqlDB.SetMaxIdleConns(25)
        sqlDB.SetConnMaxLifetime(1 * time.Hour)

        return connection, nil</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">package eventbus

import (
        "context"
        "github.com/amirasaad/fintech/pkg/domain/events"
        "log/slog"
        "sync"

        "github.com/amirasaad/fintech/pkg/eventbus"
)

const EventDepthKey = "eventDepth"
const MaxEventDepth = 10

// MemoryEventBus is a simple in-memory implementation of the EventBus interface.
type MemoryEventBus struct {
        handlers  map[events.EventType][]eventbus.HandlerFunc
        mu        sync.RWMutex
        logger    *slog.Logger
        published []events.Event // Added for testing purposes
}

// NewWithMemory creates a new in-memory event bus for event-driven
// communication.
func NewWithMemory(logger *slog.Logger) *MemoryEventBus <span class="cov0" title="0">{
        return &amp;MemoryEventBus{
                handlers:  make(map[events.EventType][]eventbus.HandlerFunc),
                logger:    logger.With("bus", "memory"),
                published: make([]events.Event, 0), // Initialize the slice
        }
}</span>

// Register registers a handler for a specific event type.
func (b *MemoryEventBus) Register(
        eventType events.EventType,
        handler eventbus.HandlerFunc,
) <span class="cov0" title="0">{
        b.mu.Lock()
        defer b.mu.Unlock()
        b.handlers[eventType] = append(b.handlers[eventType], handler)
}</span>

// Emit dispatches the event to all registered handlers for its type.
func (b *MemoryEventBus) Emit(ctx context.Context, event events.Event) error <span class="cov0" title="0">{
        eventType := events.EventType(event.Type())
        b.mu.RLock()
        handlers := b.handlers[eventType]
        b.mu.RUnlock()

        // Store the published event for testing
        b.mu.Lock()
        b.published = append(b.published, event)
        b.mu.Unlock()

        for _, handler := range handlers </span><span class="cov0" title="0">{
                handler(ctx, event) //nolint:errcheck
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ClearPublished clears the list of published events.
// This is useful for testing.
func (b *MemoryEventBus) ClearPublished() <span class="cov0" title="0">{
        b.mu.Lock()
        defer b.mu.Unlock()
        b.published = make([]events.Event, 0)
}</span>

// Published returns the list of published events. This is useful for testing.
func (b *MemoryEventBus) Published() []events.Event <span class="cov0" title="0">{
        b.mu.RLock()
        defer b.mu.RUnlock()
        return b.published
}</span>

// Ensure MemoryEventBus implements the EventBus interface.
var _ eventbus.Bus = (*MemoryEventBus)(nil)

// MemoryAsyncEventBus is a registry-based in-memory event bus implementation.
type MemoryAsyncEventBus struct {
        handlers map[events.EventType][]eventbus.HandlerFunc
        mu       sync.RWMutex
        eventCh  chan struct {
                ctx   context.Context
                event events.Event
        }
        log *slog.Logger
}

// NewWithMemoryAsync creates a new registry-based in-memory event bus.
func NewWithMemoryAsync(logger *slog.Logger) *MemoryAsyncEventBus <span class="cov0" title="0">{
        b := &amp;MemoryAsyncEventBus{
                handlers: make(map[events.EventType][]eventbus.HandlerFunc),
                eventCh: make(chan struct {
                        ctx   context.Context
                        event events.Event
                }, 100),
        }
        go b.process()
        b.log = logger.With("event-bus", "memory")
        return b
}</span>

func (b *MemoryAsyncEventBus) Register(
        eventType events.EventType,
        handler eventbus.HandlerFunc,
) <span class="cov0" title="0">{
        b.mu.Lock()
        defer b.mu.Unlock()
        b.handlers[eventType] = append(b.handlers[eventType], handler)
}</span>

func (b *MemoryAsyncEventBus) Emit(
        ctx context.Context,
        event events.Event,
) error <span class="cov0" title="0">{
        b.eventCh &lt;- struct {
                ctx   context.Context
                event events.Event
        }{ctx, event}
        return nil
}</span>

// getHandlers returns a copy of the handlers for the given event type.
func (b *MemoryAsyncEventBus) getHandlers(
        eventType events.EventType,
) []eventbus.HandlerFunc <span class="cov0" title="0">{
        b.mu.RLock()
        defer b.mu.RUnlock()
        handlers := make([]eventbus.HandlerFunc, len(b.handlers[eventType]))
        copy(handlers, b.handlers[eventType])
        return handlers
}</span>

func (b *MemoryAsyncEventBus) process() <span class="cov0" title="0">{
        for item := range b.eventCh </span><span class="cov0" title="0">{
                eventType := events.EventType(item.event.Type())
                handlers := b.getHandlers(eventType)
                for _, handler := range handlers </span><span class="cov0" title="0">{
                        go func(
                                h eventbus.HandlerFunc,
                                ctx context.Context,
                                evt events.Event,
                        ) </span><span class="cov0" title="0">{
                                if err := h(ctx, evt); err != nil </span><span class="cov0" title="0">{
                                        b.log.Error("error handling event", "error", err, "event_type", eventType)
                                }</span>
                        }(handler, item.ctx, item.event)
                }
        }
}

// Ensure MemoryRegistryEventBus implements the Bus interface.
var _ eventbus.Bus = (*MemoryAsyncEventBus)(nil)
</pre>

		<pre class="file" id="file3" style="display: none">package eventbus

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "strings"
        "sync"
        "time"

        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/redis/go-redis/v9"
)

type envelope struct {
        Type    string          `json:"type"`
        Payload json.RawMessage `json:"payload"`
}

// RedisEventBus implements a production-ready event bus using Redis Streams.
type RedisEventBus struct {
        client      *redis.Client
        handlers    map[events.EventType][]eventbus.HandlerFunc
        handlersMtx sync.RWMutex
        logger      *slog.Logger
}

// NewWithRedis creates a new Redis-backed event bus.
// url: Redis connection URL (e.g., "redis://localhost:6379")
func NewWithRedis(
        url string,
        logger *slog.Logger,
) (*RedisEventBus, error) <span class="cov8" title="1">{
        if url == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("redis event bus: url is required")
        }</span>
        <span class="cov8" title="1">client, err := setupRedisClient(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">bus := createRedisEventBus(client, logger)
        bus.StartDLQRetryWorkersFromEventTypes(context.Background())
        return bus, nil</span>
}

// Emit publishes an event to the Redis stream.
func (b *RedisEventBus) Emit(
        ctx context.Context,
        event events.Event,
) error <span class="cov8" title="1">{
        if err := b.validateClient(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">envBytes, err := b.buildEnvelope(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Convert the event type string to EventType
        <span class="cov8" title="1">eventType := events.EventType(event.Type())
        if err := b.publishEnvelope(ctx, eventType, envBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">b.logger.Debug(
                "event emitted successfully",
                "type", eventType,
        )
        return nil</span>
}

// Register registers an event handler for a specific event type.
func (b *RedisEventBus) Register(
        eventType events.EventType,
        handler eventbus.HandlerFunc,
) <span class="cov8" title="1">{
        b.logger.Debug(
                "registering handler",
                "event_type", eventType,
        )
        b.registerHandler(eventType, handler)
        if err := b.startConsumerForEvent(eventType); err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                        b.logger.Error(
                                "error reading from stream",
                                "error", err,
                                "event_type", eventType,
                        )
                }</span>
        }
}

// createRedisEventBus initializes the RedisEventBus struct.
func createRedisEventBus(
        client *redis.Client,
        logger *slog.Logger,
) *RedisEventBus <span class="cov8" title="1">{
        return &amp;RedisEventBus{
                client:   client,
                handlers: make(map[events.EventType][]eventbus.HandlerFunc),
                logger:   logger.With("bus", "redis"),
        }
}</span>

// initializeConsumerGroup ensures group exists and cleans up idle consumers.
func (b *RedisEventBus) initializeConsumerGroup(
        eventType events.EventType,
) error <span class="cov8" title="1">{
        ctx := context.Background()
        group := groupNameFor(eventType)
        stream := streamNameFor(eventType)
        if err := b.ensureConsumerGroup(ctx, stream, group); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">b.cleanupIdleConsumers(ctx, stream, group)
        return nil</span>
}

// validateClient ensures the Redis client is initialized.
func (b *RedisEventBus) validateClient() error <span class="cov8" title="1">{
        if b.client == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redis event bus: client not initialized")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// startConsumerForEvent derives group/consumer names and starts consuming for
// eventType.
func (b *RedisEventBus) startConsumerForEvent(
        eventType events.EventType,
) error <span class="cov8" title="1">{
        if err := b.initializeConsumerGroup(eventType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">b.startConsuming(eventType)
        return nil</span>
}

// setupRedisClient parses URL, creates client, and pings redis.
func setupRedisClient(url string) (*redis.Client, error) <span class="cov8" title="1">{
        opt, err := redis.ParseURL(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("redis event bus: invalid URL: %w", err)
        }</span>

        <span class="cov8" title="1">client := redis.NewClient(opt)
        if err := client.Ping(context.Background()).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("redis event bus: connection failed: %w", err)
        }</span>
        <span class="cov8" title="1">return client, nil</span>
}

// ensureConsumerGroup creates the group if not exists.
func (b *RedisEventBus) ensureConsumerGroup(
        ctx context.Context,
        stream,
        group string,
) error <span class="cov8" title="1">{
        err := b.client.XGroupCreateMkStream(
                ctx,
                stream,
                group,
                "$",
        ).Err()
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "BUSYGROUP") </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create consumer group: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// cleanupIdleConsumers removes idle consumers with pending messages.
func (b *RedisEventBus) cleanupIdleConsumers(
        ctx context.Context,
        stream,
        group string,
) <span class="cov8" title="1">{
        if consumers, err := b.client.XInfoConsumers(
                ctx,
                stream,
                group,
        ).Result(); err == nil </span><span class="cov8" title="1">{
                for _, consumer := range consumers </span><span class="cov0" title="0">{
                        idleDuration := consumer.Idle * time.Millisecond
                        if consumer.Pending &gt; 0 &amp;&amp; idleDuration &gt; 5*time.Minute </span><span class="cov0" title="0">{
                                b.client.XGroupDelConsumer(ctx, stream, group, consumer.Name)
                        }</span>
                }
        }
}

// buildEnvelope marshals event and wraps in envelope.
func (b *RedisEventBus) buildEnvelope(event events.Event) ([]byte, error) <span class="cov8" title="1">{
        data, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                b.logger.Error(
                        "failed to marshal event",
                        "error", err,
                        "event_type", event.Type(),
                )
                return nil, fmt.Errorf("redis event bus: marshal failed: %w", err)
        }</span>

        <span class="cov8" title="1">env := envelope{Type: event.Type(), Payload: data}
        envBytes, err := json.Marshal(env)
        if err != nil </span><span class="cov0" title="0">{
                b.logger.Error(
                        "failed to marshal envelope",
                        "error", err,
                        "type", event.Type(),
                )
                return nil, fmt.Errorf("redis event bus: envelope marshal failed: %w", err)
        }</span>

        <span class="cov8" title="1">return envBytes, nil</span>
}

// publishEnvelope adds the envelope to the redis stream.
func (b *RedisEventBus) publishEnvelope(
        ctx context.Context,
        eventType events.EventType,
        envelopeData []byte,
) error <span class="cov8" title="1">{
        args := b.prepareAddArgs(eventType, envelopeData)
        _, err := b.client.XAdd(ctx, args).Result()
        if err != nil </span><span class="cov0" title="0">{
                b.logger.Error(
                        "failed to publish event",
                        "error", err,
                        "event_type", eventType,
                )
                return fmt.Errorf("failed to publish event: %w", err)
        }</span>
        <span class="cov8" title="1">b.logger.Debug(
                "event published to stream",
                "event_type", eventType,
                "stream", args.Stream,
        )
        return nil</span>
}

// prepareAddArgs prepares the XAddArgs for publishing an envelope.
func (b *RedisEventBus) prepareAddArgs(eventType events.EventType, data []byte) *redis.XAddArgs <span class="cov8" title="1">{
        stream := streamNameFor(eventType)
        return &amp;redis.XAddArgs{
                Stream: stream,
                Values: map[string]interface{}{"event": string(data)},
        }
}</span>

// registerHandler safely registers a handler for the given event type.
func (b *RedisEventBus) registerHandler(eventType events.EventType, handler eventbus.HandlerFunc) <span class="cov8" title="1">{
        b.handlersMtx.Lock()
        defer b.handlersMtx.Unlock()
        b.ensureHandlersMap()
        b.handlers[eventType] = append(b.handlers[eventType], handler)
        b.logger.Debug("registered handler", "event_type", eventType)
}</span>

// ensureHandlersMap initializes the handlers map if it is nil.
func (b *RedisEventBus) ensureHandlersMap() <span class="cov8" title="1">{
        if b.handlers == nil </span><span class="cov0" title="0">{
                b.handlers = make(map[events.EventType][]eventbus.HandlerFunc)
        }</span>
}

// startConsuming starts a goroutine to consume events for the given eventType.
func (b *RedisEventBus) startConsuming(eventType events.EventType) <span class="cov8" title="1">{
        go b.consume(eventType)
}</span>

// consume starts consuming messages from the
// Redis stream and routes them to the appropriate handlers.
func (b *RedisEventBus) consume(
        eventType events.EventType,
) <span class="cov8" title="1">{
        stream := streamNameFor(eventType)
        group := groupNameFor(eventType)
        consumer := consumerNameFor(eventType)
        b.logger.Debug(
                "starting consumer",
                "event_type", eventType,
                "stream", stream,
                "group", group,
                "consumer", consumer,
        )

        for </span><span class="cov8" title="1">{
                ctx := context.Background()

                // Read messages from the stream
                messages, err := b.readStream(ctx, stream, group, consumer)
                if err != nil </span><span class="cov8" title="1">{
                        if !errors.Is(err, redis.Nil) </span><span class="cov8" title="1">{
                                b.logger.Error(
                                        "error reading from stream",
                                        "error", err,
                                        "stream", stream,
                                        "group", group,
                                )
                        }</span>
                        <span class="cov8" title="1">time.Sleep(5 * time.Second) // Prevent tight loop on errors
                        continue</span>
                }

                // Process each message
                <span class="cov8" title="1">for _, msg := range messages </span><span class="cov8" title="1">{
                        b.processMessage(ctx, group, msg)
                }</span>
        }
}

// readStream reads messages from a redis stream group.
func (b *RedisEventBus) readStream(
        ctx context.Context,
        stream, group, consumer string,
) ([]redis.XMessage, error) <span class="cov8" title="1">{
        res, err := b.client.XReadGroup(ctx, &amp;redis.XReadGroupArgs{
                Group:    group,
                Consumer: consumer,
                Streams:  []string{stream, "&gt;"},
                Count:    10,
                Block:    5 * time.Second,
                NoAck:    false,
        }).Result()

        if err != nil </span><span class="cov8" title="1">{
                if !errors.Is(err, redis.Nil) </span><span class="cov8" title="1">{
                        b.logger.Error(
                                "error reading from stream",
                                "error", err,
                                "group", group,
                        )
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">var messages []redis.XMessage
        for _, stream := range res </span><span class="cov8" title="1">{
                messages = append(messages, stream.Messages...)
        }</span>
        <span class="cov8" title="1">return messages, nil</span>
}

// processMessage processes a single message from the Redis stream.
func (b *RedisEventBus) processMessage(ctx context.Context, group string, msg redis.XMessage) <span class="cov8" title="1">{
        raw, ok := msg.Values["event"].(string)
        if !ok </span><span class="cov0" title="0">{
                b.logger.Error(
                        "invalid message format, missing 'event' field",
                        "msg_id", msg.ID,
                )
                return
        }</span>

        <span class="cov8" title="1">var env envelope
        if err := json.Unmarshal([]byte(raw), &amp;env); err != nil </span><span class="cov0" title="0">{
                b.logger.Error(
                        "failed to unmarshal envelope",
                        "error", err,
                        "msg_id", msg.ID,
                )
                return
        }</span>

        // Convert the string event type to EventType
        <span class="cov8" title="1">evtType := events.EventType(env.Type)

        constructor, ok := events.EventTypes[evtType]
        if !ok </span><span class="cov0" title="0">{
                b.logger.Error(
                        "unknown event type",
                        "type", env.Type,
                        "msg_id", msg.ID,
                )
                _ = b.ackMessage(ctx, evtType, group, msg.ID)
                return
        }</span>

        <span class="cov8" title="1">evt := constructor()

        // Special handling for events with custom JSON unmarshaling
        err := json.Unmarshal(env.Payload, evt)

        if err != nil </span><span class="cov0" title="0">{
                b.logger.Error(
                        "failed to unmarshal event",
                        "error", err,
                        "event_type", env.Type,
                        "msg_id", msg.ID,
                )
                _ = b.ackMessage(ctx, evtType, group, msg.ID)
                return
        }</span>

        <span class="cov8" title="1">handlers := b.getHandlers(evtType)
        if len(handlers) == 0 </span><span class="cov0" title="0">{
                b.logger.Warn(
                        "no handlers registered for event type",
                        "event_type", env.Type,
                        "msg_id", msg.ID,
                )
                _ = b.ackMessage(ctx, evtType, group, msg.ID)
                return
        }</span>

        <span class="cov8" title="1">success := b.executeHandlers(
                ctx,
                evtType,
                evt,
                msg.ID,
                handlers,
        )

        if success </span><span class="cov8" title="1">{
                if err := b.ackMessage(ctx, evtType, group, msg.ID); err != nil </span><span class="cov0" title="0">{
                        b.logger.Error(
                                "failed to ack message",
                                "error", err,
                                "msg_id", msg.ID,
                        )
                }</span>
        } else<span class="cov8" title="1"> {
                b.logger.Warn(
                        "sending message to DLQ due to handler errors",
                        "event_type", env.Type,
                        "msg_id", msg.ID,
                )
                b.pushToDLQ(ctx, evtType, msg.Values)
        }</span>
}

// getHandlers retrieves a copy of the handlers for a given event type.
func (b *RedisEventBus) getHandlers(
        eventType events.EventType,
) []eventbus.HandlerFunc <span class="cov8" title="1">{
        b.handlersMtx.RLock()
        defer b.handlersMtx.RUnlock()

        handlers, exists := b.handlers[eventType]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Return a copy to avoid race conditions
        <span class="cov8" title="1">handlersCopy := make([]eventbus.HandlerFunc, len(handlers))
        copy(handlersCopy, handlers)
        return handlersCopy</span>
}

// executeHandlers runs all handlers for an event and returns true if all succeed.
func (b *RedisEventBus) executeHandlers(
        ctx context.Context,
        eventType events.EventType,
        evt events.Event,
        msgID string,
        handlers []eventbus.HandlerFunc,
) bool <span class="cov8" title="1">{
        var wg sync.WaitGroup
        var mu sync.Mutex
        success := true

        for _, handler := range handlers </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(h eventbus.HandlerFunc) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        if err := h(ctx, evt); err != nil </span><span class="cov8" title="1">{
                                mu.Lock()
                                success = false
                                mu.Unlock()
                                b.logger.Error(
                                        "handler error",
                                        "error", err,
                                        "event_type", eventType,
                                        "msg_id", msgID,
                                )
                        }</span>
                }(handler)
        }

        <span class="cov8" title="1">wg.Wait()
        return success</span>
}

// ackMessage acknowledges a message in the Redis stream.
func (b *RedisEventBus) ackMessage(
        ctx context.Context,
        eventType events.EventType,
        group, msgID string,
) error <span class="cov8" title="1">{
        stream := streamNameFor(eventType)
        _, err := b.client.XAck(ctx, stream, group, msgID).Result()
        return err
}</span>

// pushToDLQ pushes the raw event (msg.Values) to a DLQ Redis stream for inspection or reprocessing.
func (b *RedisEventBus) pushToDLQ(
        ctx context.Context,
        eventType events.EventType,
        values map[string]any,
) <span class="cov8" title="1">{
        dlqStream := dlqStreamName(eventType)
        if err := b.publishToStream(ctx, dlqStream, values); err != nil </span><span class="cov0" title="0">{
                b.logDLQResult(err, dlqStream, values)
        }</span>
}

// publishToStream adds a raw message to a given Redis stream.
func (b *RedisEventBus) publishToStream(
        ctx context.Context,
        stream string,
        values map[string]any,
) error <span class="cov8" title="1">{
        _, err := b.client.XAdd(ctx, &amp;redis.XAddArgs{
                Stream: stream,
                Values: values,
        }).Result()
        return err
}</span>

// logDLQResult logs the result of a DLQ operation.
func (b *RedisEventBus) logDLQResult(
        err error,
        stream string,
        values map[string]any,
) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                b.logger.Error(
                        "failed to push to DLQ",
                        "error", err,
                        "stream", stream,
                )
        }</span> else<span class="cov0" title="0"> {
                b.logger.Warn(
                        "event pushed to DLQ",
                        "stream", stream,
                        "values", values,
                )
        }</span>
}
func (b *RedisEventBus) StartDLQRetryWorkersFromEventTypes(ctx context.Context) <span class="cov8" title="1">{

        for eventType := range events.EventTypes </span><span class="cov8" title="1">{
                stream := streamNameFor(eventType)
                dlq := dlqStreamName(eventType)

                // Retry worker reads from DLQ and re-publishes to original stream
                if err := b.retryDLQ(ctx, dlq, stream, 10); err != nil </span><span class="cov0" title="0">{
                        b.logger.Error(
                                "failed to retry DLQ messages",
                                "error", err,
                                "dlq", dlq,
                                "stream", stream,
                        )
                }</span>
        }
}

func (b *RedisEventBus) retryDLQ(
        ctx context.Context,
        dlqStream,
        originalStream string,
        count int64,
) error <span class="cov8" title="1">{
        entries, err := b.client.XRangeN(
                ctx,
                dlqStream,
                "-",
                "+",
                count,
        ).Result()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed reading from DLQ: %w", err)
        }</span>

        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov0" title="0">{
                data := entry.Values["event"]
                if data == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if _, err := b.client.XAdd(ctx, &amp;redis.XAddArgs{
                        Stream: originalStream,
                        Values: map[string]any{"event": data},
                }).Result(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed retrying DLQ event: %w", err)
                }</span>

                // Delete the message from the DLQ after retry
                <span class="cov0" title="0">if _, err := b.client.XDel(ctx, dlqStream, entry.ID).Result(); err != nil </span><span class="cov0" title="0">{
                        b.logger.Error(
                                "failed to delete retried message from DLQ",
                                "error", err,
                                "msg_id", entry.ID,
                        )
                }</span>
        }
        <span class="cov8" title="1">b.logger.Debug(
                "✅ Successfully retried DLQ messages",
                "count", count,
                "dlq_stream", dlqStream,
                "original_stream", originalStream,
        )
        return nil</span>
}
</pre>

		<pre class="file" id="file4" style="display: none">package eventbus

import (
        "fmt"
        "github.com/amirasaad/fintech/pkg/domain/events"
        "strings"
)

func streamNameFor(eventType events.EventType) string <span class="cov8" title="1">{
        return nameFor("events", eventType)
}</span>

// dlqStreamName returns the DLQ stream name for the given event type.
func dlqStreamName(eventType events.EventType) string <span class="cov8" title="1">{
        return nameFor("dlq", eventType)
}</span>

// groupNameFor returns the Redis consumer group name for the event type.
func groupNameFor(eventType events.EventType) string <span class="cov8" title="1">{
        return nameFor("group", eventType)
}</span>

// consumerNameFor returns the Redis consumer name for the event type.
func consumerNameFor(eventType events.EventType) string <span class="cov8" title="1">{
        return nameFor("consumer", eventType)
}</span>

func nameFor(prefix string, eventType events.EventType) string <span class="cov8" title="1">{
        parts := strings.Split(eventType.String(), ".")
        if len(parts) == 2 </span><span class="cov8" title="1">{
                return fmt.Sprintf(
                        "%s:%s:%s",
                        prefix,
                        strings.ToLower(parts[0]),
                        strings.ToLower(parts[1]))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s:%s", prefix, strings.ToLower(eventType.String()))</span>
}
</pre>

		<pre class="file" id="file5" style="display: none">package initializer

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/amirasaad/fintech/infra/caching"
        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/amirasaad/fintech/pkg/registry"

        "github.com/amirasaad/fintech/infra"
        infra_eventbus "github.com/amirasaad/fintech/infra/eventbus"
        infra_provider "github.com/amirasaad/fintech/infra/provider"
        infra_repository "github.com/amirasaad/fintech/infra/repository"
        currencyfixtures "github.com/amirasaad/fintech/internal/fixtures/currency"
        "github.com/amirasaad/fintech/pkg/app"
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/eventbus"
)

// InitializeDependencies initializes all the application dependencies
func InitializeDependencies(cfg *config.App) (
        deps *app.Deps,
        err error,
) <span class="cov0" title="0">{
        // Load configuration
        deps = &amp;app.Deps{}
        logger := setupLogger(cfg.Log)
        deps.Logger = logger

        // Initialize registry providers for each service
        deps.RegistryProvider, err = GetDefaultRegistry(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize main registry provider: %w", err)
        }</span>

        // Initialize currency registry
        <span class="cov0" title="0">deps.CurrencyRegistry, err = GetDefaultRegistry(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize currency registry provider: %w", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        // Only load currency fixtures if the registry is empty
        count, err := deps.CurrencyRegistry.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to check currency registry count", "error", err)
        }</span>

        // Load currency metadata from CSV
        <span class="cov0" title="0">entities, err := currencyfixtures.LoadCurrencyMetaCSV(
                "../../internal/fixtures/currency/meta.csv")
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to load currency meta from CSV", "error", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Loading currency meta from fixture", "count", count)
        for _, entity := range entities </span><span class="cov0" title="0">{
                if err := deps.CurrencyRegistry.Register(ctx, entity); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to register currency", "code", entity.ID(), "error", err)
                        // Continue with other currencies even if one fails
                }</span>
        }
        <span class="cov0" title="0">logger.Info("Successfully loaded currency fixtures", "count", len(entities))

        // Initialize checkout registry
        deps.CheckoutRegistry, err = GetCheckoutRegistry(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize checkout registry provider: %w", err)
        }</span>

        // Initialize exchange rate registry
        <span class="cov0" title="0">deps.ExchangeRateRegistry, err = GetExchangeRateRegistry(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize exchange rate registry provider: %w", err)
        }</span>

        // Create the exchange rate provider
        <span class="cov0" title="0">exchangeProvider := infra_provider.NewExchangeRateAPIProvider(
                cfg.ExchangeRateAPIProviders.ExchangeRateApi,
                logger,
        )
        if err := initializeExchangeRates(
                exchangeProvider,
                deps.ExchangeRateRegistry,
                cfg.ExchangeRateCache,
                logger,
        ); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to initialize exchange rates", "error", err)
                // Don't fail the entire startup for exchange rate initialization
        }</span>
        <span class="cov0" title="0">deps.ExchangeRateProvider = exchangeProvider

        // Initialize database
        db, err := infra.NewDBConnection(cfg.DB, cfg.Env)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to initialize database", "error", err)
                return nil, err
        }</span>

        // Initialize unit of work
        <span class="cov0" title="0">deps.Uow = infra_repository.NewUoW(db)

        // Initialize event bus
        var bus eventbus.Bus
        if cfg.Redis.URL != "" </span><span class="cov0" title="0">{
                bus, err = infra_eventbus.NewWithRedis(cfg.Redis.URL, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create Redis event bus: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                bus = infra_eventbus.NewWithMemory(logger)
        }</span>
        <span class="cov0" title="0">deps.EventBus = bus

        // Initialize payment provider with the checkout registry
        deps.PaymentProvider = infra_provider.NewStripePaymentProvider(
                bus,
                deps.CheckoutRegistry, // Use the checkout-specific registry
                cfg.PaymentProviders.Stripe,
                logger,
        )

        return</span>
}

// initializeExchangeRates fetches and caches exchange rates during application startup
func initializeExchangeRates(
        exchangeRateProvider provider.ExchangeRate,
        registryProvider registry.Provider,
        cfg *config.ExchangeRateCache,
        logger *slog.Logger,
) error <span class="cov0" title="0">{
        // Create a context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Initialize the exchange cache with the provided registry provider
        exchangeCache := caching.NewExchangeCache(
                registryProvider,
                logger,
                cfg.TTL,
        )

        // Fetch rates from the provider
        rates, err := exchangeRateProvider.GetRates(ctx, "USD")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to fetch exchange rates: %w", err)
        }</span>

        // Cache the rates using ExchangeCache
        <span class="cov0" title="0">if err := exchangeCache.CacheRates(
                ctx,
                rates,
                exchangeRateProvider.Name(),
        ); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cache exchange rates: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Successfully fetched and cached exchange rates",
                "provider", exchangeRateProvider.Name(),
                "rates_count", len(rates),
        )

        return nil</span>
}
</pre>

		<pre class="file" id="file6" style="display: none">package initializer

import (
        "log/slog"
        "time"

        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/registry"
)

// RegistryConfig holds configuration for creating a registry provider
type RegistryConfig struct {
        Name      string
        RedisURL  string
        KeyPrefix string
        CacheSize int
        CacheTTL  time.Duration
}

// GetRegistryProvider returns a configured registry provider based on the provided config
func GetRegistryProvider(
        cfg *RegistryConfig,
        logger *slog.Logger,
) (registry.Provider, error) <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                cfg = &amp;RegistryConfig{
                        Name:      "default",
                        CacheSize: 1000,
                        CacheTTL:  -1, // No expiration
                }
        }</span>

        // Ensure cache size is at least 1 if caching is enabled
        <span class="cov0" title="0">if cfg.CacheTTL != 0 &amp;&amp; cfg.CacheSize &lt;= 0 </span><span class="cov0" title="0">{
                cfg.CacheSize = 1000
        }</span>

        <span class="cov0" title="0">builder := registry.NewBuilder().
                WithName(cfg.Name).
                WithRedis(cfg.RedisURL).
                WithKeyPrefix(cfg.KeyPrefix).
                WithCache(cfg.CacheSize, cfg.CacheTTL)

        logger.Info("Creating registry provider",
                "name", cfg.Name,
                "redis_configured", cfg.RedisURL != "",
                "key_prefix", cfg.KeyPrefix,
                "cache_size", cfg.CacheSize,
                "cache_ttl", cfg.CacheTTL,
        )

        return builder.BuildRegistry()</span>
}

// GetCheckoutRegistry creates a registry provider for the checkout service
func GetCheckoutRegistry(cfg *config.App, logger *slog.Logger) (registry.Provider, error) <span class="cov0" title="0">{
        keyPrefix := ""
        if cfg.Redis != nil </span><span class="cov0" title="0">{
                keyPrefix = cfg.Redis.KeyPrefix
        }</span>

        <span class="cov0" title="0">registryCfg := &amp;RegistryConfig{
                Name:      "checkout",
                RedisURL:  cfg.Redis.URL,
                KeyPrefix: keyPrefix + "checkout:",
                CacheSize: 1000,
                CacheTTL:  -1, // No expiration for checkout sessions
        }

        return GetRegistryProvider(registryCfg, logger)</span>
}

// GetExchangeRateRegistry creates a registry provider for the exchange rate service
func GetExchangeRateRegistry(cfg *config.App, logger *slog.Logger) (registry.Provider, error) <span class="cov0" title="0">{
        if cfg.ExchangeRateCache == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">keyPrefix := cfg.ExchangeRateCache.Prefix
        if keyPrefix == "" </span><span class="cov0" title="0">{
                keyPrefix = "exr:rate:"
        }</span>

        <span class="cov0" title="0">registryCfg := &amp;RegistryConfig{
                Name:      "exchange_rate",
                RedisURL:  cfg.ExchangeRateCache.Url,
                KeyPrefix: keyPrefix,
                CacheSize: 1000,
                CacheTTL:  cfg.ExchangeRateCache.TTL,
        }

        return GetRegistryProvider(registryCfg, logger)</span>
}

// GetDefaultRegistry creates a default registry provider
func GetDefaultRegistry(cfg *config.App, logger *slog.Logger) (registry.Provider, error) <span class="cov0" title="0">{
        keyPrefix := ""
        if cfg.Redis != nil </span><span class="cov0" title="0">{
                keyPrefix = cfg.Redis.KeyPrefix
        }</span>

        <span class="cov0" title="0">registryCfg := &amp;RegistryConfig{
                Name:      "default",
                RedisURL:  cfg.Redis.URL,
                KeyPrefix: keyPrefix,
                CacheSize: 1000,
                CacheTTL:  -1, // No expiration
        }

        return GetRegistryProvider(registryCfg, logger)</span>
}
</pre>

		<pre class="file" id="file7" style="display: none">package initializer

import (
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/charmbracelet/lipgloss"
        "github.com/charmbracelet/log"
        "log/slog"
        "os"
)

func setupLogger(cfg *config.Log) *slog.Logger <span class="cov0" title="0">{
        // Create a new logger with a custom style
        // Define color styles for different log levels
        styles := log.DefaultStyles()
        infoTxtColor := lipgloss.AdaptiveColor{Light: "#04B575", Dark: "#04B575"}
        warnTxtColor := lipgloss.AdaptiveColor{Light: "#EE6FF8", Dark: "#EE6FF8"}
        errorTxtColor := lipgloss.AdaptiveColor{Light: "#FF6B6B", Dark: "#FF6B6B"}
        debugTxtColor := lipgloss.AdaptiveColor{Light: "#7E57C2", Dark: "#7E57C2"}

        // Customize the style for each log level
        // Error level styling
        styles.Levels[log.ErrorLevel] = lipgloss.NewStyle().
                SetString("❌").
                Bold(true).
                Padding(0, 1).
                Foreground(errorTxtColor)

        // Info level styling
        styles.Levels[log.InfoLevel] = lipgloss.NewStyle().
                SetString("ℹ️").
                Bold(true).
                Padding(0, 1).
                Foreground(infoTxtColor)

        // Warn level styling
        styles.Levels[log.WarnLevel] = lipgloss.NewStyle().
                SetString("⚠️").
                Bold(true).
                Padding(0, 1).
                Foreground(warnTxtColor)

        // Debug level styling
        styles.Levels[log.DebugLevel] = lipgloss.NewStyle().
                SetString("🐛").
                Bold(true).
                Padding(0, 1).
                Foreground(debugTxtColor)

        styles.Keys["error"] = lipgloss.NewStyle().Foreground(errorTxtColor)
        styles.Values["error"] = lipgloss.NewStyle().Bold(true)
        styles.Keys["info"] = lipgloss.NewStyle().Foreground(infoTxtColor)
        styles.Values["info"] = lipgloss.NewStyle().Bold(true)
        styles.Keys["warn"] = lipgloss.NewStyle().Foreground(warnTxtColor)
        styles.Values["warn"] = lipgloss.NewStyle().Bold(true)
        styles.Keys["debug"] = lipgloss.NewStyle().Foreground(debugTxtColor)
        styles.Values["debug"] = lipgloss.NewStyle().Bold(true)
        styles.Keys["prefix"] = lipgloss.NewStyle().Foreground(debugTxtColor)
        styles.Values["prefix"] = lipgloss.NewStyle().Bold(true)
        styles.Keys["caller"] = lipgloss.NewStyle().Foreground(debugTxtColor)
        styles.Values["caller"] = lipgloss.NewStyle().Bold(true)
        styles.Keys["time"] = lipgloss.NewStyle().Foreground(debugTxtColor)
        styles.Values["time"] = lipgloss.NewStyle().Bold(true)

        formattersMap := map[string]log.Formatter{
                "json": log.JSONFormatter,
                "text": log.TextFormatter,
        }
        formatter := log.TextFormatter
        if f, ok := formattersMap[cfg.Format]; ok </span><span class="cov0" title="0">{
                formatter = f
        }</span>

        // Create a new logger with the custom styles
        <span class="cov0" title="0">logger := log.NewWithOptions(os.Stdout, log.Options{
                ReportCaller:    true,
                ReportTimestamp: true,
                TimeFormat:      cfg.TimeFormat,
                Level:           log.Level(cfg.Level),
                Prefix:          cfg.Prefix,
                Formatter:       formatter,
        })

        logger.SetStyles(styles) // Convert to slog.Logger

        slogger := slog.New(logger)
        slog.SetDefault(slogger)

        return slogger</span>
}
</pre>

		<pre class="file" id="file8" style="display: none">package provider

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "time"

        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/provider"
)

// exchangeRateAPI implements the ExchangeRate interface for exchangerate-api.com v6 API
type exchangeRateAPI struct {
        apiKey     string
        baseURL    string
        httpClient *http.Client
        logger     *slog.Logger
        timeout    time.Duration
}

// API error types
const (
        errorTypeUnsupportedCode  = "unsupported-code"
        errorTypeMalformedRequest = "malformed-request"
        errorTypeInvalidKey       = "invalid-key"
        errorTypeInactiveAccount  = "inactive-account"
        errorTypeQuotaReached     = "quota-reached"
        errorTypeUnknown          = "unknown-code"
)

// ExchangeRateAPIResponseV6 represents the v6 response from the ExchangeRate API
// See: https://www.exchangerate-api.com/docs/standard-requests
// Example:
// { "result": "success", "documentation": "...", "terms_of_use": "...",
// "time_last_update_unix": 1585267200, ... }
type ExchangeRateAPIResponseV6 struct {
        Result             string             `json:"result"`
        Documentation      string             `json:"documentation"`
        TermsOfUse         string             `json:"terms_of_use"`
        TimeLastUpdateUnix int64              `json:"time_last_update_unix"`
        TimeLastUpdateUTC  string             `json:"time_last_update_utc"`
        TimeNextUpdateUnix int64              `json:"time_next_update_unix"`
        TimeNextUpdateUTC  string             `json:"time_next_update_utc"`
        BaseCode           string             `json:"base_code"`
        ConversionRates    map[string]float64 `json:"conversion_rates"`
        // Error fields (if any)
        ErrorType string `json:"error-type,omitempty"`
}

// NewExchangeRateAPIProvider creates a new ExchangeRate API provider using config
func NewExchangeRateAPIProvider(
        cfg *config.ExchangeRateApi,
        logger *slog.Logger,
) *exchangeRateAPI <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = slog.Default()
        }</span>

        <span class="cov0" title="0">return &amp;exchangeRateAPI{
                apiKey:  cfg.ApiKey,
                baseURL: fmt.Sprintf("%s/%s", cfg.ApiUrl, cfg.ApiKey),
                httpClient: &amp;http.Client{
                        Timeout: cfg.HTTPTimeout,
                },
                logger:  logger,
                timeout: cfg.HTTPTimeout,
        }</span>
}

// GetRate fetches the current exchange rate for a currency pair
func (p *exchangeRateAPI) GetRate(
        ctx context.Context,
        from, to string,
) (*provider.ExchangeInfo, error) <span class="cov0" title="0">{
        // Update GetRate to use the v6 endpoint and response if needed, or rely on cache for POC
        // For now, we'll assume a simple call to the base URL with the API key
        url := fmt.Sprintf("%s/%s/%s", p.baseURL, "latest", from)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">if p.apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+p.apiKey)
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := resp.Body.Close(); cerr != nil </span><span class="cov0" title="0">{
                        p.logger.Warn(
                                "Failed to close response body",
                                "error", cerr,
                        )
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("API returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResp ExchangeRateAPIResponseV6
        if err = json.NewDecoder(resp.Body).Decode(&amp;apiResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if apiResp.Result != "success" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned result=%s", apiResp.Result)
        }</span>

        <span class="cov0" title="0">rate, exists := apiResp.ConversionRates[to]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rate for %s not found in response", to)
        }</span>

        <span class="cov0" title="0">return &amp;provider.ExchangeInfo{
                OriginalCurrency:  from,
                ConvertedCurrency: to,
                ConversionRate:    rate,
                Timestamp:         time.Now(),
                Source:            p.Name(),
        }, nil</span>
}

// GetRates fetches multiple exchange rates in a single request
func (p *exchangeRateAPI) GetRates(
        ctx context.Context,
        from string,
) (map[string]*provider.ExchangeInfo, error) <span class="cov0" title="0">{

        // Build the URL for the latest rates endpoint
        url := fmt.Sprintf("%s/latest/%s", p.baseURL, from)

        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set content type header
        <span class="cov0" title="0">req.Header.Set("Accept", "application/json")

        // Execute the request
        resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := resp.Body.Close(); cerr != nil </span><span class="cov0" title="0">{
                        p.logger.Warn("failed to close response body", "error", cerr)
                }</span>
        }()

        // Read the response body
        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Parse the response
        <span class="cov0" title="0">var apiResp ExchangeRateAPIResponseV6
        if err := json.Unmarshal(body, &amp;apiResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        // Check for API errors
        <span class="cov0" title="0">if apiResp.Result != "success" </span><span class="cov0" title="0">{
                switch apiResp.ErrorType </span>{
                case errorTypeUnsupportedCode:<span class="cov0" title="0">
                        return nil, fmt.Errorf("unsupported currency code")</span>
                case errorTypeMalformedRequest:<span class="cov0" title="0">
                        return nil, fmt.Errorf("malformed request")</span>
                case errorTypeInvalidKey:<span class="cov0" title="0">
                        return nil, fmt.Errorf("invalid API key")</span>
                case errorTypeInactiveAccount:<span class="cov0" title="0">
                        return nil, fmt.Errorf("inactive account")</span>
                case errorTypeQuotaReached:<span class="cov0" title="0">
                        return nil, fmt.Errorf("API quota reached")</span>
                case errorTypeUnknown, "":<span class="cov0" title="0">
                        fallthrough</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("API error: %s", apiResp.ErrorType)</span>
                }
        }

        // Process the requested rates
        <span class="cov0" title="0">results := make(map[string]*provider.ExchangeInfo)
        now := time.Now()

        for currency := range apiResp.ConversionRates </span><span class="cov0" title="0">{
                rate, exists := apiResp.ConversionRates[currency]
                if !exists </span><span class="cov0" title="0">{
                        p.logger.Warn("currency not found in response", "currency", currency)
                        continue</span>
                }

                <span class="cov0" title="0">results[currency] = &amp;provider.ExchangeInfo{
                        OriginalCurrency:  from,
                        ConvertedCurrency: currency,
                        ConversionRate:    rate,
                        Timestamp:         now,
                        Source:            p.Name(),
                }</span>
        }

        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("none of the requested currencies were found in the response")
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// IsSupported checks if the provider supports the given currency pair
func (p *exchangeRateAPI) IsSupported(from string, to string) bool <span class="cov0" title="0">{
        // TODO: implement me
        panic("unimplemented")</span>
}

// Name returns the provider's name
func (p *exchangeRateAPI) Name() string <span class="cov0" title="0">{
        return "exchangerate-api"
}</span>

// IsHealthy checks if the provider is currently available
func (p *exchangeRateAPI) IsHealthy() bool <span class="cov0" title="0">{
        // Make a simple health check request
        return true
}</span>

// Ensure ExchangeRateAPIProvider implements provider.ExchangeRate
var _ provider.ExchangeRate = (*exchangeRateAPI)(nil)
</pre>

		<pre class="file" id="file9" style="display: none">package provider

import (
        "context"
        "time"

        "github.com/amirasaad/fintech/pkg/provider"
)

// mockExchangeRate is a mock implementation of the ExchangeRate interface for testing.
type mockExchangeRate struct {
        GetRateFunc  func(ctx context.Context, from, to string) (*provider.ExchangeInfo, error)
        GetRatesFunc func(
                ctx context.Context,
                from string,
        ) (map[string]*provider.ExchangeInfo, error)
        IsSupportedFunc func(from, to string) bool
        NameFunc        func() string
        IsHealthyFunc   func() bool
}

func NewMockExchangeRate() *mockExchangeRate <span class="cov0" title="0">{
        return &amp;mockExchangeRate{
                GetRateFunc: func(ctx context.Context, from, to string) (*provider.ExchangeInfo, error) </span><span class="cov0" title="0">{
                        return &amp;provider.ExchangeInfo{
                                OriginalCurrency:  from,
                                ConvertedCurrency: to,
                                ConversionRate:    1.0,
                                Timestamp:         time.Now(),
                        }, nil
                }</span>,
                GetRatesFunc: func(
                        ctx context.Context,
                        from string,
                ) (map[string]*provider.ExchangeInfo, error) <span class="cov0" title="0">{
                        result := make(map[string]*provider.ExchangeInfo)
                        supportedCurrencies := []string{
                                "EUR", "GBP", "JPY", "USD", "AUD",
                                "CAD", "CHF", "CNY", "HKD", "NZD",
                                "SGD", "ZAR",
                        }
                        for _, currency := range supportedCurrencies </span><span class="cov0" title="0">{
                                result[currency] = &amp;provider.ExchangeInfo{
                                        OriginalCurrency:  from,
                                        ConvertedCurrency: currency,
                                        ConversionRate:    1.0,
                                        Timestamp:         time.Now(),
                                }
                        }</span>
                        <span class="cov0" title="0">return result, nil</span>
                },
                IsSupportedFunc: func(from, to string) bool <span class="cov0" title="0">{
                        return true
                }</span>,
                NameFunc: func() string <span class="cov0" title="0">{
                        return "mock"
                }</span>,
                IsHealthyFunc: func() bool <span class="cov0" title="0">{
                        return true
                }</span>,
        }
}

// GetRate calls the mock implementation of GetRate.
func (m *mockExchangeRate) GetRate(
        ctx context.Context,
        from, to string,
) (*provider.ExchangeInfo, error) <span class="cov0" title="0">{
        if m.GetRateFunc != nil </span><span class="cov0" title="0">{
                return m.GetRateFunc(ctx, from, to)
        }</span>
        <span class="cov0" title="0">return &amp;provider.ExchangeInfo{
                OriginalCurrency:  from,
                ConvertedCurrency: to,
                ConversionRate:    1.0,
                Timestamp:         time.Now(),
        }, nil</span>
}

// GetRates calls the mock implementation of GetRates.
func (m *mockExchangeRate) GetRates(
        ctx context.Context,
        from string,
) (map[string]*provider.ExchangeInfo, error) <span class="cov0" title="0">{
        if m.GetRatesFunc != nil </span><span class="cov0" title="0">{
                return m.GetRatesFunc(ctx, from)
        }</span>
        <span class="cov0" title="0">result := make(map[string]*provider.ExchangeInfo)
        supportedCurrencies := []string{
                "EUR", "GBP", "JPY", "USD", "AUD",
                "CAD", "CHF", "CNY", "HKD", "NZD",
                "SGD", "ZAR",
        }
        for _, currency := range supportedCurrencies </span><span class="cov0" title="0">{
                result[currency] = &amp;provider.ExchangeInfo{
                        OriginalCurrency:  from,
                        ConvertedCurrency: currency,
                        ConversionRate:    1.0,
                        Timestamp:         time.Now(),
                }
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// IsSupported calls the mock implementation of IsSupported.
func (m *mockExchangeRate) IsSupported(from, to string) bool <span class="cov0" title="0">{
        if m.IsSupportedFunc != nil </span><span class="cov0" title="0">{
                return m.IsSupportedFunc(from, to)
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Name calls the mock implementation of Name.
func (m *mockExchangeRate) Name() string <span class="cov0" title="0">{
        if m.NameFunc != nil </span><span class="cov0" title="0">{
                return m.NameFunc()
        }</span>
        <span class="cov0" title="0">return "mock"</span>
}

// IsHealthy calls the mock implementation of IsHealthy.
func (m *mockExchangeRate) IsHealthy() bool <span class="cov0" title="0">{
        if m.IsHealthyFunc != nil </span><span class="cov0" title="0">{
                return m.IsHealthyFunc()
        }</span>
        <span class="cov0" title="0">return true</span>
}
</pre>

		<pre class="file" id="file10" style="display: none">package provider

import (
        "context"
        "sync"
        "time"

        "github.com/amirasaad/fintech/pkg/provider"
)

type mockPayment struct {
        status provider.PaymentStatus
}

// MockPaymentProvider simulates a payment provider for tests and local development.
//
// Usage:
// - InitiateDeposit/InitiateWithdraw simulate async payment completion after a short delay.
// - GetPaymentStatus can be polled until PaymentCompleted is returned.
// - This is NOT for production use. Real payment providers use webhooks or callbacks.
//
// In tests, the service will poll GetPaymentStatus until completion,
// simulating a real-world async flow.
//
// See pkg/service/account/account.go for example usage.
// For production, use a real provider and event-driven confirmation.
type MockPaymentProvider struct {
        mu       sync.Mutex
        payments map[string]*mockPayment
}

// NewMockPaymentProvider creates a new instance of MockPaymentProvider.
func NewMockPaymentProvider() *MockPaymentProvider <span class="cov0" title="0">{
        return &amp;MockPaymentProvider{
                payments: make(map[string]*mockPayment),
        }
}</span>

// InitiatePayment simulates initiating a deposit payment.
func (m *MockPaymentProvider) InitiatePayment(
        ctx context.Context,
        params *provider.InitiatePaymentParams,
) (*provider.InitiatePaymentResponse, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.payments[params.TransactionID.String()] = &amp;mockPayment{
                status: provider.PaymentPending,
        }
        m.mu.Unlock()
        // Simulate async completion
        go func() </span><span class="cov0" title="0">{
                time.Sleep(2 * time.Second)
                m.mu.Lock()
                m.payments[params.TransactionID.String()].status = provider.PaymentCompleted
                m.mu.Unlock()
        }</span>()
        <span class="cov0" title="0">return &amp;provider.InitiatePaymentResponse{
                Status: provider.PaymentPending,
        }, nil</span>
}

// HandleWebhook handles payment webhook events
func (m *MockPaymentProvider) HandleWebhook(
        ctx context.Context,
        payload []byte,
        signature string,
) (*provider.PaymentEvent, error) <span class="cov0" title="0">{
        // TODO: implement me
        panic("implement me")</span>
}
</pre>

		<pre class="file" id="file11" style="display: none">package provider

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "maps"
        "net/url"
        "strings"
        "time"

        "github.com/amirasaad/fintech/pkg/service/checkout"

        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/registry"

        "github.com/stripe/stripe-go/v82/webhook"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/google/uuid"
        "github.com/stripe/stripe-go/v82"
)

// CheckoutSession represents a Stripe Checkout session.
type CheckoutSession struct {
        ID          string
        PaymentID   string
        URL         string
        AmountTotal int64
        Currency    string
}

// StripePaymentProvider implements Payment using Stripe API.
type StripePaymentProvider struct {
        bus             eventbus.Bus
        client          *stripe.Client
        checkoutService *checkout.Service
        cfg             *config.Stripe
        logger          *slog.Logger
}

// NewStripePaymentProvider creates a new StripePaymentProvider with the given
// API key, registry, and logger. The registry parameter is used for storing
// checkout session data.
func NewStripePaymentProvider(
        bus eventbus.Bus,
        checkoutProvider registry.Provider,
        cfg *config.Stripe,
        logger *slog.Logger,
) *StripePaymentProvider <span class="cov0" title="0">{
        client := stripe.NewClient(cfg.ApiKey)

        return &amp;StripePaymentProvider{
                bus:             bus,
                client:          client,
                cfg:             cfg,
                checkoutService: checkout.New(checkoutProvider),
                logger:          logger,
        }
}</span>

// InitiatePayment creates a PaymentIntent in Stripe and returns its ID.
func (s *StripePaymentProvider) InitiatePayment(
        ctx context.Context,
        params *provider.InitiatePaymentParams,
) (*provider.InitiatePaymentResponse, error) <span class="cov0" title="0">{
        log := s.logger.With(
                "handler", "stripe.InitiatePayment",
                "user_id", params.UserID,
                "account_id", params.AccountID,
                "amount", params.Amount,
                "currency", params.Currency,
        )

        // Create checkout session
        co, err := s.createCheckoutSession(
                ctx,
                params.UserID,
                params.AccountID,
                params.TransactionID,
                params.Amount,
                params.Currency,
                "Payment for deposit",
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "failed to create checkout session",
                        "error", err,
                )
                return nil, fmt.Errorf(
                        "failed to create checkout session: %w", err)
        }</span>

        // Create internal checkout session record
        <span class="cov0" title="0">_, err = s.checkoutService.CreateSession(
                ctx,
                co.ID,
                co.PaymentID,
                params.TransactionID,
                params.UserID,
                params.AccountID,
                params.Amount,
                params.Currency,
                co.URL,
                time.Hour*24,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "failed to create checkout session record",
                        "error", err,
                )
                return nil, fmt.Errorf(
                        "failed to create checkout session record: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info(
                "🛒 Creating checkout session",
                "user_id", params.UserID,
                "account_id", params.AccountID,
                "transaction_id", params.TransactionID,
                "amount", params.Amount,
                "currency", params.Currency,
        )

        // Note: We're using the transaction ID as the payment ID to maintain consistency
        // with our internal transaction tracking. The checkout session ID is stored in the
        // checkout service for reference.
        return &amp;provider.InitiatePaymentResponse{
                Status:    provider.PaymentPending,
                PaymentID: co.PaymentID, // Use transaction ID as payment ID
        }, nil</span>
}

// HandleWebhook handles Stripe webhook events using a handler map.
func (s *StripePaymentProvider) HandleWebhook(
        ctx context.Context,
        payload []byte,
        signature string,
) (*provider.PaymentEvent, error) <span class="cov0" title="0">{
        log := s.logger.With("handler", "stripe.HandleWebhook")
        event, err := webhook.ConstructEvent(payload, signature, s.cfg.SigningSecret)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("invalid webhook signature", "error", err)
                return nil, fmt.Errorf("error verifying webhook signature: %w", err)
        }</span>
        <span class="cov0" title="0">log = log.With("event_type", event.Type, "event_id", event.ID)
        log.Info("📥 Handling webhook event", "type", event.Type)

        handlers := map[string]func(
                context.Context,
                stripe.Event,
                *slog.Logger,
        ) (*provider.PaymentEvent, error){
                "checkout.session.completed":    s.handleCheckoutSessionCompleted,
                "checkout.session.expired":      s.handleCheckoutSessionExpired,
                "payment_intent.succeeded":      s.handlePaymentIntentSucceeded,
                "payment_intent.payment_failed": s.handlePaymentIntentFailed,
                "charge.succeeded":              s.handleChargeSucceeded,
                "charge.updated":                s.handleChargeSucceeded,
        }
        if handler, ok := handlers[string(event.Type)]; ok </span><span class="cov0" title="0">{
                return handler(ctx, event, log)
        }</span>
        <span class="cov0" title="0">log.Info("Unhandled event type")
        return nil, nil</span>
}

// createCheckoutSession creates a new Stripe Checkout Session
func (s *StripePaymentProvider) createCheckoutSession(
        ctx context.Context,
        userID, accountID, transactionID uuid.UUID,
        amount int64,
        currency string,
        description string,
) (*CheckoutSession, error) <span class="cov0" title="0">{
        successURL := s.ensureAbsoluteURL(s.cfg.SuccessPath)
        cancelURL := s.ensureAbsoluteURL(s.cfg.CancelPath)

        // Create metadata for the checkout session and payment intent
        metadata := map[string]string{
                "user_id":        userID.String(),
                "account_id":     accountID.String(),
                "transaction_id": transactionID.String(),
                "amount":         fmt.Sprintf("%d", amount),
                "currency":       currency,
        }

        params := &amp;stripe.CheckoutSessionCreateParams{
                PaymentMethodTypes: stripe.StringSlice([]string{"card"}),
                Mode:               stripe.String(string(stripe.CheckoutSessionModePayment)),
                SuccessURL:         stripe.String(successURL),
                CancelURL:          stripe.String(cancelURL),
                Metadata:           metadata,
                PaymentIntentData: &amp;stripe.CheckoutSessionCreatePaymentIntentDataParams{
                        Metadata: metadata,
                },
                LineItems: []*stripe.CheckoutSessionCreateLineItemParams{{
                        PriceData: &amp;stripe.CheckoutSessionCreateLineItemPriceDataParams{
                                Currency: stripe.String(currency),
                                ProductData: &amp;stripe.CheckoutSessionCreateLineItemPriceDataProductDataParams{
                                        Name: stripe.String(description)},
                                UnitAmount: stripe.Int64(amount),
                        },
                        Quantity: stripe.Int64(1),
                }},
        }
        // Create the checkout session parameters

        // Add customer email if available
        if userEmail, ok := ctx.Value("user_email").(string); ok &amp;&amp; userEmail != "" </span><span class="cov0" title="0">{
                params.CustomerEmail = stripe.String(userEmail)
        }</span>

        // Create the checkout session using the session package
        <span class="cov0" title="0">session, err := s.client.V1CheckoutSessions.Create(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(
                        "failed to create checkout session",
                        "error", err,
                )
                return nil, fmt.Errorf("failed to create checkout session: %w", err)
        }</span>

        // Log successful session creation
        <span class="cov0" title="0">s.logger.Info(
                "✅ Created checkout session",
                "session_id", session.ID,
                "url", session.URL,
        )

        // Create the checkout session response
        checkoutSession := &amp;CheckoutSession{
                ID:          session.ID,
                URL:         session.URL,
                AmountTotal: session.AmountTotal,
                Currency:    string(session.Currency),
        }

        // Only set PaymentID if PaymentIntent is not nil
        if session.PaymentIntent != nil </span><span class="cov0" title="0">{
                checkoutSession.PaymentID = session.PaymentIntent.ID
        }</span>

        <span class="cov0" title="0">return checkoutSession, nil</span>
}

// handleCheckoutSessionCompleted handles the checkout.session.completed event
func (s *StripePaymentProvider) handleCheckoutSessionCompleted(
        ctx context.Context,
        event stripe.Event,
        log *slog.Logger,
) (*provider.PaymentEvent, error) <span class="cov0" title="0">{
        var session stripe.CheckoutSession
        if err := json.Unmarshal(event.Data.Raw, &amp;session); err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "parsing checkout.session.completed",
                        "error", err,
                )
                return nil, fmt.Errorf(
                        "error parsing checkout.pi.completed: %w", err)
        }</span>

        <span class="cov0" title="0">log = log.With(
                "checkout_session_id", session.ID,
                "payment_intent_id", session.PaymentIntent.ID,
        )
        se, err := s.checkoutService.GetSession(ctx, session.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">amount, err := s.parseAmount(session.AmountSubtotal, string(session.Currency))
        if err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "error parsing amount",
                        "error", err,
                )
                return nil, fmt.Errorf("error parsing amount: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.bus.Emit(
                ctx,
                events.NewPaymentProcessed(
                        &amp;events.FlowEvent{
                                ID:            uuid.New(),
                                UserID:        se.UserID,
                                AccountID:     se.AccountID,
                                FlowType:      "payment",
                                CorrelationID: uuid.New(),
                        }, func(pp *events.PaymentProcessed) </span><span class="cov0" title="0">{
                                pp.TransactionID = se.TransactionID
                                paymentID := session.PaymentIntent.ID
                                pp.PaymentID = &amp;paymentID
                                log.Info("Emitting ", "event_type", pp.Type())
                        }</span>,
                ).WithAmount(amount).WithPaymentID(session.PaymentIntent.ID),
        ); err != nil <span class="cov0" title="0">{
                log.Error(
                        "error emitting payment processed event",
                        "error", err,
                )
                return nil, fmt.Errorf("error emitting payment processed event: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info(
                "✅ Checkout pi and transaction updated successfully",
                "transaction_id", se.TransactionID,
                "checkout_session_id", session.ID,
                "payment_intent_id", session.PaymentIntent.ID,
        )

        return &amp;provider.PaymentEvent{
                ID:        session.PaymentIntent.ID,
                Status:    provider.PaymentCompleted,
                Amount:    session.PaymentIntent.Amount,
                Currency:  string(session.Currency),
                UserID:    se.UserID,
                AccountID: se.AccountID,
        }, nil</span>
}

// handleCheckoutSessionExpired handles the checkout.session.expired event
func (s *StripePaymentProvider) handleCheckoutSessionExpired(
        ctx context.Context,
        event stripe.Event,
        log *slog.Logger,
) (*provider.PaymentEvent, error) <span class="cov0" title="0">{
        var session stripe.CheckoutSession
        if err := json.Unmarshal(event.Data.Raw, &amp;session); err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "parsing checkout.session.expired",
                        "error", err,
                )
                return nil, fmt.Errorf(
                        "error parsing checkout.session.expired: %w", err)
        }</span>

        <span class="cov0" title="0">log = log.With(
                "checkout_session_id", session.ID,
                "payment_intent_id", session.PaymentIntent.ID,
        )

        // Get transaction ID from metadata
        transactionID, err := uuid.Parse(session.Metadata["transaction_id"])
        if err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "invalid transaction_id in metadata",
                        "error", err,
                        "metadata", session.Metadata,
                )
                return nil, fmt.Errorf("invalid transaction_id in metadata: %w", err)
        }</span>

        // Update the checkout session status to expired
        <span class="cov0" title="0">if err := s.checkoutService.UpdateStatus(
                ctx,
                session.ID,
                "expired",
        ); err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "updating checkout session status to expired",
                        "error", err,
                        "transaction_id", transactionID,
                )
                return nil, fmt.Errorf("error updating session status: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info(
                "⏰ Checkout session and transaction updated to expired",
                "transaction_id", transactionID,
        )
        return nil, nil</span>
}

// handlePaymentIntentSucceeded handles the payment_intent.succeeded event
func (s *StripePaymentProvider) handlePaymentIntentSucceeded(
        ctx context.Context,
        event stripe.Event,
        log *slog.Logger,
) (
        *provider.PaymentEvent,
        error,
) <span class="cov0" title="0">{
        const op = "stripe.handlePaymentIntentSucceeded"
        var pi stripe.PaymentIntent
        if err := json.Unmarshal(event.Data.Raw, &amp;pi); err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s: failed to unmarshal payment intent: %w", op, err)
                log.Error(err.Error())
                return nil, err
        }</span>
        <span class="cov0" title="0">log = log.With("payment_intent_id", pi.ID)

        // Expand PaymentIntent to include latest_charge.balance_transaction
        piFull, err := s.client.V1PaymentIntents.Retrieve(
                ctx,
                pi.ID,
                &amp;stripe.PaymentIntentRetrieveParams{
                        Expand: []*string{stripe.String("latest_charge.balance_transaction")},
                })
        if err == nil &amp;&amp; piFull != nil </span><span class="cov0" title="0">{
                pi = *piFull
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                log.Warn("Failed to expand payment intent with balance_transaction", "error", err)
        }</span>

        // Retrieve the Stripe fee using the balance transaction
        <span class="cov0" title="0">var feeAmount int64 = 0
        feeCurrency := strings.ToUpper(string(pi.Currency))

        // Only try to get fee if we have a balance transaction
        if pi.LatestCharge != nil &amp;&amp;
                pi.LatestCharge.BalanceTransaction != nil &amp;&amp;
                pi.LatestCharge.BalanceTransaction.ID != "" </span><span class="cov0" title="0">{
                balanceTxID := pi.LatestCharge.BalanceTransaction.ID
                var feeErr error
                feeAmount, feeCurrency, feeErr = s.getFeeFromBalanceTransaction(ctx, log, balanceTxID)
                if feeErr != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to retrieve fee from balance transaction, using 0 fee",
                                "error", feeErr,
                                "balance_transaction_id", balanceTxID)
                        // Continue with 0 fee but log the error
                }</span>
        } else<span class="cov0" title="0"> {
                log.Info("No balance transaction found on PaymentIntent, using 0 fee",
                        "payment_intent_id", pi.ID,
                        "has_latest_charge", pi.LatestCharge != nil)
        }</span>

        // Ensure we have a valid currency
        <span class="cov0" title="0">if feeCurrency == "" </span><span class="cov0" title="0">{
                feeCurrency = strings.ToUpper(string(pi.Currency))
                log.Warn("Empty fee currency, falling back to payment intent currency",
                        "fallback_currency", feeCurrency)
        }</span>
        <span class="cov0" title="0">s.logStripeFeeInfo(log, &amp;pi)
        log.Info("💰 Handling payment_intent.succeeded event", "payment_intent_id", pi.ID)
        parsedMeta, err := s.parseAndValidateMetadata(pi.Metadata, log)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s: invalid metadata: %w", op, err)
                log.Error(err.Error())
                return nil, err
        }</span>
        <span class="cov0" title="0">metadata := s.copyMetadata(pi.Metadata)
        fee, err := s.parseProviderFeeAmount(feeAmount, feeCurrency, log)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s: failed to parse provider fee: %w", op, err)
                log.Error(err.Error(),
                        "fee_amount", feeAmount,
                        "fee_currency", feeCurrency,
                        "payment_intent_id", pi.ID,
                )
                return nil, err
        }</span>
        <span class="cov0" title="0">currencyCode := strings.ToUpper(string(pi.Currency))
        amount, err := money.NewFromSmallestUnit(pi.Amount, money.Code(currencyCode))
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to create money amount", "error", err, "currency", currencyCode)
                return nil, fmt.Errorf("failed to create money amount: %w", err)
        }</span>
        <span class="cov0" title="0">pp := &amp;events.PaymentProcessed{
                PaymentInitiated: events.PaymentInitiated{
                        FlowEvent: events.FlowEvent{
                                ID:            uuid.New(),
                                FlowType:      "payment",
                                UserID:        parsedMeta.UserID,
                                AccountID:     parsedMeta.AccountID,
                                CorrelationID: parsedMeta.TransactionID,
                                Timestamp:     time.Now(),
                        },
                        TransactionID: parsedMeta.TransactionID,
                        PaymentID:     &amp;pi.ID,
                        Amount:        amount,
                },
        }
        log.Info("🔄 Emitting PaymentProcessed event",
                "transaction_id", parsedMeta.TransactionID,
                "payment_id", pi.ID)
        if err := s.bus.Emit(ctx, pp); err != nil </span><span class="cov0" title="0">{
                log.Error("error emitting payment processed event", "error", err)
                return nil, fmt.Errorf("error emitting payment processed event: %w", err)
        }</span>
        // Emit PaymentCompleted event with the actual Stripe fee
        <span class="cov0" title="0">pc := s.buildPaymentCompletedEventPayload(&amp;pi, parsedMeta, *fee, log)
        if pc == nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("failed to build payment completed event payload")
                log.Error(err.Error())
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := s.bus.Emit(ctx, pc); err != nil </span><span class="cov0" title="0">{
                log.Error("error emitting payment completed event", "error", err)
                return nil, fmt.Errorf("error emitting payment completed event: %w", err)
        }</span>
        <span class="cov0" title="0">log.Info("✅ Payment intent processed and transaction updated successfully",
                "transaction_id", parsedMeta.TransactionID, "payment_id", pi.ID)
        return &amp;provider.PaymentEvent{
                ID:        pi.ID,
                Status:    provider.PaymentCompleted,
                Amount:    pi.Amount,
                Currency:  string(pi.Currency),
                UserID:    parsedMeta.UserID,
                AccountID: parsedMeta.AccountID,
                Metadata:  metadata,
        }, nil</span>
}

// getFeeFromBalanceTransaction retrieves the balance transaction
// and returns the fee amount and currency.
func (s *StripePaymentProvider) getFeeFromBalanceTransaction(
        ctx context.Context,
        log *slog.Logger,
        balanceTxID string,
) (int64, string, error) <span class="cov0" title="0">{
        bt, err := s.client.V1BalanceTransactions.Retrieve(ctx, balanceTxID, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Warn(
                        "Failed to retrieve balance transaction",
                        "error", err,
                        "balance_transaction_id", balanceTxID,
                )
                return 0, "", err
        }</span>
        <span class="cov0" title="0">log.Debug("Retrieved balance transaction", "balance_transaction", bt)
        feeAmount := bt.Fee
        feeCurrency := strings.ToUpper(string(bt.Currency))
        log.Info("Retrieved fee from balance transaction",
                "fee_amount", feeAmount,
                "fee_currency", feeCurrency,
                "balance_transaction_id", balanceTxID,
        )
        return feeAmount, feeCurrency, nil</span>
}

// logStripeFeeInfo logs Stripe fee-related info.
func (s *StripePaymentProvider) logStripeFeeInfo(log *slog.Logger, pi *stripe.PaymentIntent) <span class="cov0" title="0">{
        log.Info("Stripe fees",
                "amount_received", pi.AmountReceived,
                "amount_details", pi.AmountDetails,
                "application_fee", pi.ApplicationFeeAmount,
                "currency", pi.Currency,
        )
}</span>

// metadataInfo holds parsed metadata fields.
type metadataInfo struct {
        UserID        uuid.UUID
        AccountID     uuid.UUID
        TransactionID uuid.UUID
        Currency      string
}

// parseAndValidateMetadata extracts and validates required fields from metadata.
func (s *StripePaymentProvider) parseAndValidateMetadata(
        meta map[string]string,
        log *slog.Logger,
) (*metadataInfo, error) <span class="cov0" title="0">{
        userID, err := uuid.Parse(meta["user_id"])
        if err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "invalid user_id in metadata",
                        "error", err,
                        "metadata", meta,
                )
                return nil, fmt.Errorf("invalid user_id in metadata: %w", err)
        }</span>
        <span class="cov0" title="0">accountID, err := uuid.Parse(meta["account_id"])
        if err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "invalid account_id in metadata",
                        "error", err,
                        "metadata", meta,
                )
                return nil, fmt.Errorf("invalid account_id in metadata: %w", err)
        }</span>
        <span class="cov0" title="0">transactionID, err := uuid.Parse(meta["transaction_id"])
        if err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "invalid transaction_id in metadata",
                        "error", err,
                        "metadata", meta,
                )
                return nil, fmt.Errorf(
                        "invalid transaction_id in metadata: %w", err)
        }</span>
        <span class="cov0" title="0">currencyCode := meta["currency"]
        return &amp;metadataInfo{
                UserID:        userID,
                AccountID:     accountID,
                TransactionID: transactionID,
                Currency:      currencyCode,
        }, nil</span>
}

// copyMetadata creates a copy of the metadata map.
func (s *StripePaymentProvider) copyMetadata(
        meta map[string]string,
) map[string]string <span class="cov0" title="0">{
        copied := make(map[string]string)
        maps.Copy(copied, meta)
        return copied
}</span>

// parseAmount converts a Stripe amount and currency to a money.Money object.
func (s *StripePaymentProvider) parseAmount(
        amount int64,
        currency string,
) (*money.Money, error) <span class="cov0" title="0">{
        // Convert currency to uppercase to ensure it's valid
        currencyCode := strings.ToUpper(currency)

        // Create money amount from the smallest unit (cents for USD)
        moneyAmount, err := money.NewFromSmallestUnit(amount, money.Code(currencyCode))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to create money amount",
                        "error", err,
                        "amount", amount,
                        "currency", currencyCode,
                )
                return nil, fmt.Errorf("failed to create money amount: %w", err)
        }</span>

        <span class="cov0" title="0">return moneyAmount, nil</span>
}

// parseProviderFeeAmount parses the provider fee amount with validation.
func (s *StripePaymentProvider) parseProviderFeeAmount(
        feeAmount int64,
        cur string,
        log *slog.Logger,
) (*money.Money, error) <span class="cov0" title="0">{
        // Validate currency code
        if cur == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("empty currency code provided for fee amount %d", feeAmount)
                log.Error("invalid currency code", "error", err)
                return nil, fmt.Errorf("invalid currency code: %w", err)
        }</span>

        // Convert to uppercase to ensure consistency
        <span class="cov0" title="0">currency := strings.ToUpper(cur)

        // Log the fee being processed for debugging
        log = log.With(
                "fee_amount", feeAmount,
                "fee_currency", currency,
        )

        // Create money object with validated currency
        fee, err := money.NewFromSmallestUnit(feeAmount, money.Code(currency))
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("invalid fee amount %d %s: %w", feeAmount, currency, err)
                log.Error("error creating money from smallest unit", "error", err)
                return nil, fmt.Errorf("error creating money from smallest unit: %w", err)
        }</span>

        <span class="cov0" title="0">log.Debug("successfully parsed provider fee")
        return fee, nil</span>
}

// It ensures the fee amount is properly formatted and logs the fee being included in the event.
func (s *StripePaymentProvider) buildPaymentCompletedEventPayload(
        pi *stripe.PaymentIntent,
        meta *metadataInfo,
        feeAmount money.Money,
        log *slog.Logger,
) *events.PaymentCompleted <span class="cov0" title="0">{
        // Create payment amount with proper error handling
        currency := money.Code(strings.ToUpper(string(pi.Currency)))
        paymentAmount, err := money.NewFromSmallestUnit(pi.Amount, currency)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("error creating payment amount",
                        "error", err,
                        "amount", pi.Amount,
                        "currency", pi.Currency,
                )
                // Fallback to zero amount if we can't parse the payment amount
                zero, zeroErr := money.NewFromSmallestUnit(0, currency)
                if zeroErr != nil </span><span class="cov0" title="0">{
                        log.Error("failed to create zero amount", "error", zeroErr, "currency", currency)
                        // If we can't even create a zero amount, we have to fail
                        return nil
                }</span>
                <span class="cov0" title="0">paymentAmount = zero</span>
        }

        // Create provider fee with proper initialization
        // feeAmount is already money.Money value, we need to take its address
        <span class="cov0" title="0">feeCopy := feeAmount // Create a copy to take address of
        providerFee := account.Fee{
                Amount: &amp;feeCopy,
                Type:   account.FeeProvider,
        }

        // Build the event with all required fields
        event := &amp;events.PaymentCompleted{
                PaymentInitiated: events.PaymentInitiated{
                        FlowEvent: events.FlowEvent{
                                ID:            uuid.New(),
                                FlowType:      "payment",
                                UserID:        meta.UserID,
                                AccountID:     meta.AccountID,
                                CorrelationID: meta.TransactionID,
                                Timestamp:     time.Now(),
                        },
                        TransactionID: meta.TransactionID,
                        PaymentID:     &amp;pi.ID,
                        Amount:        paymentAmount, // This is already a *money.Money
                },
                ProviderFee: providerFee,
        }

        log.Info("built payment completed event",
                "transaction_id", meta.TransactionID,
                "amount", paymentAmount.String(),
                "fee", feeAmount.String(),
                "currency", pi.Currency,
        )

        return event</span>
}
func (s *StripePaymentProvider) handlePaymentIntentFailed(
        ctx context.Context,
        event stripe.Event, log *slog.Logger) (*provider.PaymentEvent, error) <span class="cov0" title="0">{
        var paymentIntent stripe.PaymentIntent
        if err := json.Unmarshal(event.Data.Raw, &amp;paymentIntent); err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "error parsing payment_intent.payment_failed",
                        "error", err,
                )
                return nil, fmt.Errorf(
                        "error parsing payment_intent.payment_failed: %w", err)
        }</span>

        <span class="cov0" title="0">log = log.With("payment_intent_id", paymentIntent.ID)

        // Get the payment intent details
        pi, err := s.client.V1PaymentIntents.Retrieve(
                context.Background(),
                paymentIntent.ID,
                nil,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "error retrieving payment intent",
                        "error", err,
                )
                return nil, fmt.Errorf("error retrieving payment intent: %w", err)
        }</span>

        // Get the user ID, account ID, and transaction ID from metadata
        <span class="cov0" title="0">userID, err := uuid.Parse(paymentIntent.Metadata["user_id"])
        if err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "invalid user_id in metadata",
                        "error", err,
                        "metadata", paymentIntent.Metadata,
                )
                return nil, fmt.Errorf("invalid user_id in metadata: %w", err)
        }</span>

        <span class="cov0" title="0">accountID, err := uuid.Parse(paymentIntent.Metadata["account_id"])
        if err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "invalid account_id in metadata",
                        "error", err,
                        "metadata", paymentIntent.Metadata,
                )
                return nil, fmt.Errorf("invalid account_id in metadata: %w", err)
        }</span>

        <span class="cov0" title="0">transactionID, err := uuid.Parse(
                paymentIntent.Metadata["transaction_id"])
        if err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "invalid transaction_id in metadata",
                        "error", err,
                        "metadata", paymentIntent.Metadata,
                )
                return nil, fmt.Errorf("invalid transaction_id in metadata: %w", err)
        }</span>

        // Create metadata map from payment intent metadata
        <span class="cov0" title="0">metadata := make(map[string]string)
        maps.Copy(metadata, paymentIntent.Metadata)

        if err := s.bus.Emit(ctx, events.NewPaymentFailed(
                &amp;events.FlowEvent{
                        ID:            transactionID,
                        UserID:        userID,
                        AccountID:     accountID,
                        FlowType:      "payment",
                        CorrelationID: uuid.New(),
                },
                events.WithFailedPaymentID(&amp;pi.ID),
        )); err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "error emitting payment failed event",
                        "error", err,
                )
                return nil, fmt.Errorf("error emitting payment failed event: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info(
                "✅ Payment intent failed and transaction updated",
                "transaction_id", transactionID,
                "payment_id", paymentIntent.ID,
        )

        return &amp;provider.PaymentEvent{
                ID:        pi.ID,
                Status:    provider.PaymentFailed,
                Amount:    pi.Amount,
                Currency:  string(pi.Currency),
                UserID:    userID,
                AccountID: accountID,
                Metadata:  metadata,
        }, nil</span>
}

// ensureAbsoluteURL ensures the URL is absolute by prepending the base URL if needed
func (s *StripePaymentProvider) ensureAbsoluteURL(path string) string <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">u, err := url.Parse(path)
        if err != nil </span><span class="cov0" title="0">{
                return path
        }</span>

        // If it's already an absolute URL, return as is
        <span class="cov0" title="0">if u.IsAbs() </span><span class="cov0" title="0">{
                return path
        }</span>

        <span class="cov0" title="0">return path</span>
}

func (s *StripePaymentProvider) handleChargeSucceeded(
        ctx context.Context,
        event stripe.Event,
        logger *slog.Logger,
) (
        *provider.PaymentEvent,
        error,
) <span class="cov0" title="0">{
        var charge stripe.Charge
        if err := json.Unmarshal(event.Data.Raw, &amp;charge); err != nil </span><span class="cov0" title="0">{
                logger.Error(
                        "error parsing charge.succeeded",
                        "error", err,
                )
                return nil, fmt.Errorf(
                        "error parsing charge.succeeded: %w", err)
        }</span>
        // Always attempt to retrieve the Stripe fee from the balance transaction.
        <span class="cov0" title="0">balanceTxID := ""
        if charge.BalanceTransaction != nil </span><span class="cov0" title="0">{
                balanceTxID = charge.BalanceTransaction.ID
        }</span>
        <span class="cov0" title="0">feeAmount := int64(0)
        feeCurrency := string(charge.Currency)
        var feeErr error
        if balanceTxID != "" </span><span class="cov0" title="0">{
                feeAmount, feeCurrency, feeErr = s.getFeeFromBalanceTransaction(ctx, logger, balanceTxID)
                if feeErr != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to retrieve fee from balance transaction", "error", feeErr)
                        feeAmount = 0
                        feeCurrency = string(charge.Currency)
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Warn("No balance transaction found on Charge, defaulting fee to 0")
        }</span>
        <span class="cov0" title="0">if feeCurrency == "" </span><span class="cov0" title="0">{
                feeCurrency = string(charge.Currency)
        }</span>
        <span class="cov0" title="0">feeCurrency = strings.ToUpper(feeCurrency)
        logger = logger.With("charge_id", charge.ID, "balance_transaction_id", balanceTxID)
        logger.Info("✅ Charge succeeded", "fee_amount", feeAmount, "fee_currency", feeCurrency)
        // Process and emit fee if metadata is valid
        if feeEvent, err := s.createFeeEvent(
                charge.Metadata,
                feeAmount,
                feeCurrency,
                logger,
        ); err == nil </span><span class="cov0" title="0">{
                logger.Info("Emitting FeesCalculated event", "event", feeEvent)
                _ = s.bus.Emit(ctx, feeEvent)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// createFeeEvent creates a FeesCalculated event from the given
// transaction metadata and fee details.
// It returns the created event or an error if any required metadata is missing or invalid.
func (s *StripePaymentProvider) createFeeEvent(
        metadata map[string]string,
        feeAmount int64,
        feeCurrency string,
        logger *slog.Logger,
) (*events.FeesCalculated, error) <span class="cov0" title="0">{
        // Validate metadata exists
        if len(metadata) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing required metadata")
        }</span>

        // Parse required metadata fields
        <span class="cov0" title="0">userID, err := uuid.Parse(metadata["user_id"])
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to parse user_id from metadata", "error", err)
                return nil, fmt.Errorf("invalid user_id: %w", err)
        }</span>

        <span class="cov0" title="0">accountID, err := uuid.Parse(metadata["account_id"])
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to parse account_id from metadata", "error", err)
                return nil, fmt.Errorf("invalid account_id: %w", err)
        }</span>

        <span class="cov0" title="0">transactionID, err := uuid.Parse(metadata["transaction_id"])
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to parse transaction_id from metadata", "error", err)
                return nil, fmt.Errorf("invalid transaction_id: %w", err)
        }</span>

        // Parse fee amount into money type
        <span class="cov0" title="0">feeMoney, err := s.parseProviderFeeAmount(feeAmount, feeCurrency, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to parse provider fee amount",
                        "amount", feeAmount,
                        "currency", feeCurrency,
                        "error", err)
                return nil, fmt.Errorf("invalid fee amount: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Debug("Creating fee event",
                "user_id", userID,
                "account_id", accountID,
                "transaction_id", transactionID,
                "fee_amount", feeMoney.Amount(),
                "fee_currency", feeMoney.Currency().String())

        // Create and return the fee event
        feeEvent := events.NewFeesCalculated(
                &amp;events.FlowEvent{
                        ID:            uuid.New(),
                        UserID:        userID,
                        AccountID:     accountID,
                        FlowType:      "payment",
                        CorrelationID: transactionID,
                        Timestamp:     time.Now(),
                },
                events.WithFeeAmountValue(feeMoney),
                events.WithFeeTransactionID(transactionID),
                events.WithFeeType(account.FeeProvider),
        )

        return feeEvent, nil</span>
}
</pre>

		<pre class="file" id="file12" style="display: none">package provider

import (
        "log/slog"

        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/amirasaad/fintech/pkg/registry"
)

// Deprecated: Use provider.ExchangeRate interface directly.
type ExchangeRateCurrencyConverter = provider.ExchangeRate

// exchangeRateService provides real-time exchange rates with caching and fallback providers.
//
// Deprecated: Use exchange.Service from github.com/amirasaad/fintech/pkg/service/exchange instead.
type exchangeRateService struct {
        providers []provider.ExchangeRate
        cache     registry.Provider
        logger    *slog.Logger
        cfg       *config.ExchangeRateProviders
}

// NewExchangeRateService creates a new exchange rate service.
//
// Deprecated: Use exchange.New from github.com/amirasaad/fintech/pkg/service/exchange instead.
func NewExchangeRateService(
        providers []provider.ExchangeRate,
        cache registry.Provider,
        logger *slog.Logger,
        cfg *config.ExchangeRateProviders,
) *exchangeRateService <span class="cov0" title="0">{
        return &amp;exchangeRateService{
                providers: providers,
                cache:     cache,
                logger:    logger,
                cfg:       cfg,
        }
}</span>

// GetRate retrieves an exchange rate, trying cache first, then providers in order.
//
// Deprecated: Use exchange.Service.GetRate instead.
func (s *exchangeRateService) GetRate(from, to string) (*domain.ConversionInfo, error) <span class="cov0" title="0">{
        // Implementation moved to exchange/service.go
        return nil, domain.ErrExchangeRateUnavailable
}</span>

// GetRates retrieves multiple exchange rates efficiently.
//
// Deprecated: Use exchange.Service.GetRates instead.
func (s *exchangeRateService) GetRates(
        from string,
        to []string,
) (map[string]*domain.ConversionInfo, error) <span class="cov0" title="0">{
        // Implementation moved to exchange/service.go
        return nil, domain.ErrExchangeRateUnavailable
}</span>

// Deprecated: Use NewExchangeRateAPIProvider instead.
func NewExchangeRateCurrencyConverter(
        exchangeRateService *exchangeRateService,
        fallback ExchangeRateCurrencyConverter,
        logger *slog.Logger,
) ExchangeRateCurrencyConverter <span class="cov0" title="0">{
        return NewExchangeRateAPIProvider(&amp;config.ExchangeRateApi{}, logger)
}</span>
</pre>

		<pre class="file" id="file13" style="display: none">package account

import (
        "github.com/amirasaad/fintech/infra/repository/transaction"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

// Account represents an account record in the database.
type Account struct {
        gorm.Model
        ID           uuid.UUID `gorm:"type:uuid;primary_key"`
        UserID       uuid.UUID `gorm:"type:uuid"`
        Balance      int64
        Currency     string `gorm:"type:varchar(3);not null;default:'USD'"`
        Transactions []transaction.Transaction
}

// TableName specifies the table name for the Account model.
func (Account) TableName() string <span class="cov0" title="0">{
        return "accounts"
}</span>
</pre>

		<pre class="file" id="file14" style="display: none">package account

import (
        "context"

        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type repository struct {
        db *gorm.DB
}

// New creates a new CQRS-style account repository
// using the provided *gorm.DB.
func New(db *gorm.DB) *repository <span class="cov0" title="0">{
        return &amp;repository{db: db}
}</span>

// Create implements account.Repository.
func (r *repository) Create(
        ctx context.Context,
        create dto.AccountCreate,
) error <span class="cov0" title="0">{
        acct := mapCreateDTOToModel(create)
        return r.db.WithContext(ctx).Create(&amp;acct).Error
}</span>

// Update implements account.Repository.
func (r *repository) Update(
        ctx context.Context,
        id uuid.UUID,
        update dto.AccountUpdate,
) error <span class="cov0" title="0">{
        updates := mapUpdateDTOToModel(update)
        return r.db.WithContext(ctx).Model(&amp;Account{}).Where("id = ?", id).Updates(updates).Error
}</span>

// Get implements account.Repository.
func (r *repository) Get(
        ctx context.Context,
        id uuid.UUID,
) (*dto.AccountRead, error) <span class="cov0" title="0">{
        var acct Account
        if err := r.db.WithContext(ctx).First(&amp;acct, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return mapModelToDTO(&amp;acct), nil</span>
}

// ListByUser implements account.Repository.
func (r *repository) ListByUser(
        ctx context.Context,
        userID uuid.UUID,
) ([]*dto.AccountRead, error) <span class="cov0" title="0">{
        var accts []Account
        if err := r.db.WithContext(ctx).Where("user_id = ?", userID).Find(&amp;accts).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">result := make([]*dto.AccountRead, 0, len(accts))
        for i := range accts </span><span class="cov0" title="0">{
                result = append(result, mapModelToDTO(&amp;accts[i]))
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// mapCreateDTOToModel maps AccountCreate DTO to GORM model.
func mapCreateDTOToModel(create dto.AccountCreate) Account <span class="cov0" title="0">{
        return Account{
                ID:       create.ID,
                UserID:   create.UserID,
                Balance:  0,
                Currency: create.Currency,
                // Add more fields as needed
        }
}</span>

// mapUpdateDTOToModel maps AccountUpdate DTO to a map for GORM Updates.
func mapUpdateDTOToModel(update dto.AccountUpdate) map[string]any <span class="cov0" title="0">{
        updates := make(map[string]any)
        if update.Balance != nil </span><span class="cov0" title="0">{
                updates["balance"] = *update.Balance
        }</span>
        // if update.Status != nil {
        //         updates["status"] = *update.Status
        // }
        // Add more fields as needed
        <span class="cov0" title="0">return updates</span>
}

// mapModelToDTO maps a GORM model to a read-optimized DTO.
func mapModelToDTO(acct *Account) *dto.AccountRead <span class="cov0" title="0">{
        bal := money.NewFromData(acct.Balance, acct.Currency)
        return &amp;dto.AccountRead{
                ID:        acct.ID,
                UserID:    acct.UserID,
                Balance:   bal.AmountFloat(),
                Currency:  bal.Currency().String(),
                CreatedAt: acct.CreatedAt,
        }
}</span>
</pre>

		<pre class="file" id="file15" style="display: none">package transaction

import (
        "github.com/google/uuid"
        "gorm.io/gorm"
)

// Transaction represents a persisted financial transaction.
type Transaction struct {
        gorm.Model
        ID        uuid.UUID `gorm:"type:uuid;primary_key"`
        AccountID uuid.UUID `gorm:"type:uuid"`
        UserID    uuid.UUID `gorm:"type:uuid"`
        Amount    int64
        Currency  string `gorm:"type:varchar(3);not null;default:'USD'"`
        Balance   int64
        Status    string  `gorm:"type:varchar(32);not null;default:'pending'"`
        PaymentID *string `gorm:"type:varchar(64);column:payment_id;index"`

        // Conversion fields (nullable when no conversion occurs)
        OriginalAmount   *float64 `gorm:"type:decimal(20,8)"`
        OriginalCurrency *string  `gorm:"type:varchar(3)"`
        ConversionRate   *float64 `gorm:"type:decimal(20,8)"`

        // MoneySource indicates the origin of funds (e.g., Cash, BankAccount, Stripe, etc.)
        MoneySource          string `gorm:"type:varchar(64);not null;default:'Internal'"`
        ExternalTargetMasked string `gorm:"type:varchar(128);column:external_target_masked"`

        // TargetCurrency is the currency the account is credited in (for multi-currency deposits)
        TargetCurrency string `gorm:"type:varchar(8);column:target_currency"`

        // Fee is the transaction fee in the smallest currency unit (e.g., cents)
        Fee *int64 `gorm:"type:bigint;default:0"`
}

// TableName specifies the table name for the Transaction model.
func (Transaction) TableName() string <span class="cov0" title="0">{
        return "transactions"
}</span>
</pre>

		<pre class="file" id="file16" style="display: none">package transaction // import alias for infra/repository/transaction

import (
        "context"

        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/money"
        repo "github.com/amirasaad/fintech/pkg/repository/transaction"
        "github.com/google/uuid"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

type repository struct {
        db *gorm.DB
}

// New creates a new CQRS-style transaction repository using the provided *gorm.DB.
func New(db *gorm.DB) repo.Repository <span class="cov0" title="0">{
        return &amp;repository{db: db}
}</span>

// Create implements transaction.Repository.
func (r *repository) Create(
        ctx context.Context,
        create dto.TransactionCreate,
) error <span class="cov0" title="0">{
        tx := mapCreateDTOToModel(create)
        return r.db.WithContext(ctx).Create(&amp;tx).Error
}</span>

// Update implements transaction.Repository.
func (r *repository) Update(
        ctx context.Context,
        id uuid.UUID,
        update dto.TransactionUpdate,
) error <span class="cov0" title="0">{
        updates := mapUpdateDTOToModel(update)
        return r.db.WithContext(
                ctx,
        ).Model(
                &amp;Transaction{},
        ).Where(
                "id = ?",
                id,
        ).Updates(
                updates,
        ).Error
}</span>

// PartialUpdate implements transaction.Repository.
func (r *repository) PartialUpdate(
        ctx context.Context,
        id uuid.UUID,
        update dto.TransactionUpdate,
) error <span class="cov0" title="0">{
        updates := mapUpdateDTOToModel(update)
        return r.db.WithContext(
                ctx,
        ).Model(
                &amp;Transaction{},
        ).Where(
                "id = ?",
                id,
        ).Updates(
                updates,
        ).Error
}</span>

// UpsertByPaymentID implements transaction.Repository.
func (r *repository) UpsertByPaymentID(
        ctx context.Context,
        paymentID string,
        create dto.TransactionCreate,
) error <span class="cov0" title="0">{
        tx := mapCreateDTOToModel(create)
        if paymentID != "" </span><span class="cov0" title="0">{
                tx.PaymentID = &amp;paymentID
        }</span>
        <span class="cov0" title="0">return r.db.WithContext(
                ctx,
        ).Clauses(
                clause.OnConflict{
                        Columns:   []clause.Column{{Name: "payment_id"}},
                        DoUpdates: clause.AssignmentColumns([]string{"status", "amount"}),
                },
        ).Create(&amp;tx).Error</span>
}

// Get implements transaction.Repository.
func (r *repository) Get(
        ctx context.Context,
        id uuid.UUID,
) (*dto.TransactionRead, error) <span class="cov0" title="0">{
        var tx Transaction
        if err := r.db.WithContext(
                ctx,
        ).First(
                &amp;tx,
                "id = ?",
                id,
        ).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return mapModelToReadDTO(&amp;tx), nil</span>
}

// GetByPaymentID implements transaction.Repository.
func (r *repository) GetByPaymentID(
        ctx context.Context,
        paymentID string,
) (*dto.TransactionRead, error) <span class="cov0" title="0">{
        var tx Transaction
        if err := r.db.WithContext(
                ctx,
        ).Where(
                "payment_id = ?",
                paymentID,
        ).First(
                &amp;tx,
        ).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return mapModelToReadDTO(&amp;tx), nil</span>
}

// ListByUser implements transaction.Repository.
func (r *repository) ListByUser(
        ctx context.Context,
        userID uuid.UUID,
) ([]*dto.TransactionRead, error) <span class="cov0" title="0">{
        var txs []Transaction
        if err := r.db.WithContext(
                ctx,
        ).Where(
                "user_id = ?",
                userID,
        ).Find(
                &amp;txs,
        ).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">result := make([]*dto.TransactionRead, 0, len(txs))
        for i := range txs </span><span class="cov0" title="0">{
                result = append(result, mapModelToReadDTO(&amp;txs[i]))
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// ListByAccount implements transaction.Repository.
func (r *repository) ListByAccount(
        ctx context.Context,
        accountID uuid.UUID,
) ([]*dto.TransactionRead, error) <span class="cov0" title="0">{
        var txs []Transaction
        if err := r.db.WithContext(
                ctx,
        ).Where(
                "account_id = ?",
                accountID,
        ).Find(
                &amp;txs,
        ).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">result := make([]*dto.TransactionRead, 0, len(txs))
        for i := range txs </span><span class="cov0" title="0">{
                result = append(result, mapModelToReadDTO(&amp;txs[i]))
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// --- Mappers ---

func mapCreateDTOToModel(create dto.TransactionCreate) Transaction <span class="cov0" title="0">{
        tx := Transaction{
                ID:          create.ID,
                UserID:      create.UserID,
                AccountID:   create.AccountID,
                Amount:      create.Amount,
                Status:      create.Status,
                MoneySource: create.MoneySource,
        }

        // Set PaymentID if it's not nil
        if create.PaymentID != nil &amp;&amp; *create.PaymentID != "" </span><span class="cov0" title="0">{
                tx.PaymentID = create.PaymentID
        }</span>

        <span class="cov0" title="0">return tx</span>
}

func mapUpdateDTOToModel(update dto.TransactionUpdate) map[string]any <span class="cov0" title="0">{
        updates := make(map[string]any)
        if update.Status != nil </span><span class="cov0" title="0">{
                updates["status"] = *update.Status
        }</span>
        <span class="cov0" title="0">if update.Amount != nil </span><span class="cov0" title="0">{
                updates["amount"] = *update.Amount
        }</span>
        <span class="cov0" title="0">if update.Currency != nil </span><span class="cov0" title="0">{
                updates["currency"] = *update.Currency
        }</span>
        <span class="cov0" title="0">if update.Balance != nil </span><span class="cov0" title="0">{
                updates["balance"] = *update.Balance
        }</span>
        <span class="cov0" title="0">if update.PaymentID != nil </span><span class="cov0" title="0">{
                updates["payment_id"] = *update.PaymentID
        }</span>
        <span class="cov0" title="0">if update.Fee != nil </span><span class="cov0" title="0">{
                updates["fee"] = *update.Fee
        }</span>
        <span class="cov0" title="0">if update.ConversionRate != nil </span><span class="cov0" title="0">{
                updates["conversion_rate"] = update.ConversionRate
        }</span>
        <span class="cov0" title="0">if update.OriginalAmount != nil </span><span class="cov0" title="0">{
                updates["original_amount"] = update.OriginalAmount
        }</span>
        <span class="cov0" title="0">if update.OriginalCurrency != nil </span><span class="cov0" title="0">{
                updates["original_currency"] = *update.OriginalCurrency
        }</span>

        // Add more fields as needed
        <span class="cov0" title="0">return updates</span>
}

func mapModelToReadDTO(tx *Transaction) *dto.TransactionRead <span class="cov0" title="0">{
        amount, err := money.NewFromSmallestUnit(tx.Amount, money.Code(tx.Currency))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">dto := &amp;dto.TransactionRead{
                ID:        tx.ID,
                UserID:    tx.UserID,
                AccountID: tx.AccountID,
                Amount:    amount.AmountFloat(),
                Currency:  tx.Currency, // Include the currency
                Status:    tx.Status,
                CreatedAt: tx.CreatedAt,
        }

        if tx.PaymentID != nil </span><span class="cov0" title="0">{
                dto.PaymentID = tx.PaymentID
        }</span>

        <span class="cov0" title="0">return dto</span>
}
</pre>

		<pre class="file" id="file17" style="display: none">package repository

import (
        "context"
        "fmt"

        repoaccount "github.com/amirasaad/fintech/infra/repository/account"
        repotransaction "github.com/amirasaad/fintech/infra/repository/transaction"
        repouser "github.com/amirasaad/fintech/infra/repository/user"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/amirasaad/fintech/pkg/repository/account"
        "github.com/amirasaad/fintech/pkg/repository/transaction"
        "github.com/amirasaad/fintech/pkg/repository/user"
        "gorm.io/gorm"
)

// UoW provides transaction boundary and repository access in one abstraction.
//
// Why is GetRepository part of UoW?
// - Ensures all repositories use the same DB session/transaction for true atomicity.
// - Keeps service code clean and focused on business logic.
// - Centralizes repository wiring and registry for maintainability.
// - Prevents accidental use of the wrong DB session (which would break transactionality).
// - Is idiomatic for Go UoW patterns and easy to mock in tests.
type UoW struct {
        db      *gorm.DB
        tx      *gorm.DB
        repoMap map[any]func(*gorm.DB) any
}

// NewUoW creates a new UoW for the given *gorm.DB.
func NewUoW(db *gorm.DB) *UoW <span class="cov0" title="0">{
        return &amp;UoW{
                db: db,
                repoMap: map[any]func(db *gorm.DB) any{
                        (*account.Repository)(nil): func(db *gorm.DB) any </span><span class="cov0" title="0">{
                                return repoaccount.New(db)
                        }</span>,
                        (*transaction.Repository)(nil): func(db *gorm.DB) any <span class="cov0" title="0">{
                                return repotransaction.New(db)
                        }</span>,
                        (*user.Repository)(nil): func(db *gorm.DB) any <span class="cov0" title="0">{
                                return repouser.New(db)
                        }</span>,
                },
        }
}

// Do runs the given function in a transaction boundary, providing a UoW with repository access.
func (u *UoW) Do(ctx context.Context, fn func(uow repository.UnitOfWork) error) error <span class="cov0" title="0">{
        return u.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                txnUow := &amp;UoW{
                        db: u.db,
                        tx: tx,
                }
                return fn(txnUow)
        }</span>)
}

// GetRepository provides generic, type-safe access to repositories using the transaction session.
// This method is maintained for backward compatibility
// but is deprecated in favor of type-safe methods.
//
// This method is part of UoW to guarantee that all repository operations within a transaction
// use the same DB session, ensuring atomicity and consistency. It also centralizes repository
// construction and makes testing and extension easier.
func (u *UoW) GetRepository(repoType any) (any, error) <span class="cov0" title="0">{
        // Use transaction DB if available, otherwise use main DB
        dbToUse := u.tx
        if dbToUse == nil </span><span class="cov0" title="0">{
                dbToUse = u.db
        }</span>

        <span class="cov0" title="0">switch repoType </span>{
        case (*account.Repository)(nil):<span class="cov0" title="0">
                return repoaccount.New(dbToUse), nil</span>
        case (*transaction.Repository)(nil):<span class="cov0" title="0">
                return repotransaction.New(dbToUse), nil</span>
        case (*user.Repository)(nil):<span class="cov0" title="0">
                return repouser.New(dbToUse), nil</span>
        default:<span class="cov0" title="0">
                if repo, ok := u.repoMap[repoType]; ok </span><span class="cov0" title="0">{
                        return repo(dbToUse), nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf(
                        "unsupported repository type: %T, ", repoType)</span>
        }
}
</pre>

		<pre class="file" id="file18" style="display: none">package user

import (
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// User represents a user record in the database.
type User struct {
        gorm.Model
        ID        uuid.UUID `gorm:"type:uuid;primary_key;default:uuid_generate_v4()"`
        Username  string    `gorm:"uniqueIndex;not null;size:50" validate:"required,min=3,max=50"`
        Email     string    `gorm:"uniqueIndex;not null;size:255" validate:"required,email"`
        Password  string    `gorm:"not null" validate:"required,min=6"`
        Names     string    `gorm:"size:255"`
        CreatedAt time.Time
        UpdatedAt time.Time
        DeletedAt gorm.DeletedAt `gorm:"index"`
}

// TableName specifies the table name for the User model.
func (User) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>
</pre>

		<pre class="file" id="file19" style="display: none">package user

import (
        "context"
        "errors"

        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/repository/user"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

// repository defines the interface for user repository operations
type repository struct {
        // Add repository fields here if needed
        db *gorm.DB
}

func New(db *gorm.DB) user.Repository <span class="cov0" title="0">{
        return &amp;repository{db: db}
}</span>

func (r *repository) GetByEmail(
        ctx context.Context,
        email string,
) (*dto.UserRead, error) <span class="cov0" title="0">{
        var user User
        if err := r.db.WithContext(
                ctx,
        ).Where("email = ?", email).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return mapModelToDTO(&amp;user), nil</span>
}

func (r *repository) GetByUsername(
        ctx context.Context,
        username string,
) (*dto.UserRead, error) <span class="cov0" title="0">{
        var user User
        if err := r.db.WithContext(
                ctx,
        ).Where("username = ?", username).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return mapModelToDTO(&amp;user), nil</span>
}

func (r *repository) List(
        ctx context.Context,
        page, pageSize int,
) ([]*dto.UserRead, error) <span class="cov0" title="0">{
        var users []User
        if err := r.db.WithContext(
                ctx,
        ).Offset((page - 1) * pageSize).Limit(pageSize).Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make([]*dto.UserRead, 0, len(users))
        for _, user := range users </span><span class="cov0" title="0">{
                result = append(result, mapModelToDTO(&amp;user))
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *repository) Update(
        ctx context.Context,
        id uuid.UUID,
        uu *dto.UserUpdate,
) error <span class="cov0" title="0">{
        updates := make(map[string]interface{})

        // Only include non-nil fields in the update
        if uu.Username != nil </span><span class="cov0" title="0">{
                updates["username"] = *uu.Username
        }</span>
        <span class="cov0" title="0">if uu.Email != nil </span><span class="cov0" title="0">{
                updates["email"] = *uu.Email
        }</span>
        <span class="cov0" title="0">if uu.Names != nil </span><span class="cov0" title="0">{
                updates["names"] = *uu.Names
        }</span>
        <span class="cov0" title="0">if uu.Password != nil </span><span class="cov0" title="0">{
                updates["password"] = *uu.Password
        }</span>

        // If no fields to update, return early
        <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Update only the specified fields
        <span class="cov0" title="0">return r.db.WithContext(ctx).Model(&amp;User{}).
                Where("id = ?", id).
                Updates(updates).Error</span>
}

func (r *repository) Create(
        ctx context.Context,
        create *dto.UserCreate,
) error <span class="cov0" title="0">{
        user := &amp;User{
                ID:       create.ID,
                Username: create.Username,
                Email:    create.Email,
                Password: create.Password,
                Names:    create.Names,
        }
        return r.db.WithContext(
                ctx,
        ).Create(user).Error
}</span>

func (r *repository) Get(
        ctx context.Context,
        id uuid.UUID,
) (*dto.UserRead, error) <span class="cov0" title="0">{
        var user User
        if err := r.db.WithContext(
                ctx,
        ).First(&amp;user, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return mapModelToDTO(&amp;user), nil</span>
}

func (r *repository) Delete(
        ctx context.Context,
        id uuid.UUID,
) error <span class="cov0" title="0">{
        return r.db.WithContext(
                ctx,
        ).Delete(&amp;User{}, "id = ?", id).Error
}</span>

func (r *repository) Exists(
        ctx context.Context,
        id uuid.UUID,
) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.WithContext(
                ctx,
        ).Model(&amp;User{}).Where("id = ?", id).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (r *repository) ExistsByEmail(
        ctx context.Context,
        email string,
) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.WithContext(
                ctx,
        ).Model(&amp;User{}).Where("email = ?", email).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (r *repository) ExistsByUsername(
        ctx context.Context,
        username string,
) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.WithContext(
                ctx,
        ).Model(&amp;User{}).Where("username = ?", username).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func mapModelToDTO(user *User) *dto.UserRead <span class="cov0" title="0">{
        return &amp;dto.UserRead{
                ID:             user.ID,
                Username:       user.Username,
                Email:          user.Email,
                HashedPassword: user.Password,
                Names:          user.Names,
                CreatedAt:      user.CreatedAt,
                UpdatedAt:      user.UpdatedAt,
        }
}</span>

var _ user.Repository = (*repository)(nil)
</pre>

		<pre class="file" id="file20" style="display: none">package app

import (
        "log/slog"

        "github.com/amirasaad/fintech/pkg/service/checkout"
        "github.com/amirasaad/fintech/pkg/service/exchange"

        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/amirasaad/fintech/pkg/registry"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/amirasaad/fintech/pkg/service/account"
        "github.com/amirasaad/fintech/pkg/service/auth"
        currencyScv "github.com/amirasaad/fintech/pkg/service/currency"
        "github.com/amirasaad/fintech/pkg/service/user"
)

// Deps contains all the dependencies needed by the SetupBus function
type Deps struct {
        // Registry providers
        RegistryProvider     registry.Provider // Main registry provider
        CurrencyRegistry     registry.Provider // For currency service
        CheckoutRegistry     registry.Provider // For checkout service
        ExchangeRateRegistry registry.Provider // For exchange rate service

        // Other dependencies
        ExchangeRateProvider provider.ExchangeRate
        PaymentProvider      provider.Payment
        Uow                  repository.UnitOfWork
        EventBus             eventbus.Bus
        Logger               *slog.Logger
}

type App struct {
        Deps                *Deps
        Config              *config.App
        AuthService         *auth.Service
        UserService         *user.Service
        AccountService      *account.Service
        CurrencyService     *currencyScv.Service
        CheckoutService     *checkout.Service
        ExchangeRateService *exchange.Service
}

func New(deps *Deps, cfg *config.App) *App <span class="cov0" title="0">{
        app := &amp;App{
                Deps:   deps,
                Config: cfg,
        }
        app.setupEventBus()

        authMap := map[string]func() *auth.Service{
                "jwt": func() *auth.Service </span><span class="cov0" title="0">{
                        return auth.NewWithJWT(deps.Uow, cfg.Auth.Jwt, deps.Logger)
                }</span>,
        }
        <span class="cov0" title="0">if authFactory, ok := authMap[cfg.Auth.Strategy]; ok </span><span class="cov0" title="0">{
                app.AuthService = authFactory()
        }</span> else<span class="cov0" title="0"> {
                app.AuthService = auth.NewWithBasic(deps.Uow, deps.Logger)
        }</span>
        <span class="cov0" title="0">app.UserService = user.New(
                deps.Uow,
                deps.Logger,
        )
        app.AccountService = account.New(
                deps.EventBus,
                deps.Uow,
                deps.Logger,
        )

        // Initialize services with their respective registry providers
        app.CurrencyService = currencyScv.New(
                deps.CurrencyRegistry,
                deps.Logger,
        )

        app.CheckoutService = checkout.New(
                deps.CheckoutRegistry,
        )

        app.ExchangeRateService = exchange.New(
                deps.ExchangeRateRegistry,
                deps.ExchangeRateProvider,
                deps.Logger,
        )

        return app</span>
}
</pre>

		<pre class="file" id="file21" style="display: none">// Package app provides functionality for setting up and configuring the event Bus
// with all necessary event handlers for the application.
package app

import (
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/handler/account/deposit"
        "github.com/amirasaad/fintech/pkg/handler/account/transfer"
        "github.com/amirasaad/fintech/pkg/handler/account/withdraw"
        "github.com/amirasaad/fintech/pkg/handler/conversion"
        "github.com/amirasaad/fintech/pkg/handler/fees"
        "github.com/amirasaad/fintech/pkg/handler/payment"
        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/amirasaad/fintech/pkg/repository"
)

// setupEventBus registers all event handlers with the provided event Bus.
func (a *App) setupEventBus() <span class="cov0" title="0">{

        bus := a.Deps.EventBus
        uow := a.Deps.Uow
        logger := a.Deps.Logger

        a.setupConversionHandlers(
                bus,
                uow,
                a.Deps.ExchangeRateProvider,
                logger,
        )

        a.setupDepositHandlers(bus, uow, logger)
        a.setupWithdrawHandlers(bus, uow, logger)
        a.setupPaymentHandlers(bus, uow, logger)
        a.setupTransferHandlers(bus, uow, logger)
        a.setupFeesHandlers(bus, uow, logger)
}</span>

func (a *App) setupWithdrawHandlers(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) <span class="cov0" title="0">{
        bus.Register(
                events.EventTypeWithdrawRequested,
                withdraw.HandleRequested(
                        bus,
                        uow,
                        logger,
                ),
        )
        bus.Register(
                events.EventTypeWithdrawCurrencyConverted,
                withdraw.HandleCurrencyConverted(
                        bus,
                        uow,
                        logger,
                ),
        )
}</span>

func (a *App) setupPaymentHandlers(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) <span class="cov0" title="0">{
        bus.Register(
                events.EventTypePaymentInitiated,
                payment.HandleInitiated(
                        bus,
                        a.Deps.PaymentProvider,
                        logger,
                ),
        )
        bus.Register(
                events.EventTypePaymentProcessed,
                payment.HandleProcessed(
                        uow,
                        logger,
                ),
        )
        bus.Register(
                events.EventTypePaymentCompleted,
                payment.HandleCompleted(
                        bus,
                        uow,
                        logger,
                ),
        )

}</span>

func (a *App) setupFeesHandlers(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) <span class="cov0" title="0">{
        bus.Register(
                events.EventTypeFeesCalculated,
                fees.HandleCalculated(
                        uow,
                        logger,
                ),
        )
}</span>

func (a *App) setupTransferHandlers(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) <span class="cov0" title="0">{
        bus.Register(
                events.EventTypeTransferRequested,
                transfer.HandleRequested(
                        bus,
                        uow,
                        logger,
                ),
        )
        bus.Register(
                events.EventTypeTransferCurrencyConverted,
                transfer.HandleCurrencyConverted(
                        bus,
                        uow,
                        logger,
                ),
        )
        bus.Register(
                events.EventTypeTransferCompleted,
                transfer.HandleCompleted(
                        bus,
                        uow,
                        logger,
                ),
        )
}</span>

func (a *App) setupDepositHandlers(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) <span class="cov0" title="0">{
        bus.Register(
                events.EventTypeDepositRequested,
                deposit.HandleRequested(
                        bus,
                        uow,
                        logger,
                ),
        )
        bus.Register(
                events.EventTypeDepositCurrencyConverted,
                deposit.HandleCurrencyConverted(
                        bus,
                        uow,
                        logger,
                ),
        )
}</span>

func (a *App) setupConversionHandlers(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        exchangeRateProvider provider.ExchangeRate,
        logger *slog.Logger,
) <span class="cov0" title="0">{
        // 1️⃣ GENERIC CONVERSION HANDLER
        // This handler processes all conversion requests and delegates to the appropriate flow
        conversionFactories := map[string]conversion.EventFactory{
                "deposit":  &amp;conversion.DepositEventFactory{},
                "withdraw": &amp;conversion.WithdrawEventFactory{},
                "transfer": &amp;conversion.TransferEventFactory{},
        }

        bus.Register(
                events.EventTypeCurrencyConversionRequested,
                conversion.HandleRequested(
                        bus,
                        a.Deps.ExchangeRateRegistry, // Use the exchange rate registry provider
                        exchangeRateProvider,
                        logger,
                        conversionFactories,
                ),
        )
}</span>
</pre>

		<pre class="file" id="file22" style="display: none">package config

import (
        "log/slog"

        "github.com/joho/godotenv"
        "github.com/kelseyhightower/envconfig"
)

func Load(envFilePath ...string) (*App, error) <span class="cov0" title="0">{
        logger := slog.Default()
        logger.Info("Loading environment variables")

        // If no specific paths provided, try default .env
        if len(envFilePath) == 0 </span><span class="cov0" title="0">{
                logger.Debug("No environment file specified, trying default .env")
                if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("No .env file found in current directory")
                }</span>
                <span class="cov0" title="0">return loadFromEnv()</span>
        }

        // Try each provided path until we find a valid one
        <span class="cov0" title="0">for _, path := range envFilePath </span><span class="cov0" title="0">{
                logger.Debug("Looking for environment file", "path", path)
                foundPath, err := FindEnvTest(path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Environment file not found", "path", path, "error", err)
                        continue</span>
                }

                <span class="cov0" title="0">logger.Info("Loading environment from file", "path", foundPath)
                if err := godotenv.Load(foundPath); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to load environment file", "path", foundPath, "error", err)
                        continue</span>
                }

                // Successfully loaded a file, proceed with config loading
                <span class="cov0" title="0">return loadFromEnv()</span>
        }

        // No valid environment files found, try default .env as fallback
        <span class="cov0" title="0">logger.Info("No valid environment files found, using default .env")
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                logger.Warn("No .env file found in current directory")
        }</span>
        <span class="cov0" title="0">return loadFromEnv()</span>
}

func loadFromEnv() (*App, error) <span class="cov0" title="0">{
        var cfg App
        err := envconfig.Process("", &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set default values if not set
        <span class="cov0" title="0">if cfg.Env == "" </span><span class="cov0" title="0">{
                cfg.Env = "development"
        }</span>

        <span class="cov0" title="0">logger := slog.Default()
        logger.Info("Environment variables loaded from .env file")
        logger.Info("App config loaded",
                "env", cfg.Env,
                "rate_limit_max_requests", cfg.RateLimit.MaxRequests,
                "rate_limit_window", cfg.RateLimit.Window,
                "db", maskValue(cfg.DB.Url),
                "auth_strategy", cfg.Auth.Strategy,
                "auth_jwt_expiry", cfg.Auth.Jwt.Expiry,
                "exchange_cache_ttl", cfg.ExchangeRateCache.TTL,
                "exchange_api_url", cfg.ExchangeRateAPIProviders.ExchangeRateApi.ApiUrl,
                "exchange_api_key", maskValue(cfg.ExchangeRateAPIProviders.ExchangeRateApi.ApiKey),
        )
        return &amp;cfg, nil</span>
}

func maskValue(key string) string <span class="cov0" title="0">{
        if len(key) &lt;= 6 </span><span class="cov0" title="0">{
                return "****"
        }</span>
        <span class="cov0" title="0">return key[:2] + "****" + key[len(key)-4:]</span>
}
</pre>

		<pre class="file" id="file23" style="display: none">package config

import (
        "os"
        "path/filepath"
)

// FindEnvTest searches for the nearest file
// If filename is empty, it searches for .env
func FindEnvTest(filename string) (string, error) <span class="cov0" title="0">{
        if filename == "" </span><span class="cov0" title="0">{
                filename = ".env"
        }</span>
        <span class="cov0" title="0">startDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">curr := startDir
        for </span><span class="cov0" title="0">{
                candidate := filepath.Join(curr, filename)
                if _, err = os.Stat(candidate); err == nil </span><span class="cov0" title="0">{
                        return candidate, nil
                }</span>
                <span class="cov0" title="0">parent := filepath.Dir(curr)
                if parent == curr </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">curr = parent</span>
        }
        <span class="cov0" title="0">return "", os.ErrNotExist</span>
}
</pre>

		<pre class="file" id="file24" style="display: none">// Package currency provides functionality for working with currency codes and metadata.
// It includes validation, formatting, and conversion utilities for ISO 4217 currency codes.
//
// Deprecated: This package is deprecated and will be removed in a future release.
// Please use the money package instead: github.com/amirasaad/fintech/pkg/money
package currency

import (
        "context"
        "errors"
        "fmt"
        "maps"
        "regexp"
        "strconv"
        "time"

        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/registry"
)

// Common errors
var (
        // Deprecated: Use money.ErrInvalidCurrency instead
        ErrInvalidCode     = money.ErrInvalidCurrency
        ErrUnsupported     = errors.New("unsupported currency")
        ErrInvalidDecimals = errors.New("invalid decimals: must be between 0 and 8")
        ErrInvalidSymbol   = errors.New(
                "invalid symbol: must not be empty and max 10 characters")
        ErrCurrencyNotFound = errors.New("currency not found")
        ErrCurrencyExists   = errors.New("currency already exists")
)

const (
        // DefaultCode is the fallback currency code (USD)
        DefaultCode = "USD"
        // DefaultDecimals is the default number of decimal places for currencies
        DefaultDecimals = 2
        // MaxDecimals is the maximum number of decimal places allowed
        MaxDecimals = 18
        // MaxSymbolLength is the maximum length for currency symbols
        MaxSymbolLength = 10

        // Default is the default currency code (USD)
        // Deprecated: Use money.USD from the money package instead
        Default = USD
)

// Meta holds currency-specific metadata
// Deprecated:
type Meta struct {
        Code     string            `json:"code"`
        Name     string            `json:"name"`
        Symbol   string            `json:"symbol"`
        Decimals int               `json:"decimals"`
        Country  string            `json:"country,omitempty"`
        Region   string            `json:"region,omitempty"`
        Active   bool              `json:"active"`
        Metadata map[string]string `json:"metadata,omitempty"`
        Created  time.Time         `json:"created"`
        Updated  time.Time         `json:"updated"`
}

// Entity implements the registry.Entity interface
// Deprecated
type Entity struct {
        *registry.BaseEntity
        meta Meta
}

// NewEntity creates a new currency entity
func NewEntity(meta Meta) *Entity <span class="cov8" title="1">{
        now := time.Now()
        meta.Created = now
        meta.Updated = now

        return &amp;Entity{
                BaseEntity: registry.NewBaseEntity(meta.Code, meta.Name),
                meta:       meta,
        }
}</span>

// Code returns the currency code
func (c *Entity) Code() string <span class="cov0" title="0">{
        return c.meta.Code
}</span>

// Name returns the currency name
func (c *Entity) Name() string <span class="cov8" title="1">{
        return c.meta.Name
}</span>

// Active returns whether the currency is active
func (c *Entity) Active() bool <span class="cov8" title="1">{
        return c.meta.Active
}</span>

// Metadata returns currency metadata
func (c *Entity) Metadata() map[string]string <span class="cov8" title="1">{
        metadata := make(map[string]string)

        // Only include core fields in the metadata
        metadata["code"] = c.meta.Code
        metadata["symbol"] = c.meta.Symbol
        metadata["decimals"] = strconv.Itoa(c.meta.Decimals)
        metadata["country"] = c.meta.Country
        metadata["region"] = c.meta.Region
        metadata["active"] = strconv.FormatBool(c.meta.Active)
        metadata["created"] = c.meta.Created.Format(time.RFC3339)
        metadata["updated"] = c.meta.Updated.Format(time.RFC3339)

        // Add custom metadata
        maps.Copy(metadata, c.meta.Metadata)

        return metadata
}</span>

// CreatedAt returns the creation timestamp
func (c *Entity) CreatedAt() time.Time <span class="cov8" title="1">{
        return c.meta.Created
}</span>

// UpdatedAt returns the last update timestamp
func (c *Entity) UpdatedAt() time.Time <span class="cov8" title="1">{
        return c.meta.Updated
}</span>

// Meta returns the currency metadata
func (c *Entity) Meta() Meta <span class="cov8" title="1">{
        return c.meta
}</span>

// Validator implements registry.Validator for currency entities
type Validator struct{}

// NewCurrencyValidator creates a new currency validator
func NewCurrencyValidator() *Validator <span class="cov8" title="1">{
        return &amp;Validator{}
}</span>

// Validate validates a currency entity
func (cv *Validator) Validate(ctx context.Context, entity registry.Entity) error <span class="cov8" title="1">{
        // Try to convert to Entity first
        if currencyEntity, ok := entity.(*Entity); ok </span><span class="cov8" title="1">{
                return validateMeta(currencyEntity.Meta())
        }</span>

        // If it's not a Entity, try to validate using metadata
        // This handles cases where the entity might be a BaseEntity or other type
        <span class="cov0" title="0">metadata := entity.Metadata()
        if len(metadata) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid entity type: expected *Entity or entity with metadata")
        }</span>

        // Validate required metadata fields
        <span class="cov0" title="0">requiredFields := []string{"code", "symbol", "decimals"}
        for _, field := range requiredFields </span><span class="cov0" title="0">{
                if value, exists := metadata[field]; !exists || value == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("required metadata field missing: %s", field)
                }</span>
        }

        // Validate currency code format
        <span class="cov0" title="0">if code, exists := metadata["code"]; exists </span><span class="cov0" title="0">{
                if !isValidCurrencyCode(code) </span><span class="cov0" title="0">{
                        return ErrInvalidCode
                }</span>
        }

        // Validate decimals
        <span class="cov0" title="0">if decimalsStr, exists := metadata["decimals"]; exists </span><span class="cov0" title="0">{
                if decimals, err := strconv.Atoi(decimalsStr); err != nil </span><span class="cov0" title="0">{
                        return ErrInvalidDecimals
                }</span> else<span class="cov0" title="0"> if decimals &lt; 0 || decimals &gt; MaxDecimals </span><span class="cov0" title="0">{
                        return ErrInvalidDecimals
                }</span>
        }

        // Validate symbol
        <span class="cov0" title="0">if symbol, exists := metadata["symbol"]; exists </span><span class="cov0" title="0">{
                if symbol == "" || len(symbol) &gt; MaxSymbolLength </span><span class="cov0" title="0">{
                        return ErrInvalidSymbol
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateMetadata validates currency metadata
func (cv *Validator) ValidateMetadata(ctx context.Context, metadata map[string]string) error <span class="cov8" title="1">{
        // Validate required metadata fields
        requiredFields := []string{"code", "symbol", "decimals"}
        for _, field := range requiredFields </span><span class="cov8" title="1">{
                if value, exists := metadata[field]; !exists || value == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("required metadata field missing: %s", field)
                }</span>
        }

        // Validate currency code format
        <span class="cov8" title="1">if code, exists := metadata["code"]; exists </span><span class="cov8" title="1">{
                if !isValidCurrencyCode(code) </span><span class="cov8" title="1">{
                        return ErrInvalidCode
                }</span>
        }

        // Validate decimals
        <span class="cov8" title="1">if decimalsStr, exists := metadata["decimals"]; exists </span><span class="cov8" title="1">{
                if decimals, err := strconv.Atoi(decimalsStr); err != nil </span><span class="cov8" title="1">{
                        return ErrInvalidDecimals
                }</span> else<span class="cov8" title="1"> if decimals &lt; 0 || decimals &gt; MaxDecimals </span><span class="cov0" title="0">{
                        return ErrInvalidDecimals
                }</span>
        }

        // Validate symbol
        <span class="cov8" title="1">if symbol, exists := metadata["symbol"]; exists </span><span class="cov8" title="1">{
                if symbol == "" || len(symbol) &gt; MaxSymbolLength </span><span class="cov0" title="0">{
                        return ErrInvalidSymbol
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateMeta validates currency metadata
func validateMeta(meta Meta) error <span class="cov8" title="1">{
        // Validate currency code format
        if !isValidCurrencyCode(meta.Code) </span><span class="cov8" title="1">{
                return ErrInvalidCode
        }</span>

        // Validate decimals
        <span class="cov8" title="1">if meta.Decimals &lt; 0 || meta.Decimals &gt; MaxDecimals </span><span class="cov8" title="1">{
                return ErrInvalidDecimals
        }</span>

        // Validate symbol
        <span class="cov8" title="1">if meta.Symbol == "" || len(meta.Symbol) &gt; MaxSymbolLength </span><span class="cov8" title="1">{
                return ErrInvalidSymbol
        }</span>

        // Validate name
        <span class="cov8" title="1">if meta.Name == "" </span><span class="cov8" title="1">{
                return errors.New("currency name cannot be empty")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsValidFormat returns true if the code
// is a well-formed ISO 4217 currency code (3 uppercase letters).
func IsValidFormat(code string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(`^[A-Z]{3}$`)
        return re.MatchString(code)
}</span>

// isValidCurrencyCode checks if a currency code is valid (3 uppercase letters)
func isValidCurrencyCode(code string) bool <span class="cov8" title="1">{
        return IsValidFormat(code)
}</span>

// Registry provides currency-specific operations using the registry system
type Registry struct {
        registry registry.Provider
        ctx      context.Context
}

// New creates a new currency registry with default currencies
// If redisURL is provided, it will use Redis for caching
// The function accepts optional parameters in this order: redisURL, keyPrefix
func New(ctx context.Context, params ...string) (*Registry, error) <span class="cov8" title="1">{
        var redisURL, keyPrefix string

        // Parse parameters
        switch len(params) </span>{
        case 0:<span class="cov8" title="1"></span>
                // No parameters
        case 1:<span class="cov0" title="0">
                // Only redisURL provided
                redisURL = params[0]</span>
        default:<span class="cov0" title="0">
                // Both redisURL and keyPrefix provided
                redisURL = params[0]
                keyPrefix = params[1]</span>
        }

        // Create registry with currency-specific configuration
        <span class="cov8" title="1">config := registry.Config{
                Name:             "currency-registry",
                MaxEntities:      1000,
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
        }

        var reg registry.Provider
        var err error

        // Use Redis if URL is provided
        if redisURL != "" </span><span class="cov0" title="0">{
                // Create registry builder with Redis settings
                builder := registry.NewBuilder().
                        WithName(config.Name).
                        WithMaxEntities(config.MaxEntities).
                        WithRedis(redisURL).
                        WithCache(100, 10*time.Minute) // Cache size and TTL

                // Set custom key prefix if provided
                if keyPrefix != "" </span><span class="cov0" title="0">{
                        builder = builder.WithKeyPrefix(keyPrefix)
                }</span>

                // Get the config with Redis settings
                <span class="cov0" title="0">config = builder.Build()

                // Create registry with Redis cache
                factory := registry.NewFactory()
                reg, err = factory.Create(ctx, config)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create Redis-backed registry: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // Fall back to in-memory cache
                enhanced := registry.NewEnhanced(config).
                        WithValidator(NewCurrencyValidator()).
                        WithCache(registry.NewMemoryCache(10 * time.Minute))
                reg = enhanced
        }</span>

        <span class="cov8" title="1">cr := &amp;Registry{
                registry: reg,
                ctx:      ctx,
        }

        // Register default currencies
        if err := cr.registerDefaults(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to register default currencies: %w", err)
        }</span>

        <span class="cov8" title="1">return cr, nil</span>
}

// NewRegistryWithPersistence creates a currency registry with persistence
// If redisURL is provided, it will use Redis for caching
func NewRegistryWithPersistence(
        ctx context.Context, persistencePath string, redisURL ...string,
) (*Registry, error) <span class="cov0" title="0">{
        config := registry.Config{
                Name:              "currency-registry",
                MaxEntities:       1000,
                EnableEvents:      true,
                EnableValidation:  true,
                CacheSize:         100,
                CacheTTL:          10 * time.Minute,
                EnablePersistence: true,
                PersistencePath:   persistencePath,
                AutoSaveInterval:  time.Minute,
                RedisKeyPrefix:    "currency",
        }

        var reg registry.Provider
        var err error

        // Use Redis if URL is provided
        if len(redisURL) &gt; 0 &amp;&amp; redisURL[0] != "" </span><span class="cov0" title="0">{
                // Configure Redis settings
                builder := registry.NewBuilder().
                        WithName(config.Name).
                        WithMaxEntities(config.MaxEntities).
                        WithRedis(redisURL[0]).
                        WithCache(100, 10*time.Minute).               // Cache size and TTL
                        WithPersistence(persistencePath, time.Minute) // Auto-save interval

                // Get the config with Redis settings
                config = builder.Build()

                // Create registry with Redis cache and persistence
                factory := registry.NewFactory()
                reg, err = factory.CreateWithPersistence(
                        ctx,
                        config,
                        registry.NewFilePersistence(persistencePath),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(
                                "failed to create Redis-backed registry with persistence: %w",
                                err,
                        )
                }</span>
        } else<span class="cov0" title="0"> {
                // Fall back to in-memory cache with file persistence
                enhanced := registry.NewEnhanced(config)
                enhanced.WithValidator(NewCurrencyValidator())
                enhanced.WithCache(registry.NewMemoryCache(10 * time.Minute))

                // Add persistence
                persistence := registry.NewFilePersistence(persistencePath)
                enhanced.WithPersistence(persistence)
                reg = enhanced

                // Load existing entities
                if entities, err := persistence.Load(ctx); err == nil </span><span class="cov0" title="0">{
                        for _, entity := range entities </span><span class="cov0" title="0">{
                                if err := reg.Register(ctx, entity); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to load entity %s: %w", entity.ID(), err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">cr := &amp;Registry{
                registry: reg,
                ctx:      ctx,
        }

        // Only register defaults if no entities were loaded
        if count, _ := reg.Count(ctx); count == 0 </span><span class="cov0" title="0">{
                if err := cr.registerDefaults(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to register default currencies: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return cr, nil</span>
}

// registerDefaults registers the default set of currencies
func (cr *Registry) registerDefaults() error <span class="cov8" title="1">{
        defaultCurrencies := []Meta{
                {Code: "USD", Name: "US Dollar", Symbol: "$", Decimals: 2,
                        Country: "United States", Region: "North America", Active: true},
                {Code: "EUR", Name: "Euro", Symbol: "€", Decimals: 2,
                        Country: "European Union", Region: "Europe", Active: true},
                {Code: "GBP", Name: "British Pound", Symbol: "£", Decimals: 2,
                        Country: "United Kingdom", Region: "Europe", Active: true},
                {Code: "JPY", Name: "Japanese Yen", Symbol: "¥", Decimals: 0,
                        Country: "Japan", Region: "Asia", Active: true},
                {Code: "CAD", Name: "Canadian Dollar", Symbol: "C$", Decimals: 2,
                        Country: "Canada", Region: "North America", Active: true},
                {Code: "AUD", Name: "Australian Dollar", Symbol: "A$", Decimals: 2,
                        Country: "Australia", Region: "Oceania", Active: true},
                {Code: "CHF", Name: "Swiss Franc", Symbol: "CHF", Decimals: 2,
                        Country: "Switzerland", Region: "Europe", Active: true},
                {Code: "CNY", Name: "Chinese Yuan", Symbol: "¥", Decimals: 2,
                        Country: "China", Region: "Asia", Active: true},
                {Code: "INR", Name: "Indian Rupee", Symbol: "₹", Decimals: 2,
                        Country: "India", Region: "Asia", Active: true},
                {Code: "BRL", Name: "Brazilian Real", Symbol: "R$", Decimals: 2,
                        Country: "Brazil", Region: "South America", Active: true},
                {Code: "KWD", Name: "Kuwaiti Dinar", Symbol: "د.ك", Decimals: 3,
                        Country: "Kuwait", Region: "Middle East", Active: true},
                {Code: "EGP", Name: "Egyptian Pound", Symbol: "£", Decimals: 2,
                        Country: "Egypt", Region: "Africa", Active: true},
        }

        for _, meta := range defaultCurrencies </span><span class="cov8" title="1">{
                if err := cr.Register(meta); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to register %s: %w", meta.Code, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Register adds or updates a currency in the registry
func (cr *Registry) Register(meta Meta) error <span class="cov8" title="1">{
        // Validate currency metadata
        if err := validateMeta(meta); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        // Create currency entity
        <span class="cov8" title="1">entity := NewEntity(meta)

        // Register with the registry
        if err := cr.registry.Register(cr.ctx, entity); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register currency: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Get returns currency metadata for the given code
func (cr *Registry) Get(code string) (Meta, error) <span class="cov8" title="1">{
        entity, err := cr.registry.Get(cr.ctx, code)
        if err != nil </span><span class="cov8" title="1">{
                return Meta{}, fmt.Errorf("currency not found: %w", err)
        }</span>

        // Convert entity back to currency metadata
        <span class="cov8" title="1">currencyEntity, ok := entity.(*Entity)
        if !ok </span><span class="cov0" title="0">{
                // Fallback: try to convert from BaseEntity
                metadata := entity.Metadata()
                decimals, _ := strconv.Atoi(metadata["decimals"])
                active, _ := strconv.ParseBool(metadata["active"])

                return Meta{
                        Code:     metadata["code"],
                        Name:     entity.Name(),
                        Symbol:   metadata["symbol"],
                        Decimals: decimals,
                        Country:  metadata["country"],
                        Region:   metadata["region"],
                        Active:   active,
                }, nil
        }</span>

        <span class="cov8" title="1">return currencyEntity.Meta(), nil</span>
}

// IsSupported checks if a currency code is registered and active
func (cr *Registry) IsSupported(code string) bool <span class="cov8" title="1">{
        if !cr.registry.IsRegistered(cr.ctx, code) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">entity, err := cr.registry.Get(cr.ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if ce, ok := entity.(*Entity); ok </span><span class="cov8" title="1">{
                return ce.Active()
        }</span> else<span class="cov8" title="1"> {
                return entity.Active()
        }</span>
}

// ListSupported returns a list of all supported currency codes
func (cr *Registry) ListSupported() ([]string, error) <span class="cov8" title="1">{
        entities, err := cr.registry.ListActive(cr.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list currencies: %w", err)
        }</span>

        <span class="cov8" title="1">codes := make([]string, len(entities))
        for i, entity := range entities </span><span class="cov8" title="1">{
                if ce, ok := entity.(*Entity); ok </span><span class="cov0" title="0">{
                        codes[i] = ce.Code()
                }</span> else<span class="cov8" title="1"> {
                        codes[i] = entity.ID()
                }</span>
        }

        <span class="cov8" title="1">return codes, nil</span>
}

// ListAll returns all registered currencies (active and inactive)
func (cr *Registry) ListAll() ([]Meta, error) <span class="cov8" title="1">{
        entities, err := cr.registry.List(cr.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list currencies: %w", err)
        }</span>

        <span class="cov8" title="1">currencies := make([]Meta, len(entities))
        for i, entity := range entities </span><span class="cov8" title="1">{
                if currencyEntity, ok := entity.(*Entity); ok </span><span class="cov0" title="0">{
                        currencies[i] = currencyEntity.Meta()
                }</span> else<span class="cov8" title="1"> {
                        // Fallback conversion
                        metadata := entity.Metadata()
                        decimals, _ := strconv.Atoi(metadata["decimals"])
                        active, _ := strconv.ParseBool(metadata["active"])

                        currencies[i] = Meta{
                                Code:     metadata["code"],
                                Name:     entity.Name(),
                                Symbol:   metadata["symbol"],
                                Decimals: decimals,
                                Country:  metadata["country"],
                                Region:   metadata["region"],
                                Active:   active,
                        }
                }</span>
        }

        <span class="cov8" title="1">return currencies, nil</span>
}

// Unregister removes a currency from the registry
func (cr *Registry) Unregister(code string) error <span class="cov8" title="1">{
        if err := cr.registry.Unregister(cr.ctx, code); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unregister currency: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Activate activates a currency
func (cr *Registry) Activate(code string) error <span class="cov8" title="1">{
        if err := cr.registry.Activate(cr.ctx, code); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to activate currency: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Deactivate deactivates a currency
func (cr *Registry) Deactivate(code string) error <span class="cov8" title="1">{
        if err := cr.registry.Deactivate(cr.ctx, code); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deactivate currency: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Count returns the total number of registered currencies
func (cr *Registry) Count() (int, error) <span class="cov8" title="1">{
        return cr.registry.Count(cr.ctx)
}</span>

// CountActive returns the number of active currencies
func (cr *Registry) CountActive() (int, error) <span class="cov8" title="1">{
        return cr.registry.CountActive(cr.ctx)
}</span>

// Search searches for currencies by name
func (cr *Registry) Search(query string) ([]Meta, error) <span class="cov8" title="1">{
        entities, err := cr.registry.Search(cr.ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search currencies: %w", err)
        }</span>

        <span class="cov8" title="1">var currencies []Meta
        for _, entity := range entities </span><span class="cov8" title="1">{
                if currencyEntity, ok := entity.(*Entity); ok </span><span class="cov0" title="0">{
                        currencies = append(currencies, currencyEntity.Meta())
                }</span> else<span class="cov8" title="1"> {
                        // Fallback for non-Entity types
                        metadata := entity.Metadata()
                        decimals, _ := strconv.Atoi(metadata["decimals"])
                        active, _ := strconv.ParseBool(metadata["active"])

                        currencies = append(currencies, Meta{
                                Code:     metadata["code"],
                                Name:     entity.Name(),
                                Symbol:   metadata["symbol"],
                                Decimals: decimals,
                                Country:  metadata["country"],
                                Region:   metadata["region"],
                                Active:   active,
                        })
                }</span>
        }

        <span class="cov8" title="1">return currencies, nil</span>
}

// SearchByRegion searches for currencies by region
func (cr *Registry) SearchByRegion(region string) ([]Meta, error) <span class="cov8" title="1">{
        entities, err := cr.registry.SearchByMetadata(cr.ctx, map[string]string{"region": region})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search currencies by region: %w", err)
        }</span>

        <span class="cov8" title="1">var currencies []Meta
        for _, entity := range entities </span><span class="cov8" title="1">{
                if currencyEntity, ok := entity.(*Entity); ok </span><span class="cov0" title="0">{
                        currencies = append(currencies, currencyEntity.Meta())
                }</span> else<span class="cov8" title="1"> {
                        // Fallback for non-Entity types
                        metadata := entity.Metadata()
                        decimals, _ := strconv.Atoi(metadata["decimals"])
                        active, _ := strconv.ParseBool(metadata["active"])

                        currencies = append(currencies, Meta{
                                Code:     metadata["code"],
                                Name:     entity.Name(),
                                Symbol:   metadata["symbol"],
                                Decimals: decimals,
                                Country:  metadata["country"],
                                Region:   metadata["region"],
                                Active:   active,
                        })
                }</span>
        }

        <span class="cov8" title="1">return currencies, nil</span>
}

// GetRegistry returns the underlying registry provider
func (cr *Registry) GetRegistry() registry.Provider <span class="cov0" title="0">{
        return cr.registry
}</span>

func (cr *Registry) SetRegistry(reg registry.Provider) <span class="cov0" title="0">{
        cr.registry = reg
}</span>

// Global currency registry instance
var globalCurrencyRegistry *Registry

// GetGlobalRegistry returns the global currency registry instance.
// Make sure to call InitializeGlobalRegistry first to initialize the registry.
func GetGlobalRegistry() *Registry <span class="cov0" title="0">{
        if globalCurrencyRegistry == nil </span><span class="cov0" title="0">{
                // Fallback to in-memory cache if not initialized
                var err error
                globalCurrencyRegistry, err = New(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        // This should not happen as NewRegistry only fails with invalid Redis URL
                        panic(fmt.Sprintf("failed to initialize fallback currency registry: %v", err))</span>
                }
        }
        <span class="cov0" title="0">return globalCurrencyRegistry</span>
}

// InitializeGlobalRegistry initializes the global currency registry
// with optional Redis configuration.
// If redisURL is provided, it will be used to configure Redis caching.
// If keyPrefix is provided, it will be used as the Redis key prefix.
// If redisURL is empty, an in-memory cache will be used.
//
// This function should be called during application startup.
func InitializeGlobalRegistry(ctx context.Context, redisURL ...string) error <span class="cov0" title="0">{
        var err error
        if len(redisURL) &gt; 0 &amp;&amp; redisURL[0] != "" </span><span class="cov0" title="0">{
                // Initialize with Redis cache and optional key prefix
                if len(redisURL) &gt; 1 </span><span class="cov0" title="0">{
                        globalCurrencyRegistry, err = New(ctx, redisURL[0], redisURL[1])
                }</span> else<span class="cov0" title="0"> {
                        globalCurrencyRegistry, err = New(ctx, redisURL[0])
                }</span>
        } else<span class="cov0" title="0"> {
                // Initialize with in-memory cache
                globalCurrencyRegistry, err = New(ctx)
        }</span>
        <span class="cov0" title="0">return err</span>
}

// Initialize global registry with in-memory cache as fallback
func init() <span class="cov8" title="1">{
        // Initialize with background context and in-memory cache by default
        // This ensures the global registry is always available, even if not explicitly initialized
        var err error
        globalCurrencyRegistry, err = New(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to initialize global currency registry: %v", err))</span>
        }
}

// Register Global convenience functions with error handling
func Register(meta Meta) error <span class="cov8" title="1">{
        return globalCurrencyRegistry.Register(meta)
}</span>

// Get returns currency metadata for the given code
var Get = getCurrencyInternal

func getCurrencyInternal(code string) (Meta, error) <span class="cov8" title="1">{
        return globalCurrencyRegistry.Get(code)
}</span>

func IsSupported(code string) bool <span class="cov8" title="1">{
        return globalCurrencyRegistry.IsSupported(code)
}</span>

func ListSupported() ([]string, error) <span class="cov8" title="1">{
        return globalCurrencyRegistry.ListSupported()
}</span>

func ListAll() ([]Meta, error) <span class="cov0" title="0">{
        return globalCurrencyRegistry.ListAll()
}</span>

func Unregister(code string) error <span class="cov8" title="1">{
        return globalCurrencyRegistry.Unregister(code)
}</span>

func Count() (int, error) <span class="cov8" title="1">{
        return globalCurrencyRegistry.Count()
}</span>

func CountActive() (int, error) <span class="cov0" title="0">{
        return globalCurrencyRegistry.CountActive()
}</span>

func Search(query string) ([]Meta, error) <span class="cov8" title="1">{
        return globalCurrencyRegistry.Search(query)
}</span>

func SearchByRegion(region string) ([]Meta, error) <span class="cov0" title="0">{
        return globalCurrencyRegistry.SearchByRegion(region)
}</span>

// Legacy Backward compatibility functions (deprecated)
func Legacy(code string, meta Meta) <span class="cov8" title="1">{
        // Convert legacy format to new format
        newMeta := Meta{
                Code:     code,
                Name:     code,
                Symbol:   meta.Symbol,
                Decimals: meta.Decimals,
                Active:   true,
        }

        if err := Register(newMeta); err != nil </span><span class="cov0" title="0">{
                // Log error but don't panic for backward compatibility
                fmt.Printf("Warning: failed to register currency %s: %v\n", code, err)
        }</span>
}

func GetLegacy(code string) Meta <span class="cov8" title="1">{
        meta, err := Get(code)
        if err != nil </span><span class="cov8" title="1">{
                // Return default for backward compatibility
                return Meta{
                        Code:     code,
                        Name:     code,
                        Symbol:   code,
                        Decimals: DefaultDecimals,
                        Active:   false,
                }
        }</span>
        <span class="cov8" title="1">return meta</span>
}

func IsSupportedLegacy(code string) bool <span class="cov8" title="1">{
        return IsSupported(code)
}</span>

func ListSupportedLegacy() []string <span class="cov8" title="1">{
        codes, err := ListSupported()
        if err != nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov8" title="1">return codes</span>
}

func UnregisterLegacy(code string) bool <span class="cov8" title="1">{
        err := Unregister(code)
        return err == nil
}</span>

func CountLegacy() int <span class="cov8" title="1">{
        count, err := Count()
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return count</span>
}
</pre>

		<pre class="file" id="file25" style="display: none">package account

import (
        "errors"
        "fmt"
        "time"

        "github.com/amirasaad/fintech/pkg/money"
        "github.com/google/uuid"
)

var (
        // ErrDepositAmountExceedsMaxSafeInt is returned when a deposit would cause the
        // account balance to overflow.
        ErrDepositAmountExceedsMaxSafeInt = errors.New(
                "deposit amount exceeds maximum safe integer value")

        // ErrTransactionAmountMustBePositive is returned when a transaction amount is not positive.
        ErrTransactionAmountMustBePositive = errors.New(
                "transaction amount must be positive")

        // ErrInsufficientFunds is returned when an account has insufficient funds for a
        // withdrawal or transfer.
        ErrInsufficientFunds = errors.New("insufficient funds")

        // ErrAccountNotFound is returned when an account cannot be found.
        ErrAccountNotFound = errors.New("account not found")

        // ErrTransactionNotFound is returned when a transaction cannot be found.
        ErrTransactionNotFound = errors.New("transaction not found")

        // ErrCannotTransferToSameAccount is returned when a transfer
        // is attempted from an account to itself.
        ErrCannotTransferToSameAccount = errors.New("cannot transfer to same account")
        // ErrNilAccount is returned when a nil account
        // is provided to a transfer or other operation.
        ErrNilAccount = errors.New("nil account")
        // ErrNotOwner is returned when a user attempts to
        // perform an action on an account they do not own.
        ErrNotOwner = errors.New("not owner")
        // ErrCurrencyMismatch is returned when there is
        // a currency mismatch between accounts or transactions.
        ErrCurrencyMismatch = errors.New("currency mismatch")
)

// Account represents a user's financial account, encapsulating its balance and ownership.
// It acts as an aggregate root, ensuring all state changes are consistent and valid.
//
// Invariants:
// - An account must always have a valid owner (UserID).
// - The account's balance is represented by a Money value object, ensuring currency consistency.
// - The balance can never be negative.
// - All operations are thread-safe, enforced by a mutex.
type Account struct {
        ID        uuid.UUID
        UserID    uuid.UUID
        Balance   *money.Money // Account balance as a Money value object.
        UpdatedAt time.Time
        CreatedAt time.Time
}

// Builder provides a fluent API for constructing Account instances.
// This pattern is particularly useful for setting optional parameters and ensuring
// that only valid accounts are constructed.
type Builder struct {
        id        uuid.UUID
        userID    uuid.UUID
        balance   int64
        currency  money.Code
        updatedAt time.Time
        createdAt time.Time
}

// New creates a new Builder with sensible defaults, such as a new UUID and the default currency.
func New() *Builder <span class="cov8" title="1">{
        return &amp;Builder{
                id:        uuid.New(),
                currency:  money.DefaultCode,
                createdAt: time.Now(),
        }
}</span>

// WithID sets the ID for the account being built.
func (b *Builder) WithID(id uuid.UUID) *Builder <span class="cov8" title="1">{
        b.id = id
        return b
}</span>

// WithUserID sets the user ID for the account being built. This is a mandatory field.
func (b *Builder) WithUserID(userID uuid.UUID) *Builder <span class="cov8" title="1">{
        b.userID = userID
        return b
}</span>

// WithCurrency sets the currency for the account being built.
// If not set, it defaults to the system's default currency.
// This method accepts string, money.Code, or money.Currency types for backward compatibility.
func (b *Builder) WithCurrency(currencyCode interface{}) *Builder <span class="cov8" title="1">{
        switch v := currencyCode.(type) </span>{
        case string:<span class="cov8" title="1">
                b.currency = money.Code(v)</span>
        case money.Code:<span class="cov8" title="1">
                b.currency = v</span>
        case money.Currency:<span class="cov0" title="0">
                b.currency = v.Code</span>
        default:<span class="cov0" title="0">
                b.currency = money.DefaultCode</span>
        }
        <span class="cov8" title="1">return b</span>
}

// WithBalance sets the initial balance for the account. This should only be used
// for hydrating an existing account from a data store or for test setup.
func (b *Builder) WithBalance(balance int64) *Builder <span class="cov8" title="1">{
        b.balance = balance
        return b
}</span>

// WithCreatedAt sets the creation timestamp. This is primarily for hydrating
// an existing account from a data store.
func (b *Builder) WithCreatedAt(t time.Time) *Builder <span class="cov0" title="0">{
        b.createdAt = t
        return b
}</span>

// WithUpdatedAt sets the last-updated timestamp. This is primarily for hydrating
// an existing account from a data store.
func (b *Builder) WithUpdatedAt(t time.Time) *Builder <span class="cov0" title="0">{
        b.updatedAt = t
        return b
}</span>

// Build finalizes the construction of the Account. It validates all invariants,
// such as ensuring a valid currency and a non-nil UserID, before returning the
// new Account instance.
func (b *Builder) Build() (*Account, error) <span class="cov8" title="1">{
        if b.userID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, errors.New("user ID is required")
        }</span>

        <span class="cov8" title="1">if b.currency == "" </span><span class="cov0" title="0">{
                b.currency = money.DefaultCode
        }</span>

        // Create a zero-amount money object in the specified currency
        <span class="cov8" title="1">balance, err := money.NewFromSmallestUnit(b.balance, b.currency)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid balance: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Account{
                ID:        b.id,
                UserID:    b.userID,
                Balance:   balance,
                UpdatedAt: b.updatedAt,
                CreatedAt: b.createdAt,
        }, nil</span>
}

// SetCurrency sets the account's currency.
// This is typically only used during account creation or migration.
func (a *Account) SetCurrency(c money.Code) error <span class="cov0" title="0">{
        if a.Balance.Amount() != 0 </span><span class="cov0" title="0">{
                return errors.New("cannot change currency of account with non-zero balance")
        }</span>

        <span class="cov0" title="0">var err error
        a.Balance, err = money.NewFromSmallestUnit(0, c)
        return err</span>
}

// validate checks all business invariants for an operation (common validation logic).
func (a *Account) validate(userID uuid.UUID) error <span class="cov8" title="1">{
        if a.UserID != userID </span><span class="cov0" title="0">{
                return ErrNotOwner
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (a *Account) validateAmount(amount *money.Money) error <span class="cov8" title="1">{
        if !amount.IsPositive() </span><span class="cov8" title="1">{
                return ErrTransactionAmountMustBePositive
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateDeposit checks all business invariants for a deposit operation.
func (a *Account) ValidateDeposit(userID uuid.UUID, amount *money.Money) (err error) <span class="cov8" title="1">{
        if err = a.validate(userID); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if err = a.validateAmount(amount); err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if !a.Balance.IsSameCurrency(amount) </span><span class="cov8" title="1">{
                return ErrCurrencyMismatch
        }</span>

        <span class="cov8" title="1">return</span>
}

// ValidateWithdraw removes funds from the account if all business invariants are satisfied.
// Invariants enforced:
//   - Only the account owner can withdraw.
//   - Withdrawal amount must be positive.
//   - Withdrawal currency must match account currency.
//   - Cannot withdraw more than the current balance.
//
// Returns a Transaction or an error if any invariant is violated.
func (a *Account) ValidateWithdraw(userID uuid.UUID, amount *money.Money) error <span class="cov8" title="1">{
        if a.UserID != userID </span><span class="cov8" title="1">{
                return ErrNotOwner
        }</span>
        <span class="cov8" title="1">if err := a.validateAmount(amount); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Sufficient funds check: do not allow negative balance
        <span class="cov8" title="1">hasEnough, err := a.Balance.GreaterThan(amount)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if !hasEnough &amp;&amp; !a.Balance.Equals(amount) </span><span class="cov8" title="1">{
                return ErrInsufficientFunds
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateTransfer ensures that a funds transfer from this account to another is valid.
func (a *Account) ValidateTransfer(
        senderUserID, receiverUserID uuid.UUID,
        dest *Account,
        amount *money.Money,
) error <span class="cov8" title="1">{
        if a == nil || dest == nil </span><span class="cov8" title="1">{
                return ErrNilAccount
        }</span>
        <span class="cov8" title="1">if a.ID == dest.ID </span><span class="cov8" title="1">{
                return ErrCannotTransferToSameAccount
        }</span>
        <span class="cov8" title="1">if a.UserID != senderUserID </span><span class="cov8" title="1">{
                return ErrNotOwner
        }</span>
        <span class="cov8" title="1">if !amount.IsPositive() </span><span class="cov8" title="1">{
                return ErrTransactionAmountMustBePositive
        }</span>
        <span class="cov8" title="1">if !a.Balance.IsSameCurrency(amount) ||
                !dest.Balance.IsSameCurrency(amount) </span><span class="cov8" title="1">{
                return ErrCurrencyMismatch
        }</span>
        <span class="cov8" title="1">hasEnough, err := a.Balance.GreaterThan(amount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !hasEnough &amp;&amp; !a.Balance.Equals(amount) </span><span class="cov8" title="1">{
                return ErrInsufficientFunds
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file26" style="display: none">package account

import (
        "time"

        "github.com/amirasaad/fintech/pkg/money"
        "github.com/google/uuid"
)

// MoneySource represents the origin of funds for a transaction.
type MoneySource string

// Money source constants define the origin of funds for transactions.
const (
        MoneySourceInternal       MoneySource = "Internal"
        MoneySourceBankAccount    MoneySource = "BankAccount"
        MoneySourceCard           MoneySource = "Card"
        MoneySourceCash           MoneySource = "Cash"
        MoneySourceExternalWallet MoneySource = "ExternalWallet"
)

// TransactionStatus represents the status of a transaction in the payment lifecycle.
type TransactionStatus string

// Transaction status constants define the lifecycle of a transaction.
const (
        // TransactionStatusPending indicates that a transaction
        // has been initiated and is awaiting completion.
        TransactionStatusPending TransactionStatus = "pending"
        // TransactionStatusCompleted indicates that a transaction
        // has been completed successfully.
        TransactionStatusCompleted TransactionStatus = "completed"
        // TransactionStatusFailed indicates that a transaction
        // has been failed.
        TransactionStatusFailed TransactionStatus = "failed"
)

// ExternalTarget represents the destination for an external withdrawal,
// such as a bank account or wallet.
type ExternalTarget struct {
        BankAccountNumber     string
        RoutingNumber         string
        ExternalWalletAddress string
}

// Transaction represents a financial transaction, capturing all details of a
// single ledger entry.
// It acts as a value object within the domain.
type Transaction struct {
        ID          uuid.UUID
        UserID      uuid.UUID
        AccountID   uuid.UUID
        Amount      money.Money
        Balance     money.Money // A snapshot of the account balance at the time of the transaction.
        MoneySource MoneySource // The origin of the funds (e.g., Cash, BankAccount, Stripe).
        Status      TransactionStatus
        CreatedAt   time.Time
}

// NewTransactionFromData creates a Transaction instance from raw data.
// This function is intended for use by repositories to hydrate a domain object from a data store
// or for setting up test fixtures.
// It bypasses domain invariants and should not be used in business logic.
func NewTransactionFromData(
        id, userID, accountID uuid.UUID,
        amount money.Money,
        balance money.Money,
        moneySource MoneySource,
        created time.Time,
) *Transaction <span class="cov0" title="0">{
        return &amp;Transaction{
                ID:          id,
                UserID:      userID,
                AccountID:   accountID,
                Amount:      amount,
                Balance:     balance,
                MoneySource: moneySource,
                CreatedAt:   created,
        }
}</span>
</pre>

		<pre class="file" id="file27" style="display: none">package events

import (
        "github.com/google/uuid"
        "time"
)

type FlowEventOpt func(*FlowEvent)

func NewFlowEvent(opts ...FlowEventOpt) *FlowEvent <span class="cov8" title="1">{
        e := &amp;FlowEvent{
                ID:            uuid.New(),
                FlowType:      "",
                UserID:        uuid.New(),
                AccountID:     uuid.New(),
                CorrelationID: uuid.New(),
                Timestamp:     time.Now(),
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(e)
        }</span>

        <span class="cov8" title="1">return e</span>
}

func (e *FlowEvent) WithUserID(userID uuid.UUID) *FlowEvent <span class="cov8" title="1">{
        e.UserID = userID
        return e
}</span>

func (e *FlowEvent) WithID(id uuid.UUID) *FlowEvent <span class="cov8" title="1">{
        e.ID = id
        return e
}</span>

func (e *FlowEvent) WithAccountID(accountID uuid.UUID) *FlowEvent <span class="cov8" title="1">{
        e.AccountID = accountID
        return e
}</span>

func (e *FlowEvent) WithCorrelationID(correlationID uuid.UUID) *FlowEvent <span class="cov8" title="1">{
        e.CorrelationID = correlationID
        return e
}</span>

func (e *FlowEvent) WithFlowType(flowType string) *FlowEvent <span class="cov8" title="1">{
        e.FlowType = flowType
        return e
}</span>
</pre>

		<pre class="file" id="file28" style="display: none">package events

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/google/uuid"
)

// CurrencyConversionRequested is an agnostic event
// for requesting currency conversion in any business flow.
type CurrencyConversionRequested struct {
        FlowEvent
        OriginalRequest Event `json:"-"` // Handle this field manually in MarshalJSON/UnmarshalJSON
        Amount          *money.Money
        To              money.Code
        TransactionID   uuid.UUID

        // Used for JSON serialization
        RequestType    string          `json:"requestType,omitempty"`
        RequestPayload json.RawMessage `json:"requestPayload,omitempty"`
}

func (e CurrencyConversionRequested) Type() string <span class="cov8" title="1">{
        return EventTypeCurrencyConversionRequested.String()
}</span>

// MarshalJSON implements custom JSON marshaling for CurrencyConversionRequested
func (e CurrencyConversionRequested) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        // Create an auxiliary type to avoid recursion
        type Alias CurrencyConversionRequested

        // Create a copy to avoid modifying the original
        eCopy := e

        // Marshal the original request if it exists
        if eCopy.OriginalRequest != nil </span><span class="cov0" title="0">{
                // Store the type name for proper unmarshaling
                eCopy.RequestType = fmt.Sprintf("%T", eCopy.OriginalRequest)

                // Marshal the original request
                var err error
                eCopy.RequestPayload, err = json.Marshal(eCopy.OriginalRequest)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal original request: %w", err)
                }</span>
        }

        <span class="cov8" title="1">aux := &amp;struct {
                *Alias
        }{
                Alias: (*Alias)(&amp;eCopy),
        }

        return json.Marshal(aux)</span>
}

// UnmarshalJSON implements custom JSON unmarshaling for CurrencyConversionRequested
func (e *CurrencyConversionRequested) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        // Create an auxiliary type to avoid recursion
        type Alias CurrencyConversionRequested
        aux := &amp;struct {
                *Alias
        }{
                Alias: (*Alias)(e),
        }

        // Unmarshal the main fields
        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal CurrencyConversionRequested: %w", err)
        }</span>

        // If we have a request type and payload, try to unmarshal it
        <span class="cov0" title="0">if e.RequestType != "" &amp;&amp; len(e.RequestPayload) &gt; 0 </span><span class="cov0" title="0">{
                // Create a new instance of the appropriate type based on RequestType
                var request Event
                switch e.RequestType </span>{
                case "*events.DepositRequested", "events.DepositRequested":<span class="cov0" title="0">
                        req := &amp;DepositRequested{}
                        if err := json.Unmarshal(e.RequestPayload, req); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to unmarshal DepositRequested: %w", err)
                        }</span>
                        <span class="cov0" title="0">request = req</span>
                case "*events.WithdrawRequested", "events.WithdrawRequested":<span class="cov0" title="0">
                        req := &amp;WithdrawRequested{}
                        if err := json.Unmarshal(e.RequestPayload, req); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to unmarshal WithdrawRequested: %w", err)
                        }</span>
                        <span class="cov0" title="0">request = req</span>
                case "*events.TransferRequested", "events.TransferRequested":<span class="cov0" title="0">
                        req := &amp;TransferRequested{}
                        if err := json.Unmarshal(e.RequestPayload, req); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to unmarshal TransferRequested: %w", err)
                        }</span>
                        <span class="cov0" title="0">request = req</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unsupported request type: %s", e.RequestType)</span>
                }
                <span class="cov0" title="0">e.OriginalRequest = request</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CurrencyConverted is an agnostic event for reporting
// the successful result of a currency conversion.
type CurrencyConverted struct {
        CurrencyConversionRequested
        TransactionID   uuid.UUID
        ConvertedAmount *money.Money
        ConversionInfo  *provider.ExchangeInfo `json:"-"`
}

func (e CurrencyConverted) Type() string <span class="cov8" title="1">{ return EventTypeCurrencyConverted.String() }</span>

// MarshalJSON implements custom JSON marshaling for CurrencyConverted
func (e CurrencyConverted) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        // Create an auxiliary structure to explicitly handle all fields
        aux := struct {
                // Embedded CurrencyConversionRequested fields
                ID                   uuid.UUID       `json:"id"`
                FlowType             string          `json:"flowType"`
                UserID               uuid.UUID       `json:"userId"`
                AccountID            uuid.UUID       `json:"accountId"`
                CorrelationID        uuid.UUID       `json:"correlationId"`
                Timestamp            time.Time       `json:"timestamp"`
                Amount               *money.Money    `json:"amount"`
                To                   money.Code      `json:"to"`
                RequestTransactionID uuid.UUID       `json:"requestTransactionId"` // From embedded CCR
                RequestType          string          `json:"requestType,omitempty"`
                RequestPayload       json.RawMessage `json:"requestPayload,omitempty"`

                // CurrencyConverted specific fields
                TransactionID   uuid.UUID              `json:"transactionId"`
                ConvertedAmount *money.Money           `json:"convertedAmount"`
                ConversionInfo  *provider.ExchangeInfo `json:"conversionInfo"`
        }{
                // Copy from embedded CurrencyConversionRequested
                ID:                   e.ID,
                FlowType:             e.FlowType,
                UserID:               e.UserID,
                AccountID:            e.AccountID,
                CorrelationID:        e.CorrelationID,
                Timestamp:            e.Timestamp,
                Amount:               e.Amount,
                To:                   e.To,
                RequestTransactionID: e.TransactionID,
                RequestType:          e.RequestType,
                RequestPayload:       e.RequestPayload,

                // Copy CurrencyConverted specific fields
                TransactionID:   e.TransactionID,
                ConvertedAmount: e.ConvertedAmount, // Keep as pointer
                ConversionInfo:  e.ConversionInfo,
        }

        // Handle OriginalRequest marshaling
        if e.OriginalRequest != nil </span><span class="cov0" title="0">{
                aux.RequestType = fmt.Sprintf("%T", e.OriginalRequest)
                var err error
                aux.RequestPayload, err = json.Marshal(e.OriginalRequest)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(
                                "failed to marshal original request in CurrencyConverted: %w",
                                err,
                        )
                }</span>
        }

        <span class="cov8" title="1">return json.Marshal(aux)</span>
}

// UnmarshalJSON implements custom JSON unmarshaling for CurrencyConverted
func (e *CurrencyConverted) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        // Create an auxiliary structure to match the marshaling format
        aux := struct {
                // Embedded CurrencyConversionRequested fields
                ID                   uuid.UUID       `json:"id"`
                FlowType             string          `json:"flowType"`
                UserID               uuid.UUID       `json:"userId"`
                AccountID            uuid.UUID       `json:"accountId"`
                CorrelationID        uuid.UUID       `json:"correlationId"`
                Timestamp            time.Time       `json:"timestamp"`
                Amount               money.Money     `json:"amount"`
                To                   money.Code      `json:"to"`
                RequestTransactionID uuid.UUID       `json:"requestTransactionId"` // From embedded CCR
                RequestType          string          `json:"requestType,omitempty"`
                RequestPayload       json.RawMessage `json:"requestPayload,omitempty"`

                // CurrencyConverted specific fields
                TransactionID   uuid.UUID       `json:"transactionId"`
                ConvertedAmount *money.Money    `json:"convertedAmount"`
                ConversionInfo  json.RawMessage `json:"conversionInfo"`
        }{}

        // Unmarshal the main fields
        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal CurrencyConverted: %w", err)
        }</span>

        // Copy fields to the embedded CurrencyConversionRequested
        <span class="cov0" title="0">e.ID = aux.ID
        e.FlowType = aux.FlowType
        e.UserID = aux.UserID
        e.AccountID = aux.AccountID
        e.CorrelationID = aux.CorrelationID
        e.Timestamp = aux.Timestamp
        // Create a new money.Money pointer and copy the value
        if aux.Amount != (money.Money{}) </span><span class="cov0" title="0">{
                amount := aux.Amount // Create a copy
                e.Amount = &amp;amount
        }</span> else<span class="cov0" title="0"> {
                e.Amount = nil
        }</span>
        <span class="cov0" title="0">e.To = aux.To
        e.TransactionID = aux.RequestTransactionID
        e.RequestType = aux.RequestType
        e.RequestPayload = aux.RequestPayload

        // Copy CurrencyConverted specific fields
        e.TransactionID = aux.TransactionID
        e.ConvertedAmount = aux.ConvertedAmount

        // Handle the OriginalRequest reconstruction
        if aux.RequestType != "" &amp;&amp; len(aux.RequestPayload) &gt; 0 </span><span class="cov0" title="0">{
                // Create a new instance of the appropriate type based on RequestType
                var request Event
                switch aux.RequestType </span>{
                case "*events.DepositRequested", "events.DepositRequested":<span class="cov0" title="0">
                        req := &amp;DepositRequested{}
                        if err := json.Unmarshal(aux.RequestPayload, req); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf(
                                        "failed to unmarshal DepositRequested in CurrencyConverted: %w",
                                        err,
                                )
                        }</span>
                        <span class="cov0" title="0">request = req</span>
                case "*events.WithdrawRequested", "events.WithdrawRequested":<span class="cov0" title="0">
                        req := &amp;WithdrawRequested{}
                        if err := json.Unmarshal(aux.RequestPayload, req); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf(
                                        "failed to unmarshal WithdrawRequested in CurrencyConverted: %w",
                                        err,
                                )
                        }</span>
                        <span class="cov0" title="0">request = req</span>
                case "*events.TransferRequested", "events.TransferRequested":<span class="cov0" title="0">
                        req := &amp;TransferRequested{}
                        if err := json.Unmarshal(aux.RequestPayload, req); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf(
                                        "failed to unmarshal TransferRequested in CurrencyConverted: %w",
                                        err,
                                )
                        }</span>
                        <span class="cov0" title="0">request = req</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf(
                                "unsupported request type in CurrencyConverted: %s",
                                aux.RequestType,
                        )</span>
                }
                <span class="cov0" title="0">e.OriginalRequest = request</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CurrencyConversionFailed is an event for reporting a failed currency conversion.
type CurrencyConversionFailed struct {
        FlowEvent
        TransactionID uuid.UUID
        Amount        money.Money
        To            money.Code
        Reason        string
}

func (e CurrencyConversionFailed) Type() string <span class="cov0" title="0">{
        return EventTypeCurrencyConversionFailed.String()
}</span>
</pre>

		<pre class="file" id="file29" style="display: none">package events

import (
        "time"

        "github.com/amirasaad/fintech/pkg/money"
        "github.com/google/uuid"
)

// CurrencyConversionRequestedOpt --- CurrencyConversionRequested ---
type CurrencyConversionRequestedOpt func(*CurrencyConversionRequested)

// WithConversionAmount sets the amount for the CurrencyConversionRequested.
func WithConversionAmount(amount *money.Money) CurrencyConversionRequestedOpt <span class="cov0" title="0">{
        return func(e *CurrencyConversionRequested) </span><span class="cov0" title="0">{ e.Amount = amount }</span>
}

// WithConversionTo sets the target currency for the
// CurrencyConversionRequested.
func WithConversionTo(currency money.Code) CurrencyConversionRequestedOpt <span class="cov0" title="0">{
        return func(e *CurrencyConversionRequested) </span><span class="cov0" title="0">{ e.To = currency }</span>
}

// WithConversionTransactionID sets the transaction ID for the
// CurrencyConversionRequested.
func WithConversionTransactionID(id uuid.UUID) CurrencyConversionRequestedOpt <span class="cov0" title="0">{
        return func(e *CurrencyConversionRequested) </span><span class="cov0" title="0">{ e.TransactionID = id }</span>
}

// NewCurrencyConversionRequested creates a new CurrencyConversionRequested
// with the given options.
func NewCurrencyConversionRequested(
        fe FlowEvent,
        or Event,
        opts ...CurrencyConversionRequestedOpt,
) *CurrencyConversionRequested <span class="cov0" title="0">{
        ccr := &amp;CurrencyConversionRequested{
                FlowEvent:       fe,
                OriginalRequest: or,
        }
        ccr.ID = uuid.New()
        ccr.Timestamp = time.Now()

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(ccr)
        }</span>

        <span class="cov0" title="0">return ccr</span>
}

// CurrencyConvertedOpt --- CurrencyConverted ---
type CurrencyConvertedOpt func(*CurrencyConverted)

// NewCurrencyConverted creates a new CurrencyConverted with the given options.
func NewCurrencyConverted(
        ccr *CurrencyConversionRequested,
        opts ...CurrencyConvertedOpt,
) *CurrencyConverted <span class="cov0" title="0">{
        cc := &amp;CurrencyConverted{
                CurrencyConversionRequested: *ccr,
        }
        cc.ID = uuid.New()
        cc.Timestamp = time.Now()

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(cc)
        }</span>

        <span class="cov0" title="0">return cc</span>
}
</pre>

		<pre class="file" id="file30" style="display: none">package events

import (
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/google/uuid"
)

// DepositRequested is emitted after deposit validation and persistence.
type DepositRequested struct {
        FlowEvent
        Amount        *money.Money
        Source        string
        TransactionID uuid.UUID
}

func (e DepositRequested) Type() string <span class="cov8" title="1">{ return EventTypeDepositRequested.String() }</span>
func (e DepositRequested) Validate() error <span class="cov0" title="0">{
        return nil
}</span>

// DepositCurrencyConverted is emitted after currency conversion for deposit.
type DepositCurrencyConverted struct {
        CurrencyConverted
}

func (e DepositCurrencyConverted) Type() string <span class="cov8" title="1">{
        return EventTypeDepositCurrencyConverted.String()
}</span>

// DepositValidated is emitted after business validation for deposit.
type DepositValidated struct {
        DepositCurrencyConverted
}

func (e DepositValidated) Type() string <span class="cov8" title="1">{ return EventTypeDepositValidated.String() }</span>

// DepositFailed is emitted when a deposit fails.
type DepositFailed struct {
        DepositRequested
        Reason string
}

func (e DepositFailed) Type() string <span class="cov8" title="1">{ return EventTypeDepositFailed.String() }</span>
</pre>

		<pre class="file" id="file31" style="display: none">package events

import (
        "time"

        "github.com/amirasaad/fintech/pkg/money"
        "github.com/google/uuid"
)

// DepositRequestedOpt is a function that configures a DepositRequested
type DepositRequestedOpt func(*DepositRequested)

// WithDepositAmount sets the deposit amount
func WithDepositAmount(m *money.Money) DepositRequestedOpt <span class="cov0" title="0">{
        return func(e *DepositRequested) </span><span class="cov0" title="0">{ e.Amount = m }</span>
}

// WithDepositTimestamp sets the deposit timestamp
func WithDepositTimestamp(ts time.Time) DepositRequestedOpt <span class="cov0" title="0">{
        return func(e *DepositRequested) </span><span class="cov0" title="0">{ e.Timestamp = ts }</span>
}

// WithDepositID sets the deposit ID
func WithDepositID(id uuid.UUID) DepositRequestedOpt <span class="cov0" title="0">{
        return func(e *DepositRequested) </span><span class="cov0" title="0">{ e.ID = id }</span>
}

// WithDepositFlowEvent sets the flow event for the deposit
func WithDepositFlowEvent(fe FlowEvent) DepositRequestedOpt <span class="cov0" title="0">{
        return func(e *DepositRequested) </span><span class="cov0" title="0">{ e.FlowEvent = fe }</span>
}

// WithDepositTransactionID sets the transaction ID for the deposit
func WithDepositTransactionID(id uuid.UUID) DepositRequestedOpt <span class="cov0" title="0">{
        return func(e *DepositRequested) </span><span class="cov0" title="0">{ e.TransactionID = id }</span>
}

// WithDepositSource is a test helper to set the source on a DepositRequested event
func WithDepositSource(source string) DepositRequestedOpt <span class="cov0" title="0">{
        return func(e *DepositRequested) </span><span class="cov0" title="0">{
                e.Source = source
        }</span>
}

// NewDepositRequested creates a new DepositRequested event with the given
// parameters
func NewDepositRequested(
        userID, accountID, correlationID uuid.UUID,
        opts ...DepositRequestedOpt,
) *DepositRequested <span class="cov0" title="0">{
        dr := &amp;DepositRequested{
                FlowEvent: FlowEvent{
                        ID:            uuid.New(),
                        FlowType:      "deposit",
                        UserID:        userID,
                        AccountID:     accountID,
                        CorrelationID: correlationID,
                        Timestamp:     time.Now(),
                },
                TransactionID: uuid.New(),
                Amount:        money.Zero(money.USD),
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(dr)
        }</span>

        <span class="cov0" title="0">return dr</span>
}

type DepositCurrencyConvertedOpt func(*DepositCurrencyConverted)

// NewDepositCurrencyConverted creates a new DepositCurrencyConverted event with
// the given parameters
func NewDepositCurrencyConverted(
        cc *CurrencyConverted,
        opts ...DepositCurrencyConvertedOpt,
) *DepositCurrencyConverted <span class="cov0" title="0">{
        de := &amp;DepositCurrencyConverted{
                CurrencyConverted: *cc,
        }
        de.ID = uuid.New()
        de.Timestamp = time.Now()

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(de)
        }</span>

        <span class="cov0" title="0">return de</span>
}

type DepositValidatedOpt func(*DepositValidated)

// NewDepositValidated creates a new DepositValidated event with the given parameters
func NewDepositValidated(dcv *DepositCurrencyConverted) *DepositValidated <span class="cov0" title="0">{
        dv := &amp;DepositValidated{
                DepositCurrencyConverted: *dcv,
        }
        dv.ID = uuid.New()
        dv.Timestamp = time.Now()

        return dv
}</span>

// DepositFailedOpt is a function that configures a DepositFailed
type DepositFailedOpt func(*DepositFailed)

// WithFailureReason sets the failure reason
func WithFailureReason(reason string) DepositFailedOpt <span class="cov0" title="0">{
        return func(df *DepositFailed) </span><span class="cov0" title="0">{ df.Reason = reason }</span>
}

// WithDepositFailedTransactionID sets the transaction ID for a failed deposit event
func WithDepositFailedTransactionID(id uuid.UUID) DepositFailedOpt <span class="cov0" title="0">{
        return func(df *DepositFailed) </span><span class="cov0" title="0">{ df.TransactionID = id }</span>
}

// NewDepositFailed creates a new DepositFailed event with the given parameters
func NewDepositFailed(
        dr *DepositRequested,
        reason string,
        opts ...DepositFailedOpt,
) *DepositFailed <span class="cov0" title="0">{
        df := &amp;DepositFailed{
                DepositRequested: *dr,
                Reason:           reason,
        }
        df.ID = uuid.New()
        df.Timestamp = time.Now()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(df)
        }</span>

        <span class="cov0" title="0">return df</span>
}
</pre>

		<pre class="file" id="file32" style="display: none">package events

// EventType represents the type of an event in the system.
type EventType string

// Event type constants
const (
        // Payment events
        EventTypePaymentInitiated EventType = "Payment.Initiated"
        EventTypePaymentProcessed EventType = "Payment.Processed"
        EventTypePaymentCompleted EventType = "Payment.Completed"
        EventTypePaymentFailed    EventType = "Payment.Failed"

        // Deposit events
        EventTypeDepositRequested         EventType = "Deposit.Requested"
        EventTypeDepositCurrencyConverted EventType = "Deposit.CurrencyConverted"
        EventTypeDepositValidated         EventType = "Deposit.Validated"
        EventTypeDepositFailed            EventType = "Deposit.Failed"

        // Withdraw events
        EventTypeWithdrawRequested         EventType = "Withdraw.Requested"
        EventTypeWithdrawCurrencyConverted EventType = "Withdraw.CurrencyConverted"
        EventTypeWithdrawValidated         EventType = "Withdraw.Validated"
        EventTypeWithdrawFailed            EventType = "Withdraw.Failed"

        // Transfer events
        EventTypeTransferRequested         EventType = "Transfer.Requested"
        EventTypeTransferCurrencyConverted EventType = "Transfer.CurrencyConverted"
        EventTypeTransferValidated         EventType = "Transfer.Validated"
        EventTypeTransferCompleted         EventType = "Transfer.Completed"
        EventTypeTransferFailed            EventType = "Transfer.Failed"

        // Fee events
        EventTypeFeesCalculated EventType = "Fees.Calculated"

        // Currency conversion events
        EventTypeCurrencyConversionRequested EventType = "CurrencyConversion.Requested"
        EventTypeCurrencyConverted           EventType = "CurrencyConversion.Converted"
        EventTypeCurrencyConversionFailed    EventType = "CurrencyConversion.Failed"
)

// String returns the string representation of the event type.
func (et EventType) String() string <span class="cov8" title="1">{
        return string(et)
}</span>
</pre>

		<pre class="file" id="file33" style="display: none">package events

import (
        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/google/uuid"
)

// FeesCalculated is emitted after all fees for a transaction have been calculated.
type FeesCalculated struct {
        FlowEvent
        TransactionID uuid.UUID
        Fee           account.Fee
}

func (e FeesCalculated) Type() string <span class="cov0" title="0">{ return EventTypeFeesCalculated.String() }</span>
</pre>

		<pre class="file" id="file34" style="display: none">package events

import (
        "time"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/google/uuid"
)

// FeesCalculatedOpt is a function that configures a FeesCalculated event
type FeesCalculatedOpt func(*FeesCalculated)

// WithFeeTransactionID sets the transaction ID for the FeesCalculated event
func WithFeeTransactionID(id uuid.UUID) FeesCalculatedOpt <span class="cov0" title="0">{
        return func(e *FeesCalculated) </span><span class="cov0" title="0">{ e.TransactionID = id }</span>
}

// WithFee sets the fee amount for the FeesCalculated event
func WithFee(fee account.Fee) FeesCalculatedOpt <span class="cov0" title="0">{
        return func(e *FeesCalculated) </span><span class="cov0" title="0">{ e.Fee = fee }</span>
}

// NewFeesCalculated creates a new FeesCalculated event with the given options
func NewFeesCalculated(ef *FlowEvent, opts ...FeesCalculatedOpt) *FeesCalculated <span class="cov0" title="0">{
        e := &amp;FeesCalculated{
                FlowEvent: *ef,
        }

        // Set default values
        e.ID = uuid.New()
        e.Timestamp = time.Now()

        // Apply options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(e)
        }</span>

        <span class="cov0" title="0">return e</span>
}

// WithFeeType sets the fee type for the FeesCalculated event
func WithFeeType(feeType account.FeeType) FeesCalculatedOpt <span class="cov0" title="0">{
        return func(e *FeesCalculated) </span><span class="cov0" title="0">{
                e.Fee.Type = feeType
        }</span>
}

// WithFeeAmountValue sets the fee amount for the FeesCalculated event
func WithFeeAmountValue(amount *money.Money) FeesCalculatedOpt <span class="cov0" title="0">{
        return func(e *FeesCalculated) </span><span class="cov0" title="0">{
                e.Fee.Amount = amount
        }</span>
}
</pre>

		<pre class="file" id="file35" style="display: none">package events

import (
        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/google/uuid"
)

// PaymentInitiated is emitted after payment initiation with a provider (event-driven workflow).
type PaymentInitiated struct {
        FlowEvent
        Amount        *money.Money
        TransactionID uuid.UUID
        PaymentID     *string // Pointer to allow NULL in database
        Status        string
}

func (e PaymentInitiated) Type() string <span class="cov0" title="0">{ return EventTypePaymentInitiated.String() }</span>

func (e *PaymentInitiated) WithAmount(m *money.Money) *PaymentInitiated <span class="cov0" title="0">{
        e.Amount = m
        return e
}</span>

func (e *PaymentInitiated) WithTransactionID(id uuid.UUID) *PaymentInitiated <span class="cov0" title="0">{
        e.TransactionID = id
        return e
}</span>

func (e *PaymentInitiated) WithPaymentID(id string) *PaymentInitiated <span class="cov0" title="0">{
        if id != "" </span><span class="cov0" title="0">{
                e.PaymentID = &amp;id
        }</span> else<span class="cov0" title="0"> {
                e.PaymentID = nil
        }</span>
        <span class="cov0" title="0">return e</span>
}

func (e *PaymentInitiated) WithStatus(status string) *PaymentInitiated <span class="cov0" title="0">{
        e.Status = status
        return e
}</span>

// PaymentFailed is emitted when payment fails.
type PaymentFailed struct {
        PaymentInitiated
        Reason string
}

func (e *PaymentFailed) Type() string <span class="cov0" title="0">{ return EventTypePaymentFailed.String() }</span>

func (e *PaymentFailed) WithReason(reason string) *PaymentFailed <span class="cov0" title="0">{
        e.Reason = reason
        return e
}</span>

type PaymentProcessed struct {
        PaymentInitiated
}

func (e *PaymentProcessed) Type() string <span class="cov0" title="0">{ return EventTypePaymentProcessed.String() }</span>

func (e *PaymentProcessed) WithAmount(m *money.Money) *PaymentProcessed <span class="cov0" title="0">{
        e.Amount = m
        return e
}</span>

// PaymentCompleted is an event for when a payment is completed.
type PaymentCompleted struct {
        PaymentInitiated
        ProviderFee account.Fee
}

func (e PaymentCompleted) Type() string <span class="cov0" title="0">{ return EventTypePaymentCompleted.String() }</span>
</pre>

		<pre class="file" id="file36" style="display: none">package events

import (
        "time"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/google/uuid"
)

// PaymentInitiatedOpt is a function that configures a PaymentInitiated
type PaymentInitiatedOpt func(*PaymentInitiated)

// WithPaymentTransactionID sets the transaction ID for the PaymentInitiated
func WithPaymentTransactionID(id uuid.UUID) PaymentInitiatedOpt <span class="cov0" title="0">{
        return func(
                pi *PaymentInitiated,
        ) </span><span class="cov0" title="0">{
                pi.TransactionID = id
        }</span>
}

// WithPaymentID sets the payment ID for the PaymentInitiated
func WithInitiatedPaymentID(paymentID string) PaymentInitiatedOpt <span class="cov0" title="0">{
        return func(
                pi *PaymentInitiated,
        ) </span><span class="cov0" title="0">{
                if paymentID != "" </span><span class="cov0" title="0">{
                        pi.PaymentID = &amp;paymentID
                }</span> else<span class="cov0" title="0"> {
                        pi.PaymentID = nil
                }</span>
        }
}

// WithPaymentStatus sets the status for the PaymentInitiated
func WithInitiatedPaymentStatus(status string) PaymentInitiatedOpt <span class="cov0" title="0">{
        return func(e *PaymentInitiated) </span><span class="cov0" title="0">{ e.Status = status }</span>
}

// WithFlowEvent sets the FlowEvent from an existing FlowEvent
func WithFlowEvent(fe FlowEvent) PaymentInitiatedOpt <span class="cov0" title="0">{
        return func(e *PaymentInitiated) </span><span class="cov0" title="0">{
                e.FlowEvent = fe
        }</span>
}

// NewPaymentInitiated creates a new PaymentInitiated with the given options
func NewPaymentInitiated(fe *FlowEvent, opts ...PaymentInitiatedOpt) *PaymentInitiated <span class="cov0" title="0">{
        pi := &amp;PaymentInitiated{
                FlowEvent: *fe,
                Status:    "initiated",
        }

        pi.ID = uuid.New()
        pi.Timestamp = time.Now()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(pi)
        }</span>

        <span class="cov0" title="0">return pi</span>
}

type PaymentProcessedOpt func(*PaymentProcessed)

// NewPaymentProcessed creates a new PaymentProcessed with the given parameters
func NewPaymentProcessed(
        ef *FlowEvent,
        opts ...PaymentProcessedOpt,
) *PaymentProcessed <span class="cov0" title="0">{
        // Create base PaymentInitiated with required fields
        pp := &amp;PaymentProcessed{
                PaymentInitiated: PaymentInitiated{
                        FlowEvent: *ef,
                },
        }

        pp.ID = uuid.New()
        pp.Timestamp = time.Now()
        // Apply any additional options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(pp)
        }</span>
        <span class="cov0" title="0">return pp</span>

}

// PaymentCompletedOpt is a function that configures a PaymentCompletedEvent
type PaymentCompletedOpt func(*PaymentCompleted)

// WithPaymentID sets the payment ID for the PaymentCompletedEvent
func WithPaymentID(paymentID *string) PaymentCompletedOpt <span class="cov0" title="0">{
        return func(e *PaymentCompleted) </span><span class="cov0" title="0">{
                e.PaymentID = paymentID
        }</span>
}

// WithProviderFee sets the provider fee for the PaymentCompletedEvent
func WithProviderFee(providerFee account.Fee) PaymentCompletedOpt <span class="cov0" title="0">{
        return func(e *PaymentCompleted) </span><span class="cov0" title="0">{ e.ProviderFee = providerFee }</span>
}

// WithCorrelationID sets the correlation ID for the PaymentCompletedEvent
func WithCorrelationID(correlationID uuid.UUID) PaymentCompletedOpt <span class="cov0" title="0">{
        return func(e *PaymentCompleted) </span><span class="cov0" title="0">{ e.CorrelationID = correlationID }</span>
}

// NewPaymentCompleted creates a new PaymentCompleted with the given options
func NewPaymentCompleted(
        ef *FlowEvent,
        opts ...PaymentCompletedOpt,
) *PaymentCompleted <span class="cov0" title="0">{
        pc := &amp;PaymentCompleted{
                PaymentInitiated: PaymentInitiated{
                        FlowEvent: *ef,
                },
        }

        pc.ID = uuid.New()
        pc.Timestamp = time.Now()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(pc)
        }</span>

        <span class="cov0" title="0">return pc</span>
}

// PaymentFailedOpt is a function that configures a PaymentFailedEvent
type PaymentFailedOpt func(*PaymentFailed)

// WithPaymentID sets the payment ID for the PaymentFailedEvent
func WithFailedPaymentID(paymentID *string) PaymentFailedOpt <span class="cov0" title="0">{
        return func(e *PaymentFailed) </span><span class="cov0" title="0">{
                e.PaymentID = paymentID
        }</span>
}

// NewPaymentFailed creates a new PaymentFailed with the given options
func NewPaymentFailed(
        ef *FlowEvent,
        opts ...PaymentFailedOpt,
) *PaymentFailed <span class="cov0" title="0">{
        pf := &amp;PaymentFailed{
                PaymentInitiated: PaymentInitiated{
                        FlowEvent: *ef,
                },
        }

        pf.ID = uuid.New()
        pf.Timestamp = time.Now()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(pf)
        }</span>

        <span class="cov0" title="0">return pf</span>
}
</pre>

		<pre class="file" id="file37" style="display: none">package events

import (
        "fmt"
        "time"

        "github.com/amirasaad/fintech/pkg/money"
        "github.com/google/uuid"
)

// TransferRequested is emitted after transfer validation and persistence.
type TransferRequested struct {
        FlowEvent
        Amount        *money.Money
        Source        string
        DestAccountID uuid.UUID
        Timestamp     time.Time
        TransactionID uuid.UUID
        Fee           int64
}

func (e *TransferRequested) Type() string <span class="cov0" title="0">{
        return EventTypeTransferRequested.String()
}</span>

func (e *TransferRequested) WithDestAccountID(id uuid.UUID) *TransferRequested <span class="cov0" title="0">{
        return NewTransferRequested(
                e.UserID,
                e.AccountID,
                e.CorrelationID,
                WithTransferDestAccountID(id),
        )
}</span>

func (e *TransferRequested) WithAmount(m *money.Money) *TransferRequested <span class="cov0" title="0">{
        return NewTransferRequested(
                e.UserID,
                e.AccountID,
                e.CorrelationID,
                WithTransferRequestedAmount(m),
        )
}</span>

// Validate checks if the event is valid.
func (e *TransferRequested) Validate() error <span class="cov0" title="0">{
        if e.AccountID == uuid.Nil || e.UserID == uuid.Nil ||
                e.DestAccountID == uuid.Nil || e.Amount.IsZero() || e.Amount.IsNegative() </span><span class="cov0" title="0">{
                return fmt.Errorf("malformed validated event: %+v", e)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// TransferCurrencyConverted is emitted after currency conversion for transfer.
type TransferCurrencyConverted struct {
        CurrencyConverted
}

func (e TransferCurrencyConverted) Type() string <span class="cov0" title="0">{
        return EventTypeTransferCurrencyConverted.String()
}</span>

// TransferValidated is emitted after business validation for transfer.
type TransferValidated struct {
        TransferCurrencyConverted
}

func (e TransferValidated) Type() string <span class="cov0" title="0">{ return EventTypeTransferValidated.String() }</span>

// TransferCompleted is emitted when transfer is fully completed.
type TransferCompleted struct {
        TransferValidated
}

func (e TransferCompleted) Type() string <span class="cov0" title="0">{ return EventTypeTransferCompleted.String() }</span>

// TransferFailed is emitted when transfer fails.
type TransferFailed struct {
        TransferRequested
        Reason string
}

func (e TransferFailed) Type() string <span class="cov0" title="0">{
        return EventTypeTransferFailed.String()
}</span>
</pre>

		<pre class="file" id="file38" style="display: none">package events

import (
        "time"

        "github.com/amirasaad/fintech/pkg/money"
        "github.com/google/uuid"
)

// --- TransferRequested ---
type TransferRequestedOpt func(*TransferRequested)

func WithTransferRequestedAmount(m *money.Money) TransferRequestedOpt <span class="cov0" title="0">{
        return func(e *TransferRequested) </span><span class="cov0" title="0">{ e.Amount = m }</span>
}

// WithTransferFee sets the transfer fee
func WithTransferFee(fee int64) TransferRequestedOpt <span class="cov0" title="0">{
        return func(e *TransferRequested) </span><span class="cov0" title="0">{ e.Fee = fee }</span>
}

func WithTransferDestAccountID(id uuid.UUID) TransferRequestedOpt <span class="cov0" title="0">{
        return func(e *TransferRequested) </span><span class="cov0" title="0">{ e.DestAccountID = id }</span>
}

func NewTransferRequested(
        userID, accountID, correlationID uuid.UUID,
        opts ...TransferRequestedOpt,
) *TransferRequested <span class="cov0" title="0">{
        event := TransferRequested{
                FlowEvent: FlowEvent{
                        ID:            uuid.New(),
                        FlowType:      "transfer",
                        UserID:        userID,
                        AccountID:     accountID,
                        CorrelationID: correlationID,
                },
                Amount:    money.Zero(money.USD),
                Timestamp: time.Now(),
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(&amp;event)
        }</span>
        <span class="cov0" title="0">return &amp;event</span>
}

type TransferCurrencyConvertedOpt func(*TransferCurrencyConverted)

// NewTransferCurrencyConverted creates a new TransferCurrencyConverted event
func NewTransferCurrencyConverted(
        cc *CurrencyConverted,
        opts ...TransferCurrencyConvertedOpt,
) *TransferCurrencyConverted <span class="cov0" title="0">{
        tr := &amp;TransferCurrencyConverted{
                CurrencyConverted: *cc,
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(tr)
        }</span>
        <span class="cov0" title="0">return tr</span>
}

// TransferBusinessValidatedOpt --- TransferBusinessValidated ---
type TransferBusinessValidatedOpt func(*TransferValidated)

// NewTransferBusinessValidated creates a new TransferBusinessValidated event
func NewTransferBusinessValidated(
        tr *TransferCurrencyConverted,
        opts ...TransferBusinessValidatedOpt,
) *TransferValidated <span class="cov0" title="0">{
        tf := &amp;TransferValidated{
                TransferCurrencyConverted: *tr,
        }
        tf.Timestamp = time.Now()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(tf)
        }</span>
        <span class="cov0" title="0">return tf</span>
}

// TransferFailedOpt --- TransferFailed ---
type TransferFailedOpt func(*TransferFailed)

// WithReason sets the failure reason
func WithReason(reason string) TransferFailedOpt <span class="cov0" title="0">{
        return func(f *TransferFailed) </span><span class="cov0" title="0">{ f.Reason = reason }</span>
}

// NewTransferFailed creates a new TransferFailed event
func NewTransferFailed(
        tr *TransferRequested,
        reason string,
        opts ...TransferFailedOpt,
) *TransferFailed <span class="cov0" title="0">{
        tf := &amp;TransferFailed{
                TransferRequested: *tr,
                Reason:            reason,
        }
        tf.ID = uuid.New()
        tf.Timestamp = time.Now()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(tf)
        }</span>
        <span class="cov0" title="0">return tf</span>
}

// TransferCompletedOpt --- TransferCompleted factory ---
type TransferCompletedOpt func(*TransferCompleted)

func WithTransferAmount(m *money.Money) TransferCompletedOpt <span class="cov0" title="0">{
        return func(e *TransferCompleted) </span><span class="cov0" title="0">{ e.Amount = m }</span>
}

// NewTransferCompleted creates a new TransferCompleted with the given options
func NewTransferCompleted(
        tr *TransferRequested,
        opts ...TransferCompletedOpt,
) *TransferCompleted <span class="cov0" title="0">{
        tc := &amp;TransferCompleted{
                TransferValidated: TransferValidated{
                        TransferCurrencyConverted: TransferCurrencyConverted{
                                CurrencyConverted: *NewCurrencyConverted(
                                        NewCurrencyConversionRequested(tr.FlowEvent, tr),
                                ),
                        },
                },
        }
        tc.ID = uuid.New()
        tc.Timestamp = time.Now()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(tc)
        }</span>
        <span class="cov0" title="0">return tc</span>
}
</pre>

		<pre class="file" id="file39" style="display: none">package events

// EventTypes maps event type constants to their respective constructor functions.
var EventTypes = map[EventType]func() Event{
        EventTypePaymentInitiated: func() Event <span class="cov0" title="0">{ return &amp;PaymentInitiated{} }</span>,
        EventTypePaymentCompleted: func() Event <span class="cov0" title="0">{ return &amp;PaymentCompleted{} }</span>,
        EventTypePaymentProcessed: func() Event <span class="cov0" title="0">{ return &amp;PaymentProcessed{} }</span>,
        EventTypeDepositRequested: func() Event <span class="cov0" title="0">{ return &amp;DepositRequested{} }</span>,
        EventTypeDepositCurrencyConverted: func() Event <span class="cov0" title="0">{
                return &amp;DepositCurrencyConverted{}
        }</span>,
        EventTypeDepositValidated:  func() Event <span class="cov0" title="0">{ return &amp;DepositValidated{} }</span>,
        EventTypeDepositFailed:     func() Event <span class="cov0" title="0">{ return &amp;DepositFailed{} }</span>,
        EventTypeWithdrawRequested: func() Event <span class="cov0" title="0">{ return &amp;WithdrawRequested{} }</span>,
        EventTypeWithdrawCurrencyConverted: func() Event <span class="cov0" title="0">{
                return &amp;WithdrawCurrencyConverted{}
        }</span>,
        EventTypeWithdrawValidated: func() Event <span class="cov0" title="0">{ return &amp;WithdrawValidated{} }</span>,
        EventTypeWithdrawFailed:    func() Event <span class="cov0" title="0">{ return &amp;WithdrawFailed{} }</span>,
        EventTypeTransferRequested: func() Event <span class="cov0" title="0">{ return &amp;TransferRequested{} }</span>,
        EventTypeTransferCurrencyConverted: func() Event <span class="cov0" title="0">{
                return &amp;TransferCurrencyConverted{}
        }</span>,
        EventTypeTransferValidated: func() Event <span class="cov0" title="0">{ return &amp;TransferValidated{} }</span>,
        EventTypeTransferCompleted: func() Event <span class="cov0" title="0">{ return &amp;TransferCompleted{} }</span>,
        EventTypeTransferFailed:    func() Event <span class="cov0" title="0">{ return &amp;TransferFailed{} }</span>,
        EventTypeCurrencyConversionRequested: func() Event <span class="cov0" title="0">{
                return &amp;CurrencyConversionRequested{}
        }</span>,
        EventTypeCurrencyConverted: func() Event <span class="cov0" title="0">{ return &amp;CurrencyConverted{} }</span>,
        EventTypeCurrencyConversionFailed: func() Event <span class="cov0" title="0">{
                return &amp;CurrencyConversionFailed{}
        }</span>,

        EventTypeFeesCalculated: func() Event <span class="cov0" title="0">{ return &amp;FeesCalculated{} }</span>,
}
</pre>

		<pre class="file" id="file40" style="display: none">package events

import (
        "fmt"
        "time"

        "github.com/amirasaad/fintech/pkg/money"
        "github.com/google/uuid"
)

// WithdrawRequested is emitted when a withdrawal is requested (pure event-driven
// domain).
type WithdrawRequested struct {
        FlowEvent
        ID                    uuid.UUID
        TransactionID         uuid.UUID
        Amount                *money.Money
        BankAccountNumber     string
        RoutingNumber         string
        ExternalWalletAddress string
        Timestamp             time.Time
        PaymentID             string // Added for payment provider integration
        Fee                   int64
}

func (e *WithdrawRequested) Type() string <span class="cov0" title="0">{
        return EventTypeWithdrawRequested.String()
}</span>

// Validate performs business validation on the withdrawal request
func (e *WithdrawRequested) Validate() error <span class="cov0" title="0">{
        if e.AccountID == uuid.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("account ID cannot be nil")
        }</span>
        <span class="cov0" title="0">if e.UserID == uuid.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user ID cannot be nil")
        }</span>
        <span class="cov0" title="0">if e.Amount.IsZero() </span><span class="cov0" title="0">{
                return fmt.Errorf("amount cannot be zero")
        }</span>
        <span class="cov0" title="0">if e.Amount.IsNegative() </span><span class="cov0" title="0">{
                return fmt.Errorf("amount must be positive")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// WithdrawCurrencyConverted is emitted after currency conversion for withdraw.
type WithdrawCurrencyConverted struct {
        CurrencyConverted
}

func (e WithdrawCurrencyConverted) Type() string <span class="cov0" title="0">{
        return EventTypeWithdrawCurrencyConverted.String()
}</span>

// WithdrawValidated is emitted after business validation for withdraw.
type WithdrawValidated struct {
        WithdrawCurrencyConverted
}

func (e WithdrawValidated) Type() string <span class="cov0" title="0">{
        return EventTypeWithdrawValidated.String()
}</span>

// WithdrawFailed is emitted when any part of the withdrawal flow fails.
type WithdrawFailed struct {
        WithdrawRequested
        Reason string
}

func (e WithdrawFailed) Type() string <span class="cov0" title="0">{ return EventTypeWithdrawFailed.String() }</span>
</pre>

		<pre class="file" id="file41" style="display: none">package events

import (
        "time"

        "github.com/amirasaad/fintech/pkg/money"
        "github.com/google/uuid"
)

// --- WithdrawRequested ---
type WithdrawRequestedOpt func(*WithdrawRequested)

func WithWithdrawAmount(m *money.Money) WithdrawRequestedOpt <span class="cov0" title="0">{
        return func(e *WithdrawRequested) </span><span class="cov0" title="0">{ e.Amount = m }</span>
}

func WithWithdrawTimestamp(ts time.Time) WithdrawRequestedOpt <span class="cov0" title="0">{
        return func(e *WithdrawRequested) </span><span class="cov0" title="0">{ e.Timestamp = ts }</span>
}

func WithWithdrawID(id uuid.UUID) WithdrawRequestedOpt <span class="cov0" title="0">{
        return func(e *WithdrawRequested) </span><span class="cov0" title="0">{ e.ID = id }</span>
}

func WithWithdrawFlowEvent(fe FlowEvent) WithdrawRequestedOpt <span class="cov0" title="0">{
        return func(e *WithdrawRequested) </span><span class="cov0" title="0">{ e.FlowEvent = fe }</span>
}

// WithWithdrawBankAccountNumber sets the bank account number for the withdraw
// request
func WithWithdrawBankAccountNumber(accountNumber string) WithdrawRequestedOpt <span class="cov0" title="0">{
        return func(e *WithdrawRequested) </span><span class="cov0" title="0">{ e.BankAccountNumber = accountNumber }</span>
}

func NewWithdrawRequested(
        userID, accountID, correlationID uuid.UUID,
        opts ...WithdrawRequestedOpt,
) *WithdrawRequested <span class="cov0" title="0">{
        wr := &amp;WithdrawRequested{
                FlowEvent: FlowEvent{
                        ID:            uuid.New(),
                        FlowType:      "withdraw",
                        UserID:        userID,
                        AccountID:     accountID,
                        CorrelationID: correlationID,
                        Timestamp:     time.Now(),
                },
                Amount: money.Zero(money.USD),
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(wr)
        }</span>
        <span class="cov0" title="0">return wr</span>
}

type WithdrawCurrencyConvertedOpt func(*WithdrawCurrencyConverted)

// NewWithdrawCurrencyConverted creates a new WithdrawCurrencyConverted event.
// It takes a CurrencyConverted and combines it into a
// WithdrawCurrencyConverted event.
func NewWithdrawCurrencyConverted(
        cc *CurrencyConverted,
        opts ...WithdrawCurrencyConvertedOpt,
) *WithdrawCurrencyConverted <span class="cov0" title="0">{
        wcc := &amp;WithdrawCurrencyConverted{
                CurrencyConverted: *cc,
        }
        wcc.ID = uuid.New()
        wcc.Timestamp = time.Now()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(wcc)
        }</span>
        <span class="cov0" title="0">return wcc</span>
}

type WithdrawValidatedOpt func(*WithdrawValidated)

// NewWithdrawValidated creates a new WithdrawValidated event.
// It takes a WithdrawCurrencyConverted and returns a new WithdrawValidated
// event.
func NewWithdrawValidated(
        cc *WithdrawCurrencyConverted,
        opts ...WithdrawValidatedOpt,
) *WithdrawValidated <span class="cov0" title="0">{
        wv := &amp;WithdrawValidated{
                WithdrawCurrencyConverted: *cc,
        }
        wv.ID = uuid.New()
        wv.Timestamp = time.Now()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(wv)
        }</span>
        <span class="cov0" title="0">return wv</span>
}

// --- WithdrawFailed ---
type WithdrawFailedOpt func(*WithdrawFailed)

func WithWithdrawFailureReason(reason string) WithdrawFailedOpt <span class="cov0" title="0">{
        return func(wf *WithdrawFailed) </span><span class="cov0" title="0">{ wf.Reason = reason }</span>
}

func NewWithdrawFailed(
        wr *WithdrawRequested,
        reason string,
        opts ...WithdrawFailedOpt,
) *WithdrawFailed <span class="cov0" title="0">{
        wf := &amp;WithdrawFailed{
                WithdrawRequested: *wr,
                Reason:            reason,
        }
        wf.ID = uuid.New()
        wf.Timestamp = time.Now()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(wf)
        }</span>
        <span class="cov0" title="0">return wf</span>
}
</pre>

		<pre class="file" id="file42" style="display: none">package domain

import (
        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/common"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/provider"
)

// Type aliases for backward compatibility

// Account and related
// Account is an alias for account.Account
// Deprecated: Use account.Account directly.
type Account = account.Account

// Transaction represents a financial transaction in the system.
// Deprecated: Use account.Transaction directly.
type Transaction = account.Transaction

// User and related
type User = user.User

// Error aliases for backward compatibility
var (
        // ErrDepositAmountExceedsMaxSafeInt Account errors
        // Deprecated: Use account.ErrDepositAmountExceedsMaxSafeInt directly.
        ErrDepositAmountExceedsMaxSafeInt = account.ErrDepositAmountExceedsMaxSafeInt
        // Deprecated: Use account.ErrTransactionAmountMustBePositive directly.
        ErrTransactionAmountMustBePositive = account.ErrTransactionAmountMustBePositive
        // Deprecated: Use account.ErrInsufficientFunds directly.
        ErrInsufficientFunds = account.ErrInsufficientFunds
        // Deprecated: Use account.ErrAccountNotFound directly.
        ErrAccountNotFound = account.ErrAccountNotFound
        // Deprecated: Use account.ErrInvalidCurrencyCode directly.
        ErrInvalidCurrencyCode = common.ErrInvalidCurrencyCode
        // Deprecated: Use account.ErrUserUnauthorized directly.
        ErrUserUnauthorized = user.ErrUserUnauthorized

        // Currency-related errors
        // Deprecated: Use provider.ErrExchangeRateUnavailable directly.
        ErrExchangeRateUnavailable = provider.ErrExchangeRateUnavailable
        // Deprecated: Use provider.ErrUnsupportedCurrencyPair directly.
        ErrUnsupportedCurrencyPair = provider.ErrUnsupportedCurrencyPair
        // Deprecated: Use provider.ErrExchangeRateExpired directly.
        ErrExchangeRateExpired = provider.ErrExchangeRateExpired
        // Deprecated: Use provider.ErrExchangeRateInvalid directly.
        ErrExchangeRateInvalid = provider.ErrExchangeRateInvalid
)

// ExchangeRate is an alias for provider.ExchangeRate
// Deprecated: Use provider.ExchangeRate directly.
type ConversionInfo = provider.ExchangeRate

// Deprecated: Use provider.ExchangeInfo directly.
type ExchangeRate = provider.ExchangeInfo

// Deprecated: use money.New
func NewMoney(amount float64, currencyCode money.Code) (m *money.Money, err error) <span class="cov0" title="0">{
        return money.New(amount, currencyCode)
}</span>
</pre>

		<pre class="file" id="file43" style="display: none">package user

import (
        "errors"
        "time"

        "github.com/amirasaad/fintech/pkg/utils"
        "github.com/google/uuid"
)

var (
        // ErrUserNotFound is returned when a user cannot be found in the
        // repository.
        ErrUserNotFound = errors.New("user not found")
        // ErrUserUnauthorized is return when user
        ErrUserUnauthorized = errors.New("user unauthorized")
)

// User represents a user in the system.
type User struct {
        ID        uuid.UUID `json:"id"`
        Username  string    `json:"username"`
        Email     string    `json:"email"`
        Password  string    `json:"password"`
        Names     string    `json:"names"`
        CreatedAt time.Time `json:"created"`
        UpdatedAt time.Time `json:"updated"`
}

// New creates a new User with a hashed password and current timestamps.
func New(username, email, password string) (*User, error) <span class="cov8" title="1">{
        if username == "" </span><span class="cov8" title="1">{
                return nil, errors.New("username cannot be empty")
        }</span>
        <span class="cov8" title="1">if email == "" </span><span class="cov0" title="0">{
                return nil, errors.New("email cannot be empty")
        }</span>
        <span class="cov8" title="1">hashedPassword, err := utils.HashPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;User{
                ID:        uuid.New(),
                Username:  username,
                Email:     email,
                Password:  hashedPassword,
                CreatedAt: time.Now().UTC(),
                UpdatedAt: time.Now().UTC(),
        }, nil</span>
}

// NewUserFromData creates a User from raw data (used for DB hydration).
func NewUserFromData(
        id uuid.UUID,
        username, email, password string,
        created, updated time.Time,
) *User <span class="cov0" title="0">{
        return &amp;User{
                ID:        id,
                Username:  username,
                Email:     email,
                Password:  password,
                CreatedAt: created,
                UpdatedAt: updated,
        }
}</span>
</pre>

		<pre class="file" id="file44" style="display: none">package core

import "errors"

// Common errors for exchange operations
var (
        // ErrInvalidRate indicates that an invalid exchange rate was provided
        ErrInvalidRate = errors.New("invalid exchange rate")

        // ErrUnsupportedCurrencyPair indicates that the currency pair is not supported
        ErrUnsupportedCurrencyPair = errors.New("unsupported currency pair")

        // ErrProviderUnavailable indicates that the rate provider is not available
        ErrProviderUnavailable = errors.New("rate provider unavailable")

        // ErrRateNotFound indicates that the requested rate was not found
        ErrRateNotFound = errors.New("exchange rate not found")

        // ErrInvalidAmount indicates that an invalid amount was provided
        ErrInvalidAmount = errors.New("invalid amount")
)

// ProviderError represents an error from a rate provider
type ProviderError struct {
        Provider string
        Err      error
}

func (e *ProviderError) Error() string <span class="cov0" title="0">{
        return "provider " + e.Provider + ": " + e.Err.Error()
}</span>

func (e *ProviderError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// IsProviderError checks if an error is a ProviderError
func IsProviderError(err error) bool <span class="cov0" title="0">{
        _, ok := err.(*ProviderError)
        return ok
}</span>
</pre>

		<pre class="file" id="file45" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/exchange/core"
        "github.com/amirasaad/fintech/pkg/provider"
)

// Service handles currency exchange operations using a provider and cache
type Service struct {
        provider provider.Provider // Single provider that may be a composite
        cache    *provider.Cache   // Optional cache
        logger   *slog.Logger      // Logger for the service
}

// New creates a new exchange service with the given provider and cache
func New(
        provider provider.Provider,
        cache *provider.Cache,
        logger *slog.Logger,
) *Service <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = slog.Default()
        }</span>

        <span class="cov0" title="0">return &amp;Service{
                provider: provider,
                cache:    cache,
                logger:   logger,
        }</span>
}

// Convert converts an amount from one currency to another
func (s *Service) Convert(
        ctx context.Context,
        from, to string,
        amount float64,
) (*core.ConversionResult, error) <span class="cov0" title="0">{
        if amount &lt;= 0 </span><span class="cov0" title="0">{
                return nil, core.ErrInvalidAmount
        }</span>

        <span class="cov0" title="0">rate, err := s.GetRate(ctx, from, to)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get exchange rate: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;core.ConversionResult{
                FromAmount: amount,
                ToAmount:   amount * rate.Value,
                Rate:       rate.Value,
                Source:     rate.Source,
        }, nil</span>
}

// GetRate gets the exchange rate between two currencies
func (s *Service) GetRate(
        ctx context.Context,
        from, to string,
) (*core.Rate, error) <span class="cov0" title="0">{
        // Try cache first
        if s.cache != nil </span><span class="cov0" title="0">{
                if rate, err := s.cache.GetRate(ctx, from, to); err == nil </span><span class="cov0" title="0">{
                        return &amp;core.Rate{
                                From:      from,
                                To:        to,
                                Value:     rate.Rate,
                                Timestamp: rate.Timestamp,
                                Source:    rate.Provider,
                        }, nil
                }</span>
        }

        // Get rate from provider
        <span class="cov0" title="0">rateInfo, err := s.provider.FetchRate(ctx, from, to)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider error: %w", err)
        }</span>

        <span class="cov0" title="0">rate := &amp;core.Rate{
                From:      from,
                To:        to,
                Value:     rateInfo.Rate,
                Timestamp: rateInfo.Timestamp,
                Source:    rateInfo.Provider,
        }

        // Update cache
        if s.cache != nil </span><span class="cov0" title="0">{
                if err := s.cache.StoreRate(ctx, rateInfo); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to cache rate", "error", err)
                }</span>
        }

        <span class="cov0" title="0">return rate, nil</span>
}

// GetRates gets multiple exchange rates in a single request
func (s *Service) GetRates(
        ctx context.Context,
        from string,
        to []string,
) (map[string]*core.Rate, error) <span class="cov0" title="0">{
        if len(to) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("no target currencies provided")
        }</span>

        // Check cache first
        <span class="cov0" title="0">cachedRates := make(map[string]*core.Rate)
        var toFetch []string

        if s.cache != nil </span><span class="cov0" title="0">{
                rates, err := s.cache.BatchGetRates(ctx, from, to)
                if err == nil </span><span class="cov0" title="0">{
                        for currency, rate := range rates </span><span class="cov0" title="0">{
                                if rate != nil </span><span class="cov0" title="0">{
                                        cachedRates[currency] = &amp;core.Rate{
                                                From:      from,
                                                To:        currency,
                                                Value:     rate.Rate,
                                                Timestamp: rate.Timestamp,
                                                Source:    rate.Provider,
                                        }
                                }</span> else<span class="cov0" title="0"> {
                                        toFetch = append(toFetch, currency)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        toFetch = to
                }</span>
        } else<span class="cov0" title="0"> {
                toFetch = to
        }</span>

        // If we have everything cached, return early
        <span class="cov0" title="0">if len(cachedRates) == len(to) </span><span class="cov0" title="0">{
                return cachedRates, nil
        }</span>

        // Fetch missing rates from provider
        <span class="cov0" title="0">fetchedRates := make(map[string]*core.Rate)
        if len(toFetch) &gt; 0 </span><span class="cov0" title="0">{
                rates, err := s.provider.FetchRates(ctx, from, toFetch)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch rates: %w", err)
                }</span>

                // Convert RateInfo to core.Rate and update cache
                <span class="cov0" title="0">for currency, rateInfo := range rates </span><span class="cov0" title="0">{
                        fetchedRates[currency] = &amp;core.Rate{
                                From:      from,
                                To:        currency,
                                Value:     rateInfo.Rate,
                                Timestamp: rateInfo.Timestamp,
                                Source:    rateInfo.Provider,
                        }

                        // Update cache
                        if s.cache != nil </span><span class="cov0" title="0">{
                                if err := s.cache.StoreRate(ctx, rateInfo); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("failed to cache rate", "error", err)
                                }</span>
                        }
                }
        }

        // Merge cached and fetched rates
        <span class="cov0" title="0">result := make(map[string]*core.Rate, len(to))
        for _, currency := range to </span><span class="cov0" title="0">{
                if rate, exists := cachedRates[currency]; exists </span><span class="cov0" title="0">{
                        result[currency] = rate
                }</span> else<span class="cov0" title="0"> if rate, exists := fetchedRates[currency]; exists </span><span class="cov0" title="0">{
                        result[currency] = rate
                }</span> else<span class="cov0" title="0"> {
                        result[currency] = nil // Indicate missing rate
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>

		<pre class="file" id="file46" style="display: none">package deposit

import (
        "context"
        "errors"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/mapper"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/amirasaad/fintech/pkg/repository/account"
)

// HandleCurrencyConverted performs domain validation after currency conversion for deposits.
// Emits DepositBusinessValidated event to trigger payment initiation.
func HandleCurrencyConverted(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) eventbus.HandlerFunc <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                e events.Event,
        ) error </span><span class="cov0" title="0">{
                log := logger.With(
                        "handler", "deposit.HandleCurrencyConverted",
                        "event_type", e.Type(),
                )
                log.Info("🟢 [START] Processing DepositCurrencyConverted event")

                dcc, ok := e.(*events.DepositCurrencyConverted)
                if !ok </span><span class="cov0" title="0">{
                        log.Warn(
                                "🚫 [SKIP] Skipping: unexpected event type",
                                "event", e,
                        )
                        return nil
                }</span>

                <span class="cov0" title="0">log = log.With(
                        "user_id", dcc.UserID,
                        "account_id", dcc.AccountID,
                        "transaction_id", dcc.TransactionID,
                        "correlation_id", dcc.CorrelationID,
                )

                accRepoAny, err := uow.GetRepository((*account.Repository)(nil))
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "Failed to get account repository",
                                "error", err,
                        )
                        return err
                }</span>
                <span class="cov0" title="0">accRepo, ok := accRepoAny.(account.Repository)
                if !ok </span><span class="cov0" title="0">{
                        err = errors.New("invalid account repository type")
                        log.Error(
                                "Invalid account repository type",
                                "type", accRepoAny,
                                "error", err,
                        )
                        return err
                }</span>

                // Get account for validation
                <span class="cov0" title="0">accountID := dcc.AccountID
                userID := dcc.UserID

                // Log detailed information about the event for debugging
                log.Debug(
                        "[DEBUG] Processing DepositCurrencyConverted event",
                        "event_type", fmt.Sprintf("%T", dcc),
                        "transaction_id", dcc.TransactionID,
                        "user_id", userID,
                        "account_id", accountID,
                        "converted_amount", dcc.ConvertedAmount,
                        "has_original_request", dcc.OriginalRequest != nil,
                        "original_request_type", fmt.Sprintf("%T", dcc.OriginalRequest),
                )

                // Check if OriginalRequest is nil
                if dcc.OriginalRequest == nil </span><span class="cov0" title="0">{
                        log.Warn(
                                "[SKIP] Original request is missing",
                                "event_id", dcc.ID,
                        )
                        return nil
                }</span>

                // Type assert the OriginalRequest to DepositRequested
                <span class="cov0" title="0">dr, ok := dcc.OriginalRequest.(*events.DepositRequested)
                if !ok </span><span class="cov0" title="0">{
                        log.Warn(
                                "[SKIP] Unexpected original request type",
                                "original_request_type", fmt.Sprintf("%T", dcc.OriginalRequest),
                        )
                        return nil
                }</span>

                // Get the account
                <span class="cov0" title="0">accRead, err := accRepo.Get(ctx, accountID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warn(
                                "Failed to get account",
                                "error", err,
                                "account_id", accountID,
                        )
                        return fmt.Errorf("failed to get account: %w", err)
                }</span>
                <span class="cov0" title="0">acc, err := mapper.MapAccountReadToDomain(accRead)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "Failed to map account read to domain",
                                "error", err,
                        )
                        return fmt.Errorf("failed to map account read to domain: %w", err)
                }</span>

                // Perform domain validation
                <span class="cov0" title="0">if err := acc.ValidateDeposit(userID, dcc.ConvertedAmount); err != nil </span><span class="cov0" title="0">{
                        log.Warn(
                                "Domain validation failed",
                                "error", err,
                        )
                        // Create the failed event
                        failedEvent := events.NewDepositFailed(dr, err.Error())
                        _ = bus.Emit(ctx, failedEvent)
                        return nil
                }</span>

                <span class="cov0" title="0">dv := events.NewDepositValidated(dcc)
                log.Info(
                        "✅ [SUCCESS] Domain validation passed, emitting",
                        "event_type", dv.Type(),
                )

                if err := bus.Emit(ctx, dv); err != nil </span><span class="cov0" title="0">{
                        log.Warn(
                                "Failed to emit",
                                "event_type", dv.Type(),
                                "error", err,
                        )
                        return fmt.Errorf("failed to emit %s: %w", dv.Type(), err)
                }</span>
                <span class="cov0" title="0">pi := events.NewPaymentInitiated(&amp;dcc.FlowEvent, func(pi *events.PaymentInitiated) </span><span class="cov0" title="0">{
                        pi.TransactionID = dcc.TransactionID
                        pi.Amount = dcc.ConvertedAmount
                        pi.UserID = dcc.UserID
                        pi.AccountID = dcc.AccountID
                        pi.CorrelationID = dcc.CorrelationID
                }</span>)
                <span class="cov0" title="0">log.Info(
                        "Emitting",
                        "event_type", pi.Type(),
                )
                if err := bus.Emit(ctx, pi); err != nil </span><span class="cov0" title="0">{
                        log.Warn(
                                "Failed to emit",
                                "event_type", pi.Type(),
                                "error", err,
                        )
                        return fmt.Errorf("failed to emit %s: %w", pi.Type(), err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>

		<pre class="file" id="file47" style="display: none">package deposit

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/amirasaad/fintech/pkg/repository/account"
        "github.com/amirasaad/fintech/pkg/repository/transaction"
        "github.com/google/uuid"
)

// HandleRequested handles DepositRequested events by validating and persisting the deposit.
// This follows the new event flow pattern:
// HandleRequested -&gt; HandleRequested (validate and persist).
func HandleRequested(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) func(
        ctx context.Context,
        e events.Event,
) error <span class="cov0" title="0">{
        return func(ctx context.Context, e events.Event) error </span><span class="cov0" title="0">{
                log := logger.With(
                        "handler", "deposit.HandleRequested",
                        "event_type", e.Type(),
                )
                log.Info("🟢 [START] Processing DepositRequested event")

                // Type assert to get the deposit request
                dr, ok := e.(*events.DepositRequested)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(
                                "❌ [ERROR] Unexpected event type")
                        return fmt.Errorf("unexpected event type: %s", e.Type())
                }</span>

                <span class="cov0" title="0">log = log.With(
                        "user_id", dr.UserID,
                        "account_id", dr.AccountID,
                        "amount", dr.Amount.String(),
                        "correlation_id", dr.CorrelationID,
                )

                // Validate the deposit request
                if err := dr.Validate(); err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "❌ [ERROR] Deposit validation failed",
                                "error", err,
                        )
                        // Emit failed event
                        df := events.NewDepositFailed(dr, err.Error())
                        if err := bus.Emit(ctx, df); err != nil </span><span class="cov0" title="0">{
                                log.Error("❌ [ERROR] Failed to emit DepositFailed event", "error", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">accountRepoAny, err := uow.GetRepository((*account.Repository)(nil))
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("❌ [ERROR] Failed to get account repository", "error", err)
                        return fmt.Errorf("failed to get account repository: %w", err)
                }</span>
                <span class="cov0" title="0">accountRepo, ok := accountRepoAny.(account.Repository)
                if !ok </span><span class="cov0" title="0">{
                        log.Error("❌ [ERROR] Failed to cast account repository", "error", err)
                        return fmt.Errorf("failed to cast account repository: %w", err)
                }</span>

                <span class="cov0" title="0">account, err := accountRepo.Get(ctx, dr.AccountID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("❌ [ERROR] Failed to get account", "error", err)
                        return fmt.Errorf("failed to get account: %w", err)
                }</span>

                // Create transaction ID if not provided
                <span class="cov0" title="0">if dr.TransactionID == uuid.Nil </span><span class="cov0" title="0">{
                        dr.TransactionID = uuid.New()
                }</span>

                // Persist the deposit transaction
                <span class="cov0" title="0">txID := dr.TransactionID
                if err := persistDepositTransaction(ctx, uow, dr); err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "❌ [ERROR] Failed to persist deposit transaction",
                                "error", err,
                                "transaction_id", txID,
                        )
                        // Emit failed event
                        df := events.NewDepositFailed(dr, fmt.Sprintf("failed to persist transaction: %v", err))
                        if err := bus.Emit(ctx, df); err != nil </span><span class="cov0" title="0">{
                                log.Error(
                                        "❌ [ERROR] Failed to emit DepositFailed event",
                                        "error", err,
                                )
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">log.Info(
                        "✅ [SUCCESS] Deposit validated and persisted",
                        "transaction_id", txID,
                )

                // Emit CurrencyConversionRequested event
                log.Info(
                        "🔧 [DEBUG] Creating CurrencyConversionRequested event",
                        "deposit_request", fmt.Sprintf("%+v", *dr),
                        "original_request_type", fmt.Sprintf("%T", *dr))

                ccr := events.NewCurrencyConversionRequested(
                        dr.FlowEvent,
                        *dr,
                        events.WithConversionAmount(dr.Amount),
                        events.WithConversionTo(money.Code(account.Currency)),
                        events.WithConversionTransactionID(txID),
                )

                log.Info(
                        "🔧 [DEBUG] CurrencyConversionRequested event created",
                        "ccr_original_request_nil", ccr.OriginalRequest == nil,
                        "ccr_original_request_type", fmt.Sprintf("%T", ccr.OriginalRequest),
                        "ccr_transaction_id", ccr.TransactionID,
                )
                if err := bus.Emit(ctx, ccr); err != nil </span><span class="cov0" title="0">{
                        log.Error("❌ [ERROR] Failed to emit CurrencyConversionRequested event", "error", err)
                        return nil
                }</span>

                <span class="cov0" title="0">log.Info(
                        "📤 [Emitted] event",
                        "event_id", ccr.ID,
                        "event_type", ccr.Type(),
                )
                return nil</span>
        }
}

// persistDepositTransaction persists the deposit transaction to the database
func persistDepositTransaction(
        ctx context.Context,
        uow repository.UnitOfWork,
        dr *events.DepositRequested,
) error <span class="cov0" title="0">{
        return uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov0" title="0">{
                // Get the transaction repository
                txRepoAny, err := uow.GetRepository((*transaction.Repository)(nil))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get transaction repository: %w", err)
                }</span>
                <span class="cov0" title="0">txRepo, ok := txRepoAny.(transaction.Repository)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get transaction repository: %w", err)
                }</span>

                // Create the transaction record using domain object
                <span class="cov0" title="0">tx := dto.TransactionCreate{
                        ID:          dr.TransactionID,
                        UserID:      dr.UserID,
                        AccountID:   dr.AccountID,
                        Amount:      dr.Amount.Amount(),
                        Status:      "created",
                        MoneySource: "deposit",
                        Currency:    dr.Amount.Currency().String(),
                        // PaymentID is intentionally omitted to prevent unique constraint violations
                }

                if err := txRepo.Create(ctx, tx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create transaction: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}
</pre>

		<pre class="file" id="file48" style="display: none">package transfer

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/amirasaad/fintech/pkg/repository/account"
        "github.com/amirasaad/fintech/pkg/repository/transaction"
        "github.com/google/uuid"
)

// HandleCompleted handles the final, atomic persistence of a transfer.
func HandleCompleted(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) func(
        ctx context.Context,
        e events.Event,
) error <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                e events.Event,
        ) error </span><span class="cov0" title="0">{
                log := logger.With(
                        "handler", "transfer.HandleCompleted",
                        "event_type", e.Type(),
                )

                // 1. Defensive: Check event type and structure
                te, ok := e.(*events.TransferCompleted)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(
                                "❌ [DISCARD] Unexpected event type",
                                "event", e,
                        )
                        return fmt.Errorf("unexpected event type: %T", e)
                }</span>
                <span class="cov0" title="0">tr, ok := te.OriginalRequest.(*events.TransferRequested)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(
                                "❌ [DISCARD] Unexpected original request type",
                                "event", te,
                        )
                        return fmt.Errorf("unexpected original request type: %T", te)
                }</span>
                <span class="cov0" title="0">log = log.With("correlation_id", tr.CorrelationID)
                log.Info(
                        "🟢 [START] Received event",
                        "event", te,
                )

                if tr.AccountID == uuid.Nil || tr.DestAccountID == uuid.Nil || tr.Amount.IsZero() </span><span class="cov0" title="0">{
                        log.Error(
                                "❌ [DISCARD] Malformed final persistence event",
                                "event", te,
                        )
                        return fmt.Errorf("malformed final persistence event: %v", te)
                }</span>

                // 2. Atomic Final HandleCompleted
                <span class="cov0" title="0">txInID := uuid.New()
                txOutID := tr.TransactionID

                if err := uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov0" title="0">{
                        txRepoAny, err := uow.GetRepository((*transaction.Repository)(nil))
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get transaction repo: %w", err)
                        }</span>
                        <span class="cov0" title="0">txRepo := txRepoAny.(transaction.Repository)

                        accRepoAny, err := uow.GetRepository((*account.Repository)(nil))
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get account repo: %w", err)
                        }</span>
                        <span class="cov0" title="0">accRepo := accRepoAny.(account.Repository)

                        sourceAcc, err := accRepo.Get(ctx, tr.AccountID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not find source account: %w", err)
                        }</span>
                        <span class="cov0" title="0">destAcc, err := accRepo.Get(ctx, tr.DestAccountID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not find destination account: %w", err)
                        }</span>

                        <span class="cov0" title="0">sourceBalance, err := money.New(sourceAcc.Balance, tr.Amount.Currency())
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not create money for source balance: %w", err)
                        }</span>
                        <span class="cov0" title="0">destBalance, err := money.New(destAcc.Balance, tr.Amount.Currency())
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not create money for dest balance: %w", err)
                        }</span>

                        <span class="cov0" title="0">newSourceMoney, err := sourceBalance.Subtract(tr.Amount)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not subtract from source balance: %w", err)
                        }</span>
                        <span class="cov0" title="0">newDestMoney, err := destBalance.Add(tr.Amount)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not add to dest balance: %w", err)
                        }</span>

                        <span class="cov0" title="0">newSourceBalance := newSourceMoney.Amount()
                        newDestBalance := newDestMoney.Amount()

                        if err := accRepo.Update(
                                ctx,
                                tr.AccountID,
                                dto.AccountUpdate{Balance: &amp;newSourceBalance},
                        ); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to debit source account: %w", err)
                        }</span>
                        <span class="cov0" title="0">if err := accRepo.Update(
                                ctx,
                                tr.DestAccountID,
                                dto.AccountUpdate{Balance: &amp;newDestBalance},
                        ); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to credit destination account: %w", err)
                        }</span>

                        <span class="cov0" title="0">completedStatus := "completed"
                        if err := txRepo.Update(
                                ctx,
                                txOutID,
                                dto.TransactionUpdate{Status: &amp;completedStatus},
                        ); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf(
                                        "failed to update transaction status to completed: %w", err,
                                )
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }); err != nil <span class="cov0" title="0">{
                        log.Error(
                                "❌ [ERROR] Final persistence transaction failed",
                                "error", err,
                        )
                        tf := events.NewTransferFailed(tr, "PersistenceFailed: "+err.Error())
                        return bus.Emit(ctx, tf)
                }</span>
                <span class="cov0" title="0">log.Info(
                        "✅ [SUCCESS] Final transfer persistence complete",
                        "tx_out_id", txOutID,
                        "tx_in_id", txInID,
                )

                tc := events.NewTransferCompleted(tr)
                log.Info(
                        "📤 [EMIT] Emitting",
                        "event", tc.Type(),
                )
                return bus.Emit(ctx, tc)</span>
        }
}
</pre>

		<pre class="file" id="file49" style="display: none">package transfer

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/handler/common"
        "github.com/amirasaad/fintech/pkg/mapper"
        "github.com/amirasaad/fintech/pkg/repository"
)

// HandleCurrencyConverted performs domain validation after currency conversion for transfers.
// Emits TransferBusinessValidated event to trigger final persistence.
func HandleCurrencyConverted(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) func(
        ctx context.Context,
        e events.Event,
) error <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                e events.Event,
        ) error </span><span class="cov8" title="1">{
                log := logger.With(
                        "handler", "transfer.HandleCurrencyConverted",
                        "event_type", e.Type(),
                )

                log.Info(
                        "🟢 [HANDLER] HandleCurrencyConverted received event",
                        "event_type", e.Type(),
                )

                // 1. Defensive: Check event type and structure
                tcc, ok := e.(*events.TransferCurrencyConverted)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(
                                "unexpected event type",
                                "event", e,
                        )
                        return fmt.Errorf("unexpected event type: %T", e)
                }</span>

                <span class="cov8" title="1">log = log.With(
                        "user_id", tcc.UserID,
                        "account_id", tcc.AccountID,
                        "transaction_id", tcc.TransactionID,
                        "correlation_id", tcc.CorrelationID,
                )

                // 2. Get account repository
                accRepo, err := common.GetAccountRepository(uow, log)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "failed to get account repository",
                                "error", err,
                        )
                        return err
                }</span>

                // Get source account DTO
                <span class="cov8" title="1">sourceAccDto, err := accRepo.Get(ctx, tcc.AccountID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warn(
                                "source account not found",
                                "account_id", tcc.AccountID,
                                "error", err,
                        )
                        return bus.Emit(ctx, events.NewTransferFailed(
                                tcc.OriginalRequest.(*events.TransferRequested),
                                "source account not found: "+err.Error(),
                        ))
                }</span>

                // Map DTO to domain model
                <span class="cov8" title="1">sourceAcc, err := mapper.MapAccountReadToDomain(sourceAccDto)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "failed to map account read to domain",
                                "error", err,
                        )
                        return fmt.Errorf("failed to map account read to domain: %w", err)
                }</span>

                // Get TransferRequested fields once
                <span class="cov8" title="1">tr, ok := tcc.OriginalRequest.(*events.TransferRequested)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(
                                "unexpected event type",
                                "event", tcc.OriginalRequest,
                        )
                        return fmt.Errorf("unexpected event type: %T", tcc.OriginalRequest)
                }</span>
                // Get destination account DTO
                <span class="cov8" title="1">destAccDto, err := accRepo.Get(ctx, tr.DestAccountID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warn(
                                "destination account not found",
                                "account_id", tr.DestAccountID,
                                "error", err,
                        )
                        return bus.Emit(ctx, events.NewTransferFailed(
                                tr,
                                "destination account not found: "+err.Error(),
                        ))
                }</span>

                // Map DTO to domain model
                <span class="cov8" title="1">destAcc, err := mapper.MapAccountReadToDomain(destAccDto)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "failed to map destination account read to domain",
                                "error", err,
                        )
                        return fmt.Errorf("failed to map destination account read to domain: %w", err)
                }</span>

                // Perform domain validation
                <span class="cov8" title="1">if err := sourceAcc.ValidateTransfer(
                        tcc.UserID,
                        // Pass the user ID of the destination account owner for validation
                        destAcc.UserID,
                        destAcc,
                        tcc.ConvertedAmount,
                ); err != nil </span><span class="cov0" title="0">{
                        log.Warn(
                                "domain validation failed",
                                "reason", err,
                        )
                        return bus.Emit(ctx, events.NewTransferFailed(
                                tr,
                                err.Error(),
                        ))
                }</span>

                // 3. Emit success event
                <span class="cov8" title="1">tbv := events.NewTransferBusinessValidated(
                        tcc,
                )
                log.Info(
                        "✅ [SUCCESS] Domain validation passed, emitting",
                        "event_type", tbv.Type(),
                )

                return bus.Emit(ctx, tbv)</span>
        }
}
</pre>

		<pre class="file" id="file50" style="display: none">package transfer

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/handler/common"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/repository"
)

// HandleRequested handles TransferValidatedEvent,
// creates an initial 'pending' transaction, and triggers conversion.
func HandleRequested(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) func(
        ctx context.Context,
        e events.Event,
) error <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                e events.Event,
        ) error </span><span class="cov8" title="1">{
                log := logger.With(
                        "handler", "HandleRequested",
                        "event_type", e.Type(),
                )

                tr, ok := e.(*events.TransferRequested)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(
                                "❌ [DISCARD] Unexpected event type",
                                "event", e,
                        )
                        return fmt.Errorf("unexpected event type: %T", e)
                }</span>
                <span class="cov8" title="1">log = log.With("correlation_id", tr.CorrelationID)
                log.Info("🟢 [START] Received event", "event", tr)

                if err := tr.Validate(); err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "❌ [DISCARD] Malformed validated event",
                                "error", err,
                        )
                        return err
                }</span>

                // 2. Persist initial transaction (tx_out) atomically
                <span class="cov8" title="1">txID := tr.ID
                var destAccountRead *dto.AccountRead
                err := uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                        txRepo, err := common.GetTransactionRepository(uow, log)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get repo: %w", err)
                        }</span>

                        <span class="cov8" title="1">accountRepo, err := common.GetAccountRepository(uow, log)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get account repo: %w", err)
                        }</span>
                        <span class="cov8" title="1">destAccountRead, err = accountRepo.Get(ctx, tr.DestAccountID)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to get destination account: %w", err)
                        }</span>
                        <span class="cov8" title="1">return txRepo.Create(ctx, dto.TransactionCreate{
                                ID:          txID,
                                UserID:      tr.UserID,
                                AccountID:   tr.AccountID,
                                Amount:      tr.Amount.Negate().Amount(),
                                Currency:    tr.Amount.Currency().String(),
                                Status:      "pending",
                                MoneySource: "transfer",
                        })</span>
                })

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        log.Error("❌ [ERROR] Failed to create initial transaction", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("✅ [SUCCESS] Initial 'pending' transaction created", "transaction_id", txID)

                // 3. Emit event to trigger currency conversion
                ccr := events.NewCurrencyConversionRequested(
                        tr.FlowEvent,
                        tr,
                        events.WithConversionAmount(tr.Amount),
                        events.WithConversionTo(money.Code(destAccountRead.Currency)),
                        events.WithConversionTransactionID(txID),
                )

                log.Info(
                        "📤 [EMIT] Emitting CurrencyConversionRequested",
                        "event", ccr,
                )
                if err := bus.Emit(ctx, ccr); err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "❌ [ERROR] Failed to emit CurrencyConversionRequested",
                                "error", err,
                        )
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>

		<pre class="file" id="file51" style="display: none">package withdraw

import (
        "context"
        "errors"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/handler/common"
        "github.com/amirasaad/fintech/pkg/mapper"
        "github.com/amirasaad/fintech/pkg/repository"
)

// HandleCurrencyConverted performs domain validation after currency conversion for withdrawals.
// Emits WithdrawBusinessValidated event to trigger payment initiation.
func HandleCurrencyConverted(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) func(
        ctx context.Context,
        e events.Event,
) error <span class="cov0" title="0">{
        return func(ctx context.Context, e events.Event) error </span><span class="cov0" title="0">{
                log := logger.With(
                        "handler", "withdraw.CurrencyConverted",
                        "event_type", e.Type(),
                )
                log.Info("🟢 [START] Received event", "event", e)

                wce, ok := e.(*events.WithdrawCurrencyConverted)
                if !ok </span><span class="cov0" title="0">{
                        log.Debug(
                                "🚫 skipping: unexpected event type in WithdrawCurrencyConverted",
                                "event", e,
                        )
                        return nil
                }</span>

                <span class="cov0" title="0">wr, ok := wce.OriginalRequest.(*events.WithdrawRequested)
                if !ok </span><span class="cov0" title="0">{
                        log.Debug(
                                "🚫 skipping: unexpected event type in WithdrawCurrencyConverted",
                                "event", e,
                        )
                        return nil
                }</span>

                <span class="cov0" title="0">log = log.With(
                        "user_id", wce.UserID,
                        "account_id", wce.AccountID,
                        "transaction_id", wce.TransactionID,
                        "correlation_id", wce.CorrelationID,
                )

                if wce.FlowType != "withdraw" </span><span class="cov0" title="0">{
                        log.Debug(
                                "🚫 skipping: not a withdraw flow",
                                "flow_type", wce.FlowType,
                        )
                        return nil
                }</span>

                <span class="cov0" title="0">accRepo, err := common.GetAccountRepository(uow, log)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("invalid account repository type")
                }</span>

                <span class="cov0" title="0">accRead, err := accRepo.Get(ctx, wce.AccountID)
                if err != nil &amp;&amp; !errors.Is(err, account.ErrAccountNotFound) </span><span class="cov0" title="0">{
                        log.Error(
                                "failed to get account",
                                "error", err,
                                "account_id", wce.AccountID,
                        )
                        return err
                }</span>

                <span class="cov0" title="0">if accRead == nil </span><span class="cov0" title="0">{
                        log.Error(
                                "account not found",
                                "account_id", wce.AccountID,
                        )
                        return account.ErrAccountNotFound
                }</span>

                <span class="cov0" title="0">acc, err := mapper.MapAccountReadToDomain(accRead)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "failed to map account read to domain",
                                "error", err,
                        )
                        return err
                }</span>

                // Perform domain validation
                <span class="cov0" title="0">if err := acc.ValidateWithdraw(wce.UserID, wce.ConvertedAmount); err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "domain validation failed",
                                "transaction_id", wce.TransactionID,
                                "error", err,
                                "user_id", wce.UserID,
                                "account_id", wce.AccountID,
                                "amount", wce.ConvertedAmount.String(),
                        )

                        failureEvent := events.NewWithdrawFailed(
                                wr,
                                err.Error(),
                        )
                        return bus.Emit(ctx, failureEvent)
                }</span>

                <span class="cov0" title="0">log.Info(
                        "✅ [SUCCESS] Domain validation passed, emitting WithdrawBusinessValidated",
                        "user_id", wce.UserID,
                        "account_id", wce.AccountID,
                        "amount", wce.ConvertedAmount.Amount(),
                        "currency", wce.ConvertedAmount.Currency().String(),
                        "correlation_id", wce.CorrelationID,
                )

                // Emit WithdrawBusinessValidated event
                wv := events.NewWithdrawValidated(wce)

                log.Info(
                        "📤 [EMIT] Emitting",
                        "event", wv.Type(),
                        "correlation_id", wce.CorrelationID.String(),
                )
                return bus.Emit(ctx, wv)</span>
        }
}
</pre>

		<pre class="file" id="file52" style="display: none">package withdraw

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/handler/common"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
)

// HandleRequested handles WithdrawRequested events by validating and persisting the withdraw.
// This follows the new event flow pattern: Requested -&gt; HandleRequested (validate and persist).
func HandleRequested(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) func(
        ctx context.Context,
        e events.Event,
) error <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                e events.Event,
        ) error </span><span class="cov0" title="0">{
                log := logger.With(
                        "handler", "withdraw.HandleRequested",
                        "event_type", e.Type(),
                )
                log.Info("🟢 [START] Processing WithdrawRequested event")

                // Type assert to get the withdraw request
                wr, ok := e.(*events.WithdrawRequested)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(
                                "❌ [ERROR] Unexpected event type",
                                "expected", "WithdrawRequested",
                                "got", e.Type(),
                        )
                        return fmt.Errorf("unexpected event type: %s", e.Type())
                }</span>

                <span class="cov0" title="0">log = log.With(
                        "user_id", wr.UserID,
                        "account_id", wr.AccountID,
                        "amount", wr.Amount.String(),
                        "correlation_id", wr.CorrelationID,
                )

                // Validate the withdraw request
                if err := wr.Validate(); err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "❌ [ERROR] Withdraw validation failed",
                                "error", err,
                        )
                        // Emit failed event
                        failedEvent := events.NewWithdrawFailed(
                                wr,
                                err.Error(),
                        )
                        if err := bus.Emit(ctx, failedEvent); err != nil </span><span class="cov0" title="0">{
                                log.Error(
                                        "❌ [ERROR] Failed to emit WithdrawFailed event",
                                        "error", err,
                                )
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                // Create transaction ID
                <span class="cov0" title="0">txID := uuid.New()

                // Persist the withdraw transaction
                if err := persistWithdrawTransaction(ctx, uow, wr, txID, log); err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "❌ [ERROR] Failed to persist withdraw transaction",
                                "error", err,
                                "transaction_id", txID,
                        )
                        // Emit failed event
                        failedEvent := events.NewWithdrawFailed(
                                wr,
                                fmt.Sprintf("failed to persist transaction: %v", err),
                        )
                        if err := bus.Emit(ctx, failedEvent); err != nil </span><span class="cov0" title="0">{
                                log.Error(
                                        "❌ [ERROR] Failed to emit WithdrawFailed event",
                                        "error", err,
                                )
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">log.Info("✅ [SUCCESS] Withdraw validated and persisted", "transaction_id", txID)

                // Emit CurrencyConversionRequested event
                ccr := events.NewCurrencyConversionRequested(
                        wr.FlowEvent,
                        wr,
                        events.WithConversionAmount(wr.Amount),
                        events.WithConversionTo(money.Code("USD")),
                )

                if err := bus.Emit(ctx, ccr); err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "❌ [ERROR] Failed to emit CurrencyConversionRequested event",
                                "error", err,
                        )
                        return fmt.Errorf(
                                "failed to emit CurrencyConversionRequested event: %w", err,
                        )
                }</span>

                <span class="cov0" title="0">log.Info(
                        "📤 [EMITTED] event",
                        "event_id", ccr.ID,
                        "event_type", ccr.Type(),
                )
                return nil</span>
        }
}

// persistWithdrawTransaction persists the withdraw transaction to the database
func persistWithdrawTransaction(
        ctx context.Context,
        uow repository.UnitOfWork,
        wr *events.WithdrawRequested,
        txID uuid.UUID,
        log *slog.Logger,
) error <span class="cov0" title="0">{
        return uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov0" title="0">{
                // Get the transaction repository
                txRepo, err := common.GetTransactionRepository(uow, log)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get transaction repository: %w", err)
                }</span>

                // Create the transaction record using DTO
                <span class="cov0" title="0">txCreate := dto.TransactionCreate{
                        ID:          txID,
                        UserID:      wr.UserID,
                        AccountID:   wr.AccountID,
                        Amount:      wr.Amount.Amount(),
                        Currency:    wr.Amount.Currency().String(),
                        Status:      "created",
                        MoneySource: "withdraw",
                }

                if err := txRepo.Create(ctx, txCreate); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create transaction: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}
</pre>

		<pre class="file" id="file53" style="display: none">package common

import (
        "errors"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/amirasaad/fintech/pkg/repository/account"
        "github.com/amirasaad/fintech/pkg/repository/transaction"
)

var ErrInvalidRepositoryType = errors.New("invalid repository type")

func GetAccountRepository(
        uow repository.UnitOfWork,
        log *slog.Logger,
) (
        account.Repository,
        error,
) <span class="cov0" title="0">{
        accRepoAny, err := uow.GetRepository(
                (*account.Repository)(nil),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "failed to get account repository",
                        "error", err,
                )
                return nil, err
        }</span>
        <span class="cov0" title="0">if accRepo, ok := accRepoAny.(account.Repository); ok </span><span class="cov0" title="0">{
                return accRepo, nil
        }</span>
        <span class="cov0" title="0">return nil, ErrInvalidRepositoryType</span>
}

func GetTransactionRepository(
        uow repository.UnitOfWork,
        log *slog.Logger,
) (
        transaction.Repository,
        error,
) <span class="cov0" title="0">{
        txRepoAny, err := uow.GetRepository(
                (*transaction.Repository)(nil),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Error(
                        "failed to get transaction repository",
                        "error", err,
                )
                return nil, err
        }</span>
        <span class="cov0" title="0">if txRepo, ok := txRepoAny.(transaction.Repository); ok </span><span class="cov0" title="0">{

                return txRepo, nil
        }</span>
        <span class="cov0" title="0">return nil, ErrInvalidRepositoryType</span>
}
</pre>

		<pre class="file" id="file54" style="display: none">// Package conversion handles currency conversion events and persistence logic.
package conversion

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/handler/common"
        "github.com/google/uuid"

        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/repository"
)

// HandleCurrencyConverted persists CurrencyConverted events.
func HandleCurrencyConverted(
        uow repository.UnitOfWork,
        logger *slog.Logger) func(
        context.Context,
        events.Event,
) error <span class="cov8" title="1">{
        return func(ctx context.Context, e events.Event) error </span><span class="cov8" title="1">{
                log := logger.With(
                        "handler", "conversion.HandleCurrencyConverted",
                        "event_type", e.Type(),
                )
                log.Info("🟢 [START] Event received event")

                cc, ok := e.(*events.CurrencyConverted)
                if !ok </span><span class="cov8" title="1">{
                        log.Warn("unexpected event",
                                "event", e,
                                "event_type", fmt.Sprintf("%T", e),
                        )
                        // return nil to skip processing
                        return nil
                }</span>

                // Validate TransactionID
                <span class="cov8" title="1">if cc.TransactionID == uuid.Nil </span><span class="cov8" title="1">{
                        log.Warn("TransactionID is nil in CurrencyConverted event")
                        return nil
                }</span>

                <span class="cov8" title="1">log.Info(
                        "💾 [PROGRESS] persisting conversion data",
                        "transaction_id", cc.TransactionID,
                )

                // Validate that we have the required data before persisting
                if cc.ConversionInfo == nil </span><span class="cov8" title="1">{
                        log.Warn("ConversionInfo is nil, cannot persist conversion data")
                        return nil
                }</span>

                // Persist conversion result (stubbed for now)
                <span class="cov8" title="1">if err := uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                        transactionRepo, err := common.GetTransactionRepository(uow, log)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // Create money object for transaction amount
                        <span class="cov8" title="1">amount := cc.ConvertedAmount.Amount()
                        currency := cc.ConvertedAmount.Currency().String()

                        return transactionRepo.Update(ctx, cc.TransactionID, dto.TransactionUpdate{
                                OriginalAmount:   &amp;cc.ConversionInfo.OriginalAmount,
                                Amount:           &amp;amount,
                                Currency:         &amp;currency,
                                OriginalCurrency: &amp;cc.ConversionInfo.OriginalCurrency,
                                TargetCurrency:   &amp;cc.ConversionInfo.ConvertedCurrency,
                                ConversionRate:   &amp;cc.ConversionInfo.ConversionRate,
                        })</span>
                }); err != nil <span class="cov8" title="1">{
                        log.Error("Failed to persist conversion data", "error", err)
                        return err
                }</span>

                <span class="cov8" title="1">log.Info(
                        "✅ [SUCCESS] conversion persisted",
                        "transaction_id", cc.TransactionID,
                )
                return nil</span>
                // TODO: apply conversion fee
        }
}
</pre>

		<pre class="file" id="file55" style="display: none">package conversion

import (
        "github.com/amirasaad/fintech/pkg/domain/events"
)

// DepositEventFactory creates a DepositCurrencyConverted event from a CurrencyConverted event.
type DepositEventFactory struct{}

// CreateNextEvent creates DepositCurrencyConverted with converted event
func (f *DepositEventFactory) CreateNextEvent(
        cc *events.CurrencyConverted,
) events.Event <span class="cov8" title="1">{
        return events.NewDepositCurrencyConverted(cc)
}</span>

// WithdrawEventFactory creates a WithdrawCurrencyConverted event from a CurrencyConverted event.
type WithdrawEventFactory struct{}

// CreateNextEvent creates WithdrawCurrencyConverted with converted event
func (f *WithdrawEventFactory) CreateNextEvent(
        cc *events.CurrencyConverted,
) events.Event <span class="cov8" title="1">{
        return events.NewWithdrawCurrencyConverted(cc)
}</span>

// TransferEventFactory creates a TransferCurrencyConverted event from a CurrencyConverted event.
type TransferEventFactory struct{}

// CreateNextEvent creates TransferCurrencyConverted with converted event
func (f *TransferEventFactory) CreateNextEvent(
        cc *events.CurrencyConverted,
) events.Event <span class="cov8" title="1">{
        return events.NewTransferCurrencyConverted(cc)
}</span>
</pre>

		<pre class="file" id="file56" style="display: none">// Package conversion handles currency conversion events and logic.
package conversion

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/amirasaad/fintech/pkg/registry"
        "github.com/amirasaad/fintech/pkg/service/exchange"
)

// HandleRequested processes ConversionRequestedEvent and
// delegates to a flow-specific factory to create the next event.
func HandleRequested(
        bus eventbus.Bus,
        exchangeRegistry registry.Provider,
        exchangeRateProvider provider.ExchangeRate,
        logger *slog.Logger,
        factories map[string]EventFactory,
) func(ctx context.Context, e events.Event) error <span class="cov8" title="1">{
        return func(ctx context.Context, e events.Event) error </span><span class="cov8" title="1">{
                log := logger.With(
                        "handler", "Conversion.HandleRequested",
                        "event_type", e.Type(),
                )
                log.Info("🟢 [START] Event received")

                ccr, ok := e.(*events.CurrencyConversionRequested)
                if !ok </span><span class="cov8" title="1">{
                        log.Error(
                                "Unexpected event type",
                                "event", e,
                        )
                        return fmt.Errorf("unexpected event type %T", e)
                }</span>

                <span class="cov8" title="1">log.Debug(
                        "ConversionRequestedEvent details",
                        "event", ccr,
                )
                // Use the factory map to get the correct event factory for the flow type.
                factory, found := factories[ccr.FlowType]
                if !found </span><span class="cov8" title="1">{
                        log.Error(
                                "Unknown flow type in ConversionRequestedEvent, discarding",
                                "flow_type", ccr.FlowType,
                        )
                        return fmt.Errorf("unknown flow type %s", ccr.FlowType)
                }</span>

                <span class="cov8" title="1">srv := exchange.New(exchangeRegistry, exchangeRateProvider, log)

                convertedMoney,
                        convInfo,
                        err := srv.
                        Convert(
                                ctx,
                                ccr.Amount,
                                ccr.To,
                        )
                if err != nil </span><span class="cov8" title="1">{
                        log.Error(
                                "Failed to convert currency",
                                "error", err,
                                "event_type", ccr.Type(),
                                "event_id", ccr.ID,
                        )
                        return err
                }</span>
                // Log OriginalRequest details for debugging
                <span class="cov8" title="1">log.Debug(
                        "[DEBUG] Creating CurrencyConverted event",
                        "original_request_type", fmt.Sprintf("%T", ccr.OriginalRequest),
                        "original_request_nil", ccr.OriginalRequest == nil,
                        "transaction_id", ccr.TransactionID,
                )

                cc := events.NewCurrencyConverted(
                        ccr,
                        func(cc *events.CurrencyConverted) </span><span class="cov8" title="1">{
                                cc.ConvertedAmount = convertedMoney
                                cc.ConversionInfo = convInfo
                                cc.TransactionID = ccr.TransactionID
                                // Ensure OriginalRequest is preserved
                                cc.OriginalRequest = ccr.OriginalRequest
                        }</span>,
                )

                <span class="cov8" title="1">log.Info(
                        "🔄 [PROCESS] Conversion completed successfully",
                        "amount", ccr.Amount,
                        "to", convertedMoney,
                )
                log.Info("📤 Emitting ", "event_type", cc.Type(), "event_id", cc.ID)
                if err = bus.Emit(ctx, cc); err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "Failed to emit done",
                                "error", err,
                                "event_type", cc.Type(),
                                "event_id", cc.ID,
                        )
                        return err
                }</span>

                // Delegate the creation of the next event to the factory.
                <span class="cov8" title="1">nextEvent := factory.CreateNextEvent(cc)
                log.Info(
                        "✅ Created next event",
                        "event_type", nextEvent.Type(),
                        "event_id", ccr.ID,
                        "correlation_id", ccr.CorrelationID,
                )
                log.Debug(
                        "[DEBUG] Next event details",
                        "event", nextEvent,
                        "event_type", fmt.Sprintf("%T", nextEvent),
                        "correlation_id", ccr.CorrelationID,
                )
                log.Info("📤 Emitting ", "event_type", nextEvent.Type())
                // Emit the next event in the flow
                if err := bus.Emit(ctx, nextEvent); err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "Failed to emit next event",
                                "error", err,
                                "event_type", nextEvent.Type(),
                                "event_id", ccr.ID,
                                "correlation_id", ccr.CorrelationID,
                        )
                        return fmt.Errorf("failed to emit next event: %w", err)
                }</span>

                <span class="cov8" title="1">log.Info(
                        "✅ Successfully emitted next event",
                        "event_type", nextEvent.Type(),
                        "event_id", ccr.ID,
                        "correlation_id", ccr.CorrelationID,
                )
                return nil</span>
        }
}
</pre>

		<pre class="file" id="file57" style="display: none">package conversion

import (
        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/google/uuid"
)

// NewValidConversionRequestedEvent returns a fully valid ConversionRequestedEvent for use in tests.
func NewValidConversionRequestedEvent(
        flow events.FlowEvent,
        transactionID uuid.UUID,
        amount money.Money,
        to string,
) *events.CurrencyConversionRequested <span class="cov0" title="0">{
        // Create the event using the factory function with options
        event := events.NewCurrencyConversionRequested(
                flow,
                nil,
                events.WithConversionAmount(&amp;amount),
                events.WithConversionTo(money.Code(to)),
                events.WithConversionTransactionID(transactionID),
        )

        return event
}</span>

// NewValidConversionInfo returns a fully valid Info for use in tests.
func NewValidConversionInfo(
        originalAmount, convertedAmount float64,
        originalCurrency, convertedCurrency string,
        rate float64,
) *provider.ExchangeInfo <span class="cov0" title="0">{
        return &amp;provider.ExchangeInfo{
                OriginalAmount:    originalAmount,
                OriginalCurrency:  originalCurrency,
                ConvertedAmount:   convertedAmount,
                ConvertedCurrency: convertedCurrency,
                ConversionRate:    rate,
        }
}</span>
</pre>

		<pre class="file" id="file58" style="display: none">package fees

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/handler/common"
        "github.com/amirasaad/fintech/pkg/repository"
)

// HandleCalculated handles FeesCalculated events.
// It updates the transaction with the calculated fees and deducts them from the account balance.
func HandleCalculated(
        uow repository.UnitOfWork,
        logger *slog.Logger,
) eventbus.HandlerFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                e events.Event,
        ) error </span><span class="cov8" title="1">{
                log := logger.With(
                        "handler", "fees.HandleCalculated",
                        "event_type", e.Type(),
                )
                log.Info("🟢 [START] Processing FeesCalculated event")

                // Type assert to get the FeesCalculated event
                fc, ok := e.(*events.FeesCalculated)
                if !ok </span><span class="cov0" title="0">{
                        err := fmt.Errorf("unexpected event type: %s", e.Type())
                        log.Error("unexpected event type", "error", err)
                        return err
                }</span>

                <span class="cov8" title="1">log = log.With(
                        "transaction_id", fc.TransactionID,
                        "event_id", fc.ID,
                        "fee_amount", fc.Fee.Amount,
                )

                if err := uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                        // Get transaction repository
                        txRepo, err := common.GetTransactionRepository(uow, log)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(
                                        "failed to get transaction repository", "error", err)
                                return fmt.Errorf("failed to get transaction repository: %w", err)
                        }</span>

                        // Get account repository
                        <span class="cov8" title="1">accRepo, err := common.GetAccountRepository(uow, log)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(
                                        "failed to get account repository", "error", err)
                                return fmt.Errorf("failed to get account repository: %w", err)
                        }</span>

                        // Create fee calculator and apply fees
                        <span class="cov8" title="1">calculator := NewFeeCalculator(txRepo, accRepo, log)
                        if err := calculator.ApplyFees(ctx, fc.TransactionID, fc.Fee); err != nil </span><span class="cov8" title="1">{
                                log.Error("failed to apply fees", "error", err)
                                return fmt.Errorf("failed to apply fees: %w", err)
                        }</span>

                        <span class="cov8" title="1">log.Info("✅ Successfully processed fee calculation")
                        return nil</span>
                }); err != nil <span class="cov8" title="1">{
                        log.Error("failed to process FeesCalculated event", "error", err)
                        return err
                }</span>

                <span class="cov8" title="1">log.Info("🟢 [END] Processing FeesCalculated event")
                return nil</span>
        }
}
</pre>

		<pre class="file" id="file59" style="display: none">package fees

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/mapper"
        "github.com/amirasaad/fintech/pkg/money"
        repoaccount "github.com/amirasaad/fintech/pkg/repository/account"
        repotransaction "github.com/amirasaad/fintech/pkg/repository/transaction"
        "github.com/google/uuid"
)

// FeeCalculator handles fee calculation and application to transactions and accounts
type FeeCalculator struct {
        txRepo  repotransaction.Repository
        accRepo repoaccount.Repository
        logger  *slog.Logger
}

// NewFeeCalculator creates a new FeeCalculator instance
// Returns nil if any of the required parameters are nil
func NewFeeCalculator(
        txRepo repotransaction.Repository,
        accRepo repoaccount.Repository,
        logger *slog.Logger,
) *FeeCalculator <span class="cov8" title="1">{
        if txRepo == nil || accRepo == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if logger == nil </span><span class="cov8" title="1">{
                logger = slog.Default()
        }</span>

        <span class="cov8" title="1">return &amp;FeeCalculator{
                txRepo:  txRepo,
                accRepo: accRepo,
                logger:  logger,
        }</span>
}

// ApplyFees applies the calculated fees to a transaction and updates the account balance
func (fc *FeeCalculator) ApplyFees(
        ctx context.Context,
        transactionID uuid.UUID,
        fee account.Fee,
) error <span class="cov8" title="1">{
        // Get the transaction
        tx, err := fc.txRepo.Get(ctx, transactionID)
        if err != nil </span><span class="cov8" title="1">{
                fc.logger.Error("failed to get transaction", "error", err, "transaction_id", transactionID)
                return err
        }</span>

        // Update transaction with new fee
        <span class="cov8" title="1">if err := fc.updateTransactionFee(ctx, tx, fee); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update account balance with fee deduction
        <span class="cov8" title="1">if err := fc.updateAccountBalance(ctx, tx.AccountID, fee.Amount); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// updateTransactionFee updates a transaction with the calculated fee
func (fc *FeeCalculator) updateTransactionFee(
        ctx context.Context,
        tx *dto.TransactionRead,
        fee account.Fee,
) error <span class="cov8" title="1">{
        // Validate currency is set
        if tx.Currency == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("transaction %s has no currency set", tx.ID)
                fc.logger.Error("transaction has no currency",
                        "error", err,
                        "transaction_id", tx.ID,
                )
                return err
        }</span>

        // Convert existing fee to money type
        <span class="cov8" title="1">txFee, err := money.New(tx.Fee, money.Code(tx.Currency))
        if err != nil </span><span class="cov0" title="0">{
                fc.logger.Error("invalid transaction fee amount",
                        "error", err,
                        "transaction_id", tx.ID,
                        "fee", tx.Fee,
                        "currency", tx.Currency,
                )
                return fmt.Errorf("invalid transaction fee amount: %w", err)
        }</span>

        // Add the new fee
        <span class="cov8" title="1">totalFee, err := txFee.Add(fee.Amount)
        if err != nil </span><span class="cov0" title="0">{
                fc.logger.Error("failed to add fees",
                        "error", err,
                        "transaction_id", tx.ID,
                        "existing_fee", txFee,
                        "new_fee", fee.Amount,
                )
                return fmt.Errorf("failed to add fees: %w", err)
        }</span>

        // Update the transaction
        <span class="cov8" title="1">totalFeeAmount := totalFee.Amount()
        updateTx := dto.TransactionUpdate{Fee: &amp;totalFeeAmount}

        if err := fc.txRepo.Update(ctx, tx.ID, updateTx); err != nil </span><span class="cov0" title="0">{
                fc.logger.Error("failed to update transaction with fees",
                        "error", err,
                        "transaction_id", tx.ID,
                        "fee", fee.Amount,
                )
                return fmt.Errorf("failed to update transaction: %w", err)
        }</span>

        <span class="cov8" title="1">fc.logger.Info("updated transaction with fee",
                "transaction_id", tx.ID,
                "total_fee", totalFee,
        )
        return nil</span>
}

// updateAccountBalance updates an account balance by deducting the fee
func (fc *FeeCalculator) updateAccountBalance(
        ctx context.Context,
        accountID uuid.UUID,
        feeAmount *money.Money,
) error <span class="cov8" title="1">{
        // Get the account
        acc, err := fc.accRepo.Get(ctx, accountID)
        if err != nil </span><span class="cov8" title="1">{
                fc.logger.Error("failed to get account", "error", err, "account_id", accountID)
                return err
        }</span>

        // Convert to domain model to use money operations
        <span class="cov8" title="1">domainAcc, err := mapper.MapAccountReadToDomain(acc)
        if err != nil </span><span class="cov0" title="0">{
                fc.logger.Error("error creating account from dto", "error", err, "account_id", accountID)
                return err
        }</span>

        // Calculate new balance
        <span class="cov8" title="1">newBalance, err := domainAcc.Balance.Subtract(feeAmount)
        if err != nil </span><span class="cov0" title="0">{
                fc.logger.Error("failed to subtract fee",
                        "fee", feeAmount,
                        "current_balance", domainAcc.Balance,
                        "account_id", accountID,
                )
                return fmt.Errorf("failed to subtract fee from balance: %w", err)
        }</span>

        // Update account balance
        <span class="cov8" title="1">balanceAmount := newBalance.Amount()
        if err := fc.accRepo.Update(
                ctx,
                acc.ID,
                dto.AccountUpdate{Balance: &amp;balanceAmount},
        ); err != nil </span><span class="cov8" title="1">{
                fc.logger.Error("failed to update account balance",
                        "error", err,
                        "account_id", accountID,
                        "new_balance", balanceAmount,
                )
                return err
        }</span>

        <span class="cov8" title="1">fc.logger.Info("updated account balance with fee deduction",
                "account_id", accountID,
                "fee_deducted", feeAmount,
                "new_balance", balanceAmount,
        )
        return nil</span>
}
</pre>

		<pre class="file" id="file60" style="display: none">package payment

import (
        "context"
        "errors"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/handler/common"
        "github.com/amirasaad/fintech/pkg/mapper"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

// ErrInvalidRepositoryType Define custom error for invalid repository type

// HandleCompleted handles PaymentCompletedEvent,
// updates the transaction status in the DB, and publishes a follow-up event if needed.
func HandleCompleted(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) func(
        ctx context.Context,
        e events.Event,
) error <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                e events.Event,
        ) error </span><span class="cov8" title="1">{
                log := logger.With(
                        "handler", "payment.HandleCompleted",
                        "event_type", e.Type(),
                )
                log.Info(
                        "🟢 [START] HandleCompleted received event",
                        "event_type", e.Type(),
                )
                pc, ok := e.(*events.PaymentCompleted)
                if !ok </span><span class="cov8" title="1">{
                        log.Error(
                                "Skipping unexpected event type",
                                "event", e,
                        )
                        return nil
                }</span>
                <span class="cov8" title="1">log = log.With(
                        "user_id", pc.UserID,
                        "account_id", pc.AccountID,
                        "payment_id", *pc.PaymentID,
                        "transaction_id", pc.TransactionID,
                )
                if err := uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                        accRepo, err := common.GetAccountRepository(uow, log)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">txRepo, err := common.GetTransactionRepository(uow, log)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("failed to get transaction repository", "error", err)
                                return err
                        }</span>
                        <span class="cov8" title="1">if pc.PaymentID == nil </span><span class="cov0" title="0">{
                                log.Error("payment ID is nil")
                                return fmt.Errorf("payment ID is nil")
                        }</span>

                        // First try to get by payment ID
                        <span class="cov8" title="1">tx, err := txRepo.GetByPaymentID(ctx, *pc.PaymentID)
                        if err != nil </span><span class="cov8" title="1">{
                                // If not found by payment ID, try to get by transaction ID
                                if errors.Is(err, gorm.ErrRecordNotFound) &amp;&amp; pc.TransactionID != uuid.Nil </span><span class="cov0" title="0">{
                                        tx, err = txRepo.Get(ctx, pc.TransactionID)
                                }</span>

                                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                        log.Error(
                                                "failed to get transaction by payment ID or transaction ID",
                                                "payment_id", *pc.PaymentID,
                                                "transaction_id", pc.TransactionID,
                                                "error", err,
                                        )
                                        return fmt.Errorf("failed to find transaction: %w", err)
                                }</span>

                                // Update the transaction with the payment ID if it wasn't set
                                <span class="cov0" title="0">if tx.PaymentID == nil || *tx.PaymentID != *pc.PaymentID </span><span class="cov0" title="0">{
                                        update := dto.TransactionUpdate{
                                                PaymentID: pc.PaymentID,
                                        }
                                        if err := txRepo.Update(ctx, tx.ID, update); err != nil </span><span class="cov0" title="0">{
                                                log.Error(
                                                        "failed to update transaction with payment ID",
                                                        "transaction_id", tx.ID,
                                                        "payment_id", pc.PaymentID,
                                                        "error", err,
                                                )
                                                return fmt.Errorf("failed to update transaction: %w", err)
                                        }</span>
                                        <span class="cov0" title="0">tx.PaymentID = pc.PaymentID</span>
                                }
                        }
                        <span class="cov8" title="1">log = log.With(
                                "transaction_id", tx.ID,
                                "user_id", tx.UserID,
                        )
                        acc, err := accRepo.Get(ctx, tx.AccountID)
                        if err != nil </span><span class="cov8" title="1">{
                                log.Error(
                                        "failed to get account",
                                        "error", err,
                                )
                                return err
                        }</span>
                        <span class="cov8" title="1">domainAcc, err := mapper.MapAccountReadToDomain(acc)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(
                                        "failed to map account to domain",
                                        "error", err,
                                )
                                return err
                        }</span>

                        // Log provider fee details before calculation
                        <span class="cov8" title="1">newBalance, err := domainAcc.Balance.Add(pc.Amount)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(
                                        "failed to add net transaction amount to balance",
                                        "error", err,
                                )
                                return err
                        }</span>
                        <span class="cov8" title="1">oldStatus := tx.Status
                        status := string(account.TransactionStatusCompleted)
                        tx.Status = status

                        // Store the gross amount in the transaction
                        amount := pc.Amount.Amount()
                        currency := pc.Amount.Currency().String()
                        balance := newBalance.Amount()
                        fee := pc.ProviderFee.Amount.Amount()
                        log.Info("💸 Captured provider fee for transaction", "fee_cents", fee)

                        update := dto.TransactionUpdate{
                                Status:   &amp;status,
                                Amount:   &amp;amount,
                                Currency: &amp;currency,
                                Balance:  &amp;balance,
                                Fee:      &amp;fee, // Store the fee with the transaction
                        }

                        if err = txRepo.Update(ctx, tx.ID, update); err != nil </span><span class="cov0" title="0">{
                                log.Error(
                                        "failed to update transaction status",
                                        "error", err,
                                )
                                return err
                        }</span>

                        <span class="cov8" title="1">log.Info(
                                "✅ [SUCCESS] transaction status updated",
                                "old_status", oldStatus,
                                "new_status", tx.Status,
                        )

                        f64Balance := newBalance.Amount()
                        if err := accRepo.Update(
                                ctx,
                                tx.AccountID,
                                dto.AccountUpdate{Balance: &amp;f64Balance},
                        ); err != nil </span><span class="cov0" title="0">{
                                log.Error(
                                        "failed to update account balance",
                                        "error", err,
                                )
                                return err
                        }</span>

                        <span class="cov8" title="1">log.Info(
                                "✅ [SUCCESS] account balance updated",
                                "account_id", acc.ID,
                                "new_balance", newBalance,
                                "balance", domainAcc.Balance,
                        )

                        log.Info(
                                "✅ [SUCCESS] emitted FeesCalculated event",
                                "transaction_id", tx.ID, "provider_fee", pc.ProviderFee)
                        return nil</span>
                }); err != nil <span class="cov8" title="1">{
                        log.Error(
                                "uow.Do failed",
                                "error", err,
                        )
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>

		<pre class="file" id="file61" style="display: none">package payment

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/handler/common"
        "github.com/amirasaad/fintech/pkg/repository"
)

// HandleFailed handles the PaymentFailedEvent by updating the transaction status to "failed"
func HandleFailed(
        bus eventbus.Bus,
        uow repository.UnitOfWork,
        logger *slog.Logger,
) eventbus.HandlerFunc <span class="cov8" title="1">{
        return func(ctx context.Context, event events.Event) error </span><span class="cov8" title="1">{
                log := logger.With("handler", "payment.HandleFailed", "event_type", event.Type())
                log.Info("handling payment failed event")

                // Check if the event is a PaymentFailed event
                pf, ok := event.(*events.PaymentFailed)
                if !ok </span><span class="cov8" title="1">{
                        err := fmt.Errorf("expected PaymentFailed event, got %T", event)
                        log.Error("invalid event type", "error", err)
                        return err
                }</span>

                // Use the transaction ID from the event
                <span class="cov8" title="1">txID := pf.TransactionID
                log = log.With("transaction_id", txID, "payment_id", pf.PaymentID)

                // Get the transaction repository
                txRepo, err := common.GetTransactionRepository(uow, log)
                if err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("failed to get transaction repository: %w", err)
                        log.Error("repository error", "error", err)
                        return err
                }</span>

                // Update the transaction status to failed
                <span class="cov8" title="1">status := string(account.TransactionStatusFailed)
                updateErr := txRepo.Update(ctx, txID, dto.TransactionUpdate{
                        PaymentID: pf.PaymentID, // Update to handle PaymentID as a pointer
                        Status:    &amp;status,
                })

                if updateErr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("failed to update transaction status: %w", updateErr)
                        log.Error("update error", "error", err)
                        return err
                }</span>

                // Commit the transaction
                <span class="cov8" title="1">if err := uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov0" title="0">{
                        log.Info("committing transaction update")
                        return nil
                }</span>); err != nil <span class="cov8" title="1">{
                        err = fmt.Errorf("failed to commit transaction: %w", err)
                        log.Error("commit error", "error", err)
                        return err
                }</span>

                <span class="cov8" title="1">log.Info("successfully processed payment failed event")
                return nil</span>
        }
}
</pre>

		<pre class="file" id="file62" style="display: none">package payment

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "sync"

        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/provider"
)

var processedPaymentInitiated sync.Map // map[string]struct{} for idempotency

// HandleInitiated handles DepositBusinessValidatedEvent and initiates payment for deposits.
func HandleInitiated(
        bus eventbus.Bus,
        paymentProvider provider.Payment,
        logger *slog.Logger,
) eventbus.HandlerFunc <span class="cov8" title="1">{
        return func(ctx context.Context, e events.Event) error </span><span class="cov8" title="1">{
                log := logger.With(
                        "handler", "payment.HandleInitiated",
                        "event_type", e.Type(),
                )
                pi, ok := e.(*events.PaymentInitiated)
                if !ok </span><span class="cov8" title="1">{
                        log.Error(
                                "unexpected event type",
                                "event_type", fmt.Sprintf("%T", e),
                        )
                        return errors.New("unexpected event type")
                }</span>
                <span class="cov8" title="1">transactionID := pi.TransactionID
                idempotencyKey := transactionID.String()
                if _, already := processedPaymentInitiated.
                        LoadOrStore(
                                idempotencyKey,
                                struct{}{},
                        ); already </span><span class="cov8" title="1">{
                        log.Info(
                                "🔁 [SKIP] PaymentInitiatedEvent already emitted for this transaction",
                                "transaction_id", transactionID,
                        )
                        return nil
                }</span>

                // Call payment provider
                <span class="cov8" title="1">amount := pi.Amount.Amount()
                currency := pi.Amount.Currency().String()
                payment, err := paymentProvider.InitiatePayment(
                        ctx,
                        &amp;provider.InitiatePaymentParams{
                                UserID:        pi.UserID,
                                AccountID:     pi.AccountID,
                                Amount:        amount,
                                Currency:      currency,
                                TransactionID: transactionID,
                        },
                )
                if err != nil </span><span class="cov8" title="1">{
                        log.Error(
                                "Payment initiation failed",
                                "error", err,
                        )
                        return err
                }</span>
                <span class="cov8" title="1">log.Info(
                        "✅ [SUCCESS] Initiated payment",
                        "transaction_id", transactionID,
                        "payment", payment,
                )
                return nil</span>
        }
}
</pre>

		<pre class="file" id="file63" style="display: none">package payment

import (
        "context"
        "errors"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/handler/common"

        "github.com/amirasaad/fintech/pkg/domain/events"

        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/repository"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

// HandleProcessed handles PaymentInitiatedEvent and updates the transaction with payment ID.
// This is a generic handler that can process payment events
// for all operations (deposit, withdraw, transfer).
func HandleProcessed(
        uow repository.UnitOfWork,
        logger *slog.Logger,
) eventbus.HandlerFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                e events.Event,
        ) error </span><span class="cov8" title="1">{
                log := logger.With(
                        "handler", "HandleProcessed",
                        "event_type", e.Type(),
                )
                log.Info("🟢 [START] event received")

                pp, ok := e.(*events.PaymentProcessed)
                if !ok </span><span class="cov8" title="1">{
                        log.Error(
                                "Unexpected event type for payment processed",
                                "event", e,
                        )
                        return errors.New("unexpected event type")
                }</span>
                <span class="cov8" title="1">log = log.With(
                        "transaction_id", pp.TransactionID,
                        "payment_id", *pp.PaymentID,
                )
                log.Info(
                        "🔄 [PROCESS] Updating transaction with payment ID")

                // Update the transaction with payment ID
                err := uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov0" title="0">{
                        txRepo, err := common.GetTransactionRepository(uow, log)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(
                                        "Failed to get transaction repo",
                                        "error", err,
                                )
                                return fmt.Errorf("failed to get transaction repo: %w", err)
                        }</span>

                        <span class="cov0" title="0">transactionID := pp.TransactionID
                        if transactionID == uuid.Nil &amp;&amp; pp.PaymentID != nil </span><span class="cov0" title="0">{
                                tx, getErr := txRepo.GetByPaymentID(ctx, *pp.PaymentID)
                                if getErr != nil </span><span class="cov0" title="0">{
                                        log.Error(
                                                "Failed to get transaction by payment ID",
                                                "error", getErr,
                                        )
                                        return fmt.Errorf("failed to get transaction by payment ID: %w", getErr)
                                }</span>
                                <span class="cov0" title="0">transactionID = tx.ID</span>
                        }

                        <span class="cov0" title="0">if transactionID == uuid.Nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("no transaction ID provided and could not find by payment ID")
                                log.Error(
                                        "Failed to get transaction before update",
                                        "error", err,
                                )
                                return err
                        }</span>

                        <span class="cov0" title="0">status := "processed"
                        // First, try to get the existing transaction
                        tx, getErr := txRepo.Get(ctx, transactionID)
                        if getErr != nil &amp;&amp; !errors.Is(getErr, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                                log.Error(
                                        "Failed to get transaction",
                                        "error", getErr,
                                )
                                return fmt.Errorf("failed to get transaction: %w", getErr)
                        }</span>

                        // If transaction exists, update it with payment ID
                        <span class="cov0" title="0">if tx != nil </span><span class="cov0" title="0">{
                                update := dto.TransactionUpdate{
                                        PaymentID: pp.PaymentID,
                                        Status:    &amp;status,
                                }
                                if err := txRepo.Update(ctx, transactionID, update); err != nil </span><span class="cov0" title="0">{
                                        log.Error(
                                                "Failed to update transaction with payment ID",
                                                "error", err,
                                        )
                                        return fmt.Errorf("failed to update transaction: %w", err)
                                }</span>
                                <span class="cov0" title="0">log.Info(
                                        "Updated existing transaction with payment ID",
                                )
                                return nil</span>
                        }

                        // If transaction doesn't exist, create a new one
                        <span class="cov0" title="0">txCreate := dto.TransactionCreate{
                                ID:          transactionID,
                                UserID:      pp.UserID,
                                AccountID:   pp.AccountID,
                                Status:      status,
                                MoneySource: "Stripe", // Default money source for Stripe payments
                                PaymentID:   pp.PaymentID,
                        }

                        // Set amount and currency if available
                        if pp.Amount != nil </span><span class="cov0" title="0">{
                                txCreate.Amount = int64(pp.Amount.Amount())
                                txCreate.Currency = pp.Amount.Currency().String()
                        }</span>

                        // Create the transaction using UpsertByPaymentID which handles both create and update
                        <span class="cov0" title="0">if err := txRepo.UpsertByPaymentID(ctx, *pp.PaymentID, txCreate); err != nil </span><span class="cov0" title="0">{
                                log.Error(
                                        "Failed to create/update transaction with payment ID",
                                        "error", err,
                                )
                                return fmt.Errorf("failed to create/update transaction: %w", err)
                        }</span>

                        <span class="cov0" title="0">log.Info(
                                "Transaction updated with payment ID",
                        )
                        return nil</span>
                })

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        log.Error(
                                "Uow.Do failed",
                                "error", err,
                        )
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("✅ [SUCCESS] event processed")
                return nil</span>
        }
}
</pre>

		<pre class="file" id="file64" style="display: none">package payment

import (
        "context"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/handler/testutils"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/repository"
        repoaccount "github.com/amirasaad/fintech/pkg/repository/account"
        "github.com/amirasaad/fintech/pkg/repository/transaction"
        "github.com/stretchr/testify/mock"
)

// createValidPaymentCompletedEvent creates a valid PaymentCompletedEvent
func createValidPaymentCompletedEvent(
        h *testutils.TestHelper,
) *events.PaymentCompleted <span class="cov8" title="1">{
        // Use the amount directly from the test helper
        amount := h.Amount

        // Create a small fee amount (1% of the amount)
        feeAmount, err := money.New(amount.AmountFloat(), amount.CurrencyCode())
        if err != nil </span><span class="cov0" title="0">{
                h.T.Fatalf("failed to create fee amount: %v", err)
        }</span>

        <span class="cov8" title="1">return events.NewPaymentCompleted(
                &amp;events.FlowEvent{
                        ID:            h.EventID,
                        CorrelationID: h.CorrelationID,
                        FlowType:      "payment",
                },
                func(pc *events.PaymentCompleted) </span><span class="cov8" title="1">{
                        paymentID := "test-payment-id"
                        pc.PaymentID = &amp;paymentID
                        pc.TransactionID = h.TransactionID
                        pc.Amount = amount
                        // Set provider fee if needed by the test
                        pc.ProviderFee = account.Fee{
                                Amount: feeAmount,
                        }
                        pc.Status = "completed"
                }</span>,
        )
}

// createValidPaymentFailedEvent creates a valid PaymentFailedEvent
func createValidPaymentFailedEvent(
        h *testutils.TestHelper,
) *events.PaymentFailed <span class="cov8" title="1">{
        return events.NewPaymentFailed(
                &amp;events.FlowEvent{
                        ID:            h.EventID,
                        CorrelationID: h.CorrelationID,
                        FlowType:      "payment",
                }, func(pf *events.PaymentFailed) </span><span class="cov8" title="1">{
                        if h.PaymentID != nil </span><span class="cov0" title="0">{
                                pf.PaymentID = h.PaymentID
                        }</span>
                        <span class="cov8" title="1">pf.TransactionID = h.TransactionID</span>
                }).WithReason("payment processing failed")

}

// setupSuccessfulTest configures mocks for a successful payment completion
func setupSuccessfulTest(h *testutils.TestHelper) <span class="cov8" title="1">{
        // Use the amount directly from the test helper
        amount := h.Amount

        // Setup test transaction
        tx := &amp;dto.TransactionRead{
                ID:        h.TransactionID,
                UserID:    h.UserID,
                AccountID: h.AccountID,
                PaymentID: h.PaymentID,
                Status:    "pending",
                Currency:  amount.CurrencyCode().String(),
                Amount:    amount.AmountFloat(),
        }

        // Setup test account
        testAccount := &amp;dto.AccountRead{
                ID:       h.AccountID,
                UserID:   h.UserID,
                Balance:  amount.AmountFloat(),
                Currency: amount.CurrencyCode().String(),
        }

        doFn := func(ctx context.Context, fn func(uow repository.UnitOfWork) error) error </span><span class="cov8" title="1">{
                h.UOW.
                        EXPECT().
                        GetRepository(
                                (*transaction.Repository)(nil),
                        ).
                        Return(
                                h.MockTxRepo, nil,
                        )

                // Ensure we pass a string, not a *string
                paymentID := "test-payment-id"
                h.MockTxRepo.
                        EXPECT().
                        GetByPaymentID(ctx, paymentID).
                        Return(tx, nil).
                        Once()

                h.UOW.
                        EXPECT().
                        GetRepository(
                                (*repoaccount.Repository)(nil),
                        ).
                        Return(
                                h.MockAccRepo, nil,
                        ).Once()
                h.MockAccRepo.
                        EXPECT().
                        Get(ctx, h.AccountID).
                        Return(testAccount, nil).
                        Once()

                // Setup mock expectations for account update
                h.MockAccRepo.EXPECT().
                        Update(ctx, h.AccountID, mock.MatchedBy(func(update dto.AccountUpdate) bool </span><span class="cov8" title="1">{
                                // Verify the account balance is being updated correctly
                                return update.Balance != nil &amp;&amp; *update.Balance &gt; 0
                        }</span>)).
                        Return(nil).
                        Once()

                // Setup mock expectations for transaction update
                <span class="cov8" title="1">h.MockTxRepo.EXPECT().
                        Update(ctx, h.TransactionID, mock.MatchedBy(func(update dto.TransactionUpdate) bool </span><span class="cov8" title="1">{
                                // Verify the transaction status is being updated to "completed"
                                return update.Status != nil &amp;&amp; *update.Status == "completed"
                        }</span>)).
                        Return(nil).
                        Once()

                <span class="cov8" title="1">err := fn(h.UOW)
                return err</span>
        }

        <span class="cov8" title="1">h.UOW.
                EXPECT().
                Do(
                        h.Ctx,
                        mock.AnythingOfType("func(repository.UnitOfWork) error")).
                RunAndReturn(doFn).
                Once()</span>
}
</pre>

		<pre class="file" id="file65" style="display: none">package testutils

import (
        "context"
        "io"
        "log/slog"
        "sync"
        "testing"

        "github.com/amirasaad/fintech/internal/fixtures/mocks"
        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/events"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/eventbus"
        "github.com/amirasaad/fintech/pkg/money"

        "github.com/google/uuid"
        "github.com/stretchr/testify/mock"
        "github.com/stretchr/testify/require"
)

const (
        // DefaultCurrencyCode is the default currency code used in tests
        DefaultCurrencyCode = "USD"
        // DefaultAmount is the default amount used in tests (100.00)
        DefaultAmount = 100.0
        // DefaultFeeAmount is the default fee amount used in tests (1.00)
        DefaultFeeAmount = 1.0
)

type TestEvent struct{}

func (e *TestEvent) Type() string <span class="cov0" title="0">{ return "test.event" }</span>

// TestHelper contains all test dependencies and helper methods
type TestHelper struct {
        T                   *testing.T
        Handler             eventbus.HandlerFunc
        MockPaymentProvider *mocks.PaymentProvider
        Ctx                 context.Context
        Bus                 *mocks.Bus
        UOW                 *mocks.UnitOfWork
        MockAccRepo         *mocks.AccountRepository
        MockTxRepo          *mocks.TransactionRepository
        Logger              *slog.Logger

        // Test data
        UserID        uuid.UUID
        AccountID     uuid.UUID
        PaymentID     *string
        EventID       uuid.UUID
        CorrelationID uuid.UUID
        TransactionID uuid.UUID
        Amount        *money.Money
        FeeAmount     *money.Money
}

// New creates a new test helper with fresh mocks and test data
func New(t *testing.T, opts ...TestOption) *TestHelper <span class="cov0" title="0">{
        t.Helper()

        // Setup defaults
        h := &amp;TestHelper{
                T:      t,
                Logger: slog.New(slog.NewTextHandler(io.Discard, nil)), // Create a new logger for each test
        }

        // Initialize mocks
        h.UOW = mocks.NewUnitOfWork(t)
        h.MockAccRepo = mocks.NewAccountRepository(t)
        h.MockTxRepo = mocks.NewTransactionRepository(t)
        h.MockPaymentProvider = mocks.NewPaymentProvider(t)

        // Apply options (excluding default currency initialization since we did it above)
        for _, opt := range append(defaultTestOptions, opts...) </span><span class="cov0" title="0">{
                opt(h)
        }</span>

        // Initialize test data if not set by options
        <span class="cov0" title="0">if h.Handler == nil </span><span class="cov0" title="0">{
                h.Handler = eventbus.HandlerFunc(
                        func(ctx context.Context, event events.Event) error </span><span class="cov0" title="0">{
                                return nil
                        }</span>)
        }
        <span class="cov0" title="0">if h.Ctx == nil </span><span class="cov0" title="0">{
                h.Ctx = context.Background()
        }</span>

        <span class="cov0" title="0">if h.Bus == nil </span><span class="cov0" title="0">{
                h.Bus = mocks.NewBus(t)
        }</span>

        // Initialize test data with default values if not set
        <span class="cov0" title="0">if h.UserID == uuid.Nil </span><span class="cov0" title="0">{
                h.UserID = uuid.New()
        }</span>

        <span class="cov0" title="0">if h.AccountID == uuid.Nil </span><span class="cov0" title="0">{
                h.AccountID = uuid.New()
        }</span>

        <span class="cov0" title="0">if h.TransactionID == uuid.Nil </span><span class="cov0" title="0">{
                h.TransactionID = uuid.New()
        }</span>

        <span class="cov0" title="0">if h.EventID == uuid.Nil </span><span class="cov0" title="0">{
                h.EventID = uuid.New()
        }</span>

        <span class="cov0" title="0">if h.CorrelationID == uuid.Nil </span><span class="cov0" title="0">{
                h.CorrelationID = uuid.New()
        }</span>

        // Initialize amounts if not set
        <span class="cov0" title="0">if h.Amount == nil </span><span class="cov0" title="0">{
                amount, err := money.New(DefaultAmount, money.Code(DefaultCurrencyCode).ToCurrency())
                require.NoError(t, err, "failed to create default amount")
                h.Amount = amount
        }</span>

        <span class="cov0" title="0">if h.FeeAmount == nil </span><span class="cov0" title="0">{
                feeAmount, err := money.New(DefaultFeeAmount, money.Code(DefaultCurrencyCode).ToCurrency())
                require.NoError(t, err, "failed to create default fee amount")
                h.FeeAmount = feeAmount
        }</span>

        <span class="cov0" title="0">return h</span>
}

// TestOption defines a function type for test options
type TestOption func(*TestHelper)

var (
        initOnce sync.Once
)

var defaultTestOptions = []TestOption{
        // Initialize currency registry with default currencies
        func(h *TestHelper) <span class="cov0" title="0">{
                // Use sync.Once to ensure initialization happens only once
                initOnce.Do(func() </span>{<span class="cov0" title="0">
                        // No need to initialize currency registry as it's handled by the money package
                }</span>)
        },
}

// WithHandler sets a custom handler for the test helper
func (h *TestHelper) WithHandler(
        handler eventbus.HandlerFunc) *TestHelper <span class="cov0" title="0">{
        h.Handler = handler
        return h
}</span>

// WithContext sets the context for the test helper
func (h *TestHelper) WithContext(ctx context.Context) *TestHelper <span class="cov0" title="0">{
        h.Ctx = ctx
        return h
}</span>

// WithAmount sets a custom amount for the test helper
func (h *TestHelper) WithAmount(amount *money.Money) *TestHelper <span class="cov0" title="0">{
        h.Amount = amount
        return h
}</span>

// WithFeeAmount sets a custom fee amount for the test helper
func (h *TestHelper) WithFeeAmount(amount *money.Money) *TestHelper <span class="cov0" title="0">{
        h.FeeAmount = amount
        return h
}</span>

// WithUserID sets a custom user ID for the test helper
func (h *TestHelper) WithUserID(id uuid.UUID) *TestHelper <span class="cov0" title="0">{
        h.UserID = id
        return h
}</span>

// WithAccountID sets a custom account ID for the test helper
func (h *TestHelper) WithAccountID(id uuid.UUID) *TestHelper <span class="cov0" title="0">{
        h.AccountID = id
        return h
}</span>

// WithTransactionID sets a custom transaction ID for the test helper
func (h *TestHelper) WithTransactionID(d uuid.UUID) *TestHelper <span class="cov0" title="0">{
        h.TransactionID = d
        return h
}</span>

// WithPaymentID sets a custom payment ID for the test helper
func (h *TestHelper) WithPaymentID(id *string) *TestHelper <span class="cov0" title="0">{
        h.PaymentID = id
        return h
}</span>

// CreateValidTransaction creates a test transaction DTO
func (h *TestHelper) CreateValidTransaction() *dto.TransactionRead <span class="cov0" title="0">{
        amount := h.Amount.AmountFloat()
        currency := h.Amount.CurrencyCode().String()
        return &amp;dto.TransactionRead{
                ID:        h.TransactionID,
                UserID:    h.UserID,
                AccountID: h.AccountID,
                PaymentID: h.PaymentID,
                Status:    string(account.TransactionStatusPending),
                Currency:  currency,
                Amount:    amount,
        }
}</span>

// CreateValidAccount creates a test account DTO
func (h *TestHelper) CreateValidAccount() *dto.AccountRead <span class="cov0" title="0">{
        amount := h.Amount.AmountFloat()
        currency := h.Amount.CurrencyCode().String()
        return &amp;dto.AccountRead{
                ID:       h.AccountID,
                UserID:   h.UserID,
                Balance:  amount,
                Currency: currency,
        }
}</span>

// SetupMocks configures the default mock expectations
func (h *TestHelper) SetupMocks() <span class="cov0" title="0">{
        h.UOW.EXPECT().GetRepository(mock.Anything).Return(h.MockAccRepo, nil).Maybe()
        h.UOW.EXPECT().GetRepository(mock.Anything).Return(h.MockTxRepo, nil).Maybe()
}</span>

// AssertExpectations asserts all mock expectations
func (h *TestHelper) AssertExpectations() {<span class="cov0" title="0">
}</span>
</pre>

		<pre class="file" id="file66" style="display: none">package mapper

import (
        "fmt"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/money"
)

// MapAccountReadToDomain maps a dto.AccountRead to a domain Account.
func MapAccountReadToDomain(dto *dto.AccountRead) (*account.Account, error) <span class="cov0" title="0">{
        balance, err := money.New(dto.Balance, money.Code(dto.Currency))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating money from dto: %w", err)
        }</span>
        <span class="cov0" title="0">acc, err := account.New().
                WithID(dto.ID).
                WithUserID(dto.UserID).
                WithBalance(balance.Amount()).
                WithCurrency(money.Code(balance.Currency().String())).
                WithCreatedAt(dto.CreatedAt).
                WithUpdatedAt(dto.UpdatedAt).
                Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating account from dto: %w", err)
        }</span>
        <span class="cov0" title="0">return acc, nil</span>
}
</pre>

		<pre class="file" id="file67" style="display: none">package middleware

import (
        "github.com/amirasaad/fintech/pkg/config"
        jwtware "github.com/gofiber/contrib/jwt"
        "github.com/gofiber/fiber/v2"
)

// JwtProtected protect routes
func JwtProtected(cfg *config.Jwt) fiber.Handler <span class="cov8" title="1">{
        return jwtware.New(jwtware.Config{
                SigningKey:   jwtware.SigningKey{Key: []byte(cfg.Secret)},
                ErrorHandler: jwtError,
        })
}</span>

func jwtError(c *fiber.Ctx, err error) error <span class="cov8" title="1">{
        if err.Error() == "Missing or malformed JWT" </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusBadRequest).
                        JSON(fiber.Map{"status": "error", "message": "Missing or malformed JWT", "data": nil})

        }</span>
        <span class="cov8" title="1">return c.Status(fiber.StatusUnauthorized).
                JSON(fiber.Map{"status": "error", "message": "Invalid or expired JWT", "data": nil})</span>
}
</pre>

		<pre class="file" id="file68" style="display: none">// Package money provides functionality for handling monetary values.
//
// It is a value object that represents a monetary value in a specific currency.
// Invariants:
//   - Amount is always stored in the smallest currency unit (e.g., cents for USD).
//   - Currency code must be valid ISO 4217 (3 uppercase letters).
//   - All arithmetic operations require matching currencies.
package money

import (
        "encoding/json"
        "fmt"
        "math"
        "math/big"
)

var (
        // ErrInvalidAmount is returned when an invalid amount is provided.
        ErrInvalidAmount = fmt.Errorf("invalid amount float")

        // ErrAmountExceedsMaxSafeInt is returned when an amount exceeds the maximum safe integer value.
        ErrAmountExceedsMaxSafeInt = fmt.Errorf("amount exceeds maximum safe integer value")

        // ErrMismatchedCurrencies is returned when performing operations
        // on money with different currencies.
        ErrInvalidCurrency = fmt.Errorf("invalid currency code")
)

// Amount represents a monetary amount as an integer in the
// smallest currency unit (e.g., cents for USD).
type Amount = int64

// Code represents a currency code (e.g., "USD", "EUR")
// Code is defined in codes.go

// ToCurrency converts a Code to a Currency with default decimals
func (c Code) ToCurrency() Currency <span class="cov8" title="1">{
        switch c </span>{
        case USD:<span class="cov8" title="1">
                return USDCurrency</span>
        case EUR:<span class="cov8" title="1">
                return EURCurrency</span>
        case GBP:<span class="cov8" title="1">
                return GBPCurrency</span>
        case JPY:<span class="cov8" title="1">
                return JPYCurrency</span>
        default:<span class="cov8" title="1">
                return Currency{Code: c, Decimals: 2}</span>
        }
}

// IsValid checks if the currency code is valid
func (c Code) IsValid() bool <span class="cov8" title="1">{
        if len(c) != 3 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return c[0] &gt;= 'A' &amp;&amp; c[0] &lt;= 'Z' &amp;&amp;
                c[1] &gt;= 'A' &amp;&amp; c[1] &lt;= 'Z' &amp;&amp;
                c[2] &gt;= 'A' &amp;&amp; c[2] &lt;= 'Z'</span>
}

// String returns the string representation of the currency code.
func (c Code) String() string <span class="cov8" title="1">{
        return string(c)
}</span>

// Currency represents a monetary unit with its standard decimal places
type Currency struct {
        Code     Code // 3-letter ISO 4217 code (e.g., "USD")
        Decimals int  // Number of decimal places (0-8)
}

// IsValid checks if the currency is valid.
func (c Currency) IsValid() bool <span class="cov8" title="1">{
        if c.Decimals &lt; 0 || c.Decimals &gt; 8 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return len(c.Code) == 3 &amp;&amp;
                c.Code[0] &gt;= 'A' &amp;&amp; c.Code[0] &lt;= 'Z' &amp;&amp;
                c.Code[1] &gt;= 'A' &amp;&amp; c.Code[1] &lt;= 'Z' &amp;&amp;
                c.Code[2] &gt;= 'A' &amp;&amp; c.Code[2] &lt;= 'Z'</span>
}

// String returns the currency code as a string
func (c Currency) String() string <span class="cov8" title="1">{ return string(c.Code) }</span>

// Common currency codes are defined in codes.go

// Common currency instances
var (
        USDCurrency = Currency{Code: USD, Decimals: 2}
        EURCurrency = Currency{Code: EUR, Decimals: 2}
        GBPCurrency = Currency{Code: GBP, Decimals: 2}
        JPYCurrency = Currency{Code: JPY, Decimals: 0} // Japanese Yen has no decimal places
)

// DefaultCurrency is the default currency (USD)
var DefaultCurrency = USDCurrency

// DefaultCode is the default currency code (USD)
var DefaultCode = USD

// Money represents a monetary value in a specific currency.
// Invariants:
//   - Amount is always stored in the smallest currency unit (e.g., cents for USD).
//   - Currency must be valid (valid ISO 4217 code and valid decimal places).
//   - All arithmetic operations require matching currencies.
type Money struct {
        amount   Amount
        currency Currency
}

// MarshalJSON implements json.Marshaler interface.
func (m Money) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(map[string]any{
                "amount":   m.amount,
                "currency": m.currency.Code,
        })
}</span>

// UnmarshalJSON implements json.Unmarshaler interface.
func (m *Money) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var aux struct {
                Amount   int64  `json:"amount"`
                Currency string `json:"currency"`
        }

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create currency and validate
        <span class="cov0" title="0">currency := Currency{Code: Code(aux.Currency)}
        switch aux.Currency </span>{
        case "USD", "EUR", "GBP":<span class="cov0" title="0">
                currency.Decimals = 2</span>
        case "JPY":<span class="cov0" title="0">
                currency.Decimals = 0</span>
        default:<span class="cov0" title="0">
                currency.Decimals = 2</span> // Default to 2 decimal places
        }

        <span class="cov0" title="0">if !currency.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid currency code: %s", aux.Currency)
        }</span>

        <span class="cov0" title="0">m.amount = aux.Amount
        m.currency = currency
        return nil</span>
}

// Zero creates a Money object with zero amount in the specified currency.
// The currency parameter can be either a Code or a Currency.
func Zero(currency interface{}) *Money <span class="cov0" title="0">{
        var c Currency
        switch v := currency.(type) </span>{
        case Code:<span class="cov0" title="0">
                c = v.ToCurrency()</span>
        case Currency:<span class="cov0" title="0">
                c = v</span>
        default:<span class="cov0" title="0">
                // Default to USD if invalid type is provided
                c = USDCurrency</span>
        }

        <span class="cov0" title="0">return &amp;Money{
                amount:   0,
                currency: c,
        }</span>
}

// Must creates a Money object from the given amount and currency.
// Invariants enforced:
//   - Currency must be valid (valid ISO 4217 code and valid decimal places).
//   - Amount must not have more decimal places than allowed by the currency.
//   - Amount is converted to the smallest currency unit.
//
// Panics if any invariant is violated.
func Must(amount float64, currency Currency) *Money <span class="cov0" title="0">{
        m, err := New(amount, currency)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("money.Must(%v, %v): %v", amount, currency, err))</span>
        }
        <span class="cov0" title="0">return m</span>
}

// NewFromData creates a Money object from raw data (used for DB hydration).
// This bypasses invariants and should only be used for repository hydration or tests.
// Deprecated: use NewFromSmallestUnit instead.
func NewFromData(amount int64, cc string) *Money <span class="cov0" title="0">{
        // This is intentionally not validating the currency code to allow for flexibility
        // in database migrations and test data setup.
        return &amp;Money{
                amount:   amount,
                currency: Currency{Code: Code(cc), Decimals: 2}, // Default to 2 decimal places
        }
}</span>

// New creates a new Money value object with the given amount and currency.
// The currency parameter can be either a Code, Currency, or string (e.g., "USD").
// Invariants enforced:
//   - Currency must be valid (valid ISO 4217 code and valid decimal places).
//   - Amount must not have more decimal places than allowed by the currency.
//   - Amount is converted to the smallest currency unit.
//
// Returns Money or an error if any invariant is violated.
func New(amount float64, currency any) (*Money, error) <span class="cov8" title="1">{
        var c Currency

        switch v := currency.(type) </span>{
        case string:<span class="cov0" title="0">
                // Handle string currency codes like "USD"
                if len(v) != 3 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: invalid currency code length: %s", ErrInvalidCurrency, v)
                }</span>
                <span class="cov0" title="0">code := Code(v)
                if !code.IsValid() </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: %s", ErrInvalidCurrency, v)
                }</span>
                <span class="cov0" title="0">c = code.ToCurrency()</span>
        case Code:<span class="cov8" title="1">
                c = v.ToCurrency()</span>
        case Currency:<span class="cov0" title="0">
                c = v</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf(
                        "invalid currency type: %T, expected string, Code, or Currency",
                        currency,
                )</span>
        }

        <span class="cov8" title="1">if !c.IsValid() </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %v", ErrInvalidCurrency, c)
        }</span>

        // Convert amount to smallest unit (e.g., dollars to cents)
        <span class="cov8" title="1">smallestUnit, err := convertToSmallestUnit(amount, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Money{
                amount:   Amount(smallestUnit),
                currency: c,
        }, nil</span>
}

// NewFromSmallestUnit creates a new Money object from the smallest currency unit.
// The currency parameter can be either a Code or a Currency.
// Invariants enforced:
//   - Currency must be valid (valid ISO 4217 code and valid decimal places).
//
// Returns Money or an error if any invariant is violated.
func NewFromSmallestUnit(amount int64, currency interface{}) (*Money, error) <span class="cov8" title="1">{
        var c Currency
        switch v := currency.(type) </span>{
        case Code:<span class="cov8" title="1">
                c = v.ToCurrency()</span>
        case Currency:<span class="cov0" title="0">
                c = v</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid currency type: %T", currency)</span>
        }

        <span class="cov8" title="1">if !c.IsValid() </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %v", ErrInvalidCurrency, c)
        }</span>

        <span class="cov8" title="1">return &amp;Money{
                amount:   Amount(amount),
                currency: c,
        }, nil</span>
}

// Amount returns the amount of the Money object in the smallest currency unit.
func (m *Money) Amount() Amount <span class="cov8" title="1">{
        return m.amount
}</span>

// AmountFloat returns the amount as a float64 in the main currency unit (e.g., dollars for USD).
func (m *Money) AmountFloat() float64 <span class="cov8" title="1">{
        amount := new(big.Rat).SetInt64(int64(m.amount))
        divisor := new(big.Rat).SetFloat64(math.Pow10(m.currency.Decimals))
        result := new(big.Rat).Quo(amount, divisor)

        floatResult, _ := result.Float64()
        return floatResult
}</span>

// Currency returns the currency of the Money object.
func (m *Money) Currency() Currency <span class="cov8" title="1">{
        return m.currency
}</span>

// CurrencyCode returns the currency code of the Money object.
func (m *Money) CurrencyCode() Code <span class="cov8" title="1">{
        return m.currency.Code
}</span>

// IsCurrency checks if the money object has the specified currency
func (m *Money) IsCurrency(currency Currency) bool <span class="cov0" title="0">{
        return m.currency == currency
}</span>

// Add returns a new Money object with the sum of amounts.
// Invariants enforced:
//   - Currencies must match.
func (m *Money) Add(other *Money) (*Money, error) <span class="cov8" title="1">{
        if m.currency != other.currency </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(
                        "cannot add different currencies: %s and %s",
                        m.currency.Code,
                        other.currency.Code,
                )
        }</span>

        <span class="cov8" title="1">sum := int64(m.amount) + int64(other.amount)

        return &amp;Money{
                amount:   Amount(sum),
                currency: m.currency,
        }, nil</span>
}

// Subtract returns a new Money object with the difference of amounts.
// Invariants enforced:
//   - Currencies must match.
//   - Resulting amount must not be negative.
func (m *Money) Subtract(other *Money) (*Money, error) <span class="cov8" title="1">{
        if m.currency != other.currency </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "cannot subtract different currencies: %s and %s",
                        m.currency.Code,
                        other.currency.Code,
                )
        }</span>

        <span class="cov8" title="1">diff := int64(m.amount) - int64(other.amount)
        if diff &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resulting amount cannot be negative")
        }</span>

        <span class="cov8" title="1">return &amp;Money{
                amount:   Amount(diff),
                currency: m.currency,
        }, nil</span>
}

// Negate negates the current Money object.
func (m *Money) Negate() *Money <span class="cov8" title="1">{
        return &amp;Money{
                amount:   -m.amount,
                currency: m.currency,
        }
}</span>

// Equals checks if the current Money object is equal to another Money object.
// Invariants enforced:
//   - Currencies must match.
func (m *Money) Equals(other *Money) bool <span class="cov8" title="1">{
        if m == nil || other == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return m.currency == other.currency &amp;&amp; m.amount == other.amount</span>
}

// GreaterThan checks if the current Money object is greater than another Money object.
// Invariants enforced:
//   - Currencies must match.
func (m *Money) GreaterThan(other *Money) (bool, error) <span class="cov8" title="1">{
        if m.currency != other.currency </span><span class="cov8" title="1">{
                return false, fmt.Errorf(
                        "cannot compare different currencies: %s and %s",
                        m.currency.Code,
                        other.currency.Code,
                )
        }</span>

        <span class="cov8" title="1">return m.amount &gt; other.amount, nil</span>
}

// LessThan checks if the current Money object is less than another Money object.
// Invariants enforced:
//   - Currencies must match.
//
// Returns an error if currencies do not match.
func (m *Money) LessThan(other *Money) (bool, error) <span class="cov8" title="1">{
        if !m.IsSameCurrency(other) </span><span class="cov0" title="0">{
                return false, ErrInvalidCurrency
        }</span>
        <span class="cov8" title="1">return m.amount &lt; other.amount, nil</span>
}

// IsSameCurrency checks if the current Money object has the same currency as another Money object.
func (m *Money) IsSameCurrency(other *Money) bool <span class="cov8" title="1">{
        return m.currency == other.currency
}</span>

// IsPositive returns true if the Money is not nil and its amount is greater than zero.
func (m *Money) IsPositive() bool <span class="cov8" title="1">{
        return m != nil &amp;&amp; m.amount &gt; 0
}</span>

// IsNegative returns true if the Money is not nil and its amount is less than zero.
func (m *Money) IsNegative() bool <span class="cov8" title="1">{
        return m != nil &amp;&amp; m.amount &lt; 0
}</span>

// IsZero returns true if the Money is nil or its amount is zero.
func (m *Money) IsZero() bool <span class="cov8" title="1">{
        return m == nil || m.amount == 0
}</span>

// Abs returns the absolute value of the Money amount.
func (m *Money) Abs() *Money <span class="cov8" title="1">{
        if m.amount &lt; 0 </span><span class="cov8" title="1">{
                return m.Negate()
        }</span>
        <span class="cov8" title="1">return m</span>
}

// Multiply multiplies the Money amount by a scalar factor.
// The result is rounded to the nearest integer.
// Invariants enforced:
//   - Factor must not be negative.
//
// Returns a new Money object or an error if the factor is negative.
func (m *Money) Multiply(factor float64) (*Money, error) <span class="cov8" title="1">{
        if factor &lt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("factor cannot be negative")
        }</span>

        // Convert to big.Rat for precise multiplication
        <span class="cov8" title="1">amount := new(big.Rat).SetInt64(int64(m.amount))
        f := new(big.Rat).SetFloat64(factor)
        result := new(big.Rat).Mul(amount, f)

        // Round to nearest integer
        resultFloat, _ := result.Float64()
        rounded := int64(math.Round(resultFloat))

        // Check for overflow
        if resultFloat &gt; float64(math.MaxInt64) || resultFloat &lt; float64(math.MinInt64) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiplication result would overflow")
        }</span>

        <span class="cov8" title="1">return &amp;Money{
                amount:   Amount(rounded),
                currency: m.currency,
        }, nil</span>
}

// Divide divides the Money amount by a scalar divisor.
// The result is rounded to the nearest integer.
// Invariants enforced:
//   - Divisor must be positive.
//
// Returns a new Money object or an error if the divisor is invalid.
func (m *Money) Divide(divisor float64) (*Money, error) <span class="cov8" title="1">{
        if divisor &lt;= 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("divisor must be positive")
        }</span>

        // Convert to big.Rat for precise division
        <span class="cov8" title="1">amount := new(big.Rat).SetInt64(int64(m.amount))
        d := new(big.Rat).SetFloat64(divisor)
        result := new(big.Rat).Quo(amount, d)

        // Round to nearest integer
        resultFloat, _ := result.Float64()
        rounded := int64(math.Round(resultFloat))

        // Check for overflow - using big.Int for the comparison to handle all cases
        bigRounded := big.NewInt(rounded)
        maxInt64 := big.NewInt(math.MaxInt64)
        minInt64 := big.NewInt(math.MinInt64)
        if bigRounded.Cmp(maxInt64) &gt; 0 || bigRounded.Cmp(minInt64) &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("division result would overflow")
        }</span>

        <span class="cov8" title="1">return &amp;Money{
                amount:   Amount(rounded),
                currency: m.currency,
        }, nil</span>
}

// String returns a string representation of the Money object.
func (m *Money) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%.*f %s", m.currency.Decimals, m.AmountFloat(), m.currency.Code)
}</span>

// convertToSmallestUnit converts a float64 amount to the smallest currency unit.
// This ensures precision by avoiding floating-point arithmetic issues.
func convertToSmallestUnit(amount float64, currency Currency) (int64, error) <span class="cov8" title="1">{
        factor := new(big.Rat).SetFloat64(math.Pow10(currency.Decimals))
        amountRat := new(big.Rat).SetFloat64(amount)
        result := new(big.Rat).Mul(amountRat, factor)

        // Round to nearest integer
        resultFloat, _ := result.Float64()
        return int64(math.Round(resultFloat)), nil
}</span>
</pre>

		<pre class="file" id="file69" style="display: none">// Package money provides functionality for handling monetary values.
package money

// Currency represents a monetary unit with its standard decimal places
type Currency struct {
        Code     string // 3-letter ISO 4217 code (e.g., "USD")
        Decimals int    // Number of decimal places (0-18)
}

// Common currency instances
var (
        USD = Currency{"USD", 2} // US Dollar
        EUR = Currency{"EUR", 2} // Euro
        GBP = Currency{"GBP", 2} // British Pound
        JPY = Currency{"JPY", 0} // Japanese Yen
)

// DefaultCurrency is the default currency (USD)
var DefaultCurrency = USD

// IsValid checks if the currency is valid.
func (c Currency) IsValid() bool <span class="cov8" title="1">{
        if c.Decimals &lt; 0 || c.Decimals &gt; 18 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return len(c.Code) == 3 &amp;&amp;
                c.Code[0] &gt;= 'A' &amp;&amp; c.Code[0] &lt;= 'Z' &amp;&amp;
                c.Code[1] &gt;= 'A' &amp;&amp; c.Code[1] &lt;= 'Z' &amp;&amp;
                c.Code[2] &gt;= 'A' &amp;&amp; c.Code[2] &lt;= 'Z'</span>
}

// String returns the currency code
func (c Currency) String() string <span class="cov8" title="1">{ return c.Code }</span>
</pre>

		<pre class="file" id="file70" style="display: none">// Package money provides functionality for handling monetary values.
package money

import (
        "encoding/json"
        "errors"
        "fmt"
        "math"
        "math/big"
)

// Common errors
var (
        // ErrInvalidCurrency is returned when an invalid currency is provided
        // or when there's a currency mismatch in operations.
        ErrInvalidCurrency = errors.New("invalid currency")

        // ErrInvalidAmount is returned when an invalid amount is provided.
        ErrInvalidAmount = errors.New("invalid amount")

        // ErrAmountExceedsMaxSafeInt is returned when an amount exceeds the maximum safe integer value.
        ErrAmountExceedsMaxSafeInt = errors.New("amount exceeds maximum safe integer value")
)

// Amount represents a monetary amount as an integer in the
// smallest currency unit (e.g., cents for USD).
type Amount = int64

// Money represents a monetary value in a specific currency.
// Invariants:
//   - Amount is always stored in the smallest currency unit (e.g., cents for USD).
//   - Currency must be valid (valid ISO 4217 code and valid decimal places).
//   - All arithmetic operations require matching currencies.
type Money struct {
        amount   Amount
        currency Currency
}

// MarshalJSON implements json.Marshaler interface.
func (m Money) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(map[string]any{
                "amount":   m.AmountFloat(),
                "currency": m.currency.Code,
        })
}</span>

// UnmarshalJSON implements json.Unmarshaler interface.
func (m *Money) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var aux struct {
                Amount   float64 `json:"amount"`
                Currency string  `json:"currency"`
        }

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create currency and validate
        <span class="cov0" title="0">currency := Currency{Code: aux.Currency}
        if !currency.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid currency: %s", aux.Currency)
        }</span>

        <span class="cov0" title="0">smallestUnit, err := convertToSmallestUnit(aux.Amount, currency)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid amount: %w", err)
        }</span>

        <span class="cov0" title="0">m.amount = Amount(smallestUnit)
        m.currency = currency
        return nil</span>
}

// Zero creates a Money object with zero amount in the specified currency.
func Zero(currency Currency) *Money <span class="cov0" title="0">{
        return &amp;Money{
                amount:   0,
                currency: currency,
        }
}</span>

// Must creates a Money object from the given amount and currency.
// Invariants enforced:
//   - Currency must be valid (valid ISO 4217 code and valid decimal places).
//   - Amount must not have more decimal places than allowed by the currency.
//   - Amount is converted to the smallest currency unit.
//
// Panics if any invariant is violated.
func Must(amount float64, currency Currency) *Money <span class="cov0" title="0">{
        money, err := New(amount, currency)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf(
                        "money: invalid arguments to Must(%v, %v): %v",
                        amount,
                        currency.Code,
                        err,
                ))</span>
        }
        <span class="cov0" title="0">return money</span>
}

// NewFromData creates a Money object from raw data (used for DB hydration).
// This bypasses invariants and should only be used for repository hydration or tests.
// Deprecated: use NewFromSmallestUnit instead.
func NewFromData(amount int64, currencyCode string) *Money <span class="cov0" title="0">{
        currency := Currency{Code: currencyCode}
        // Set default decimals based on common currencies
        switch currencyCode </span>{
        case "USD", "EUR", "GBP":<span class="cov0" title="0">
                currency.Decimals = 2</span>
        case "JPY":<span class="cov0" title="0">
                currency.Decimals = 0</span>
        default:<span class="cov0" title="0">
                currency.Decimals = 2</span> // Default to 2 decimal places
        }

        <span class="cov0" title="0">return &amp;Money{
                amount:   amount,
                currency: currency,
        }</span>
}

// New creates a new Money object from a float amount and currency.
// The amount is converted to the smallest currency unit (e.g., cents for USD).
func New(amount float64, currency Currency) (*Money, error) <span class="cov8" title="1">{
        if !currency.IsValid() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid currency: %v", currency)
        }</span>

        <span class="cov8" title="1">smallestUnit, err := convertToSmallestUnit(amount, currency)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid amount: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Money{
                amount:   Amount(smallestUnit),
                currency: currency,
        }, nil</span>
}

// NewFromSmallestUnit creates a new Money object directly from the smallest currency unit.
func NewFromSmallestUnit(amount int64, currency Currency) (*Money, error) <span class="cov8" title="1">{
        if !currency.IsValid() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid currency: %v", currency)
        }</span>

        <span class="cov8" title="1">return &amp;Money{
                amount:   Amount(amount),
                currency: currency,
        }, nil</span>
}

// Amount returns the amount of the Money object in the smallest currency unit.
func (m *Money) Amount() Amount <span class="cov8" title="1">{
        return m.amount
}</span>

// AmountFloat returns the amount as a float64 in the main currency unit (e.g., dollars for USD).
func (m *Money) AmountFloat() float64 <span class="cov8" title="1">{
        amount := new(big.Rat).SetInt64(int64(m.amount))
        divisor := new(big.Rat).SetFloat64(math.Pow10(m.currency.Decimals))
        result := new(big.Rat).Quo(amount, divisor)

        floatResult, _ := result.Float64()
        return floatResult
}</span>

// Currency returns the currency of the Money object.
func (m *Money) Currency() Currency <span class="cov8" title="1">{
        return m.currency
}</span>

// IsCurrency checks if the money object has the specified currency
func (m *Money) IsCurrency(currency Currency) bool <span class="cov0" title="0">{
        return m.currency == currency
}</span>

// Add returns a new Money object with the sum of amounts.
// Returns an error if the currencies don't match.
func (m *Money) Add(other *Money) (*Money, error) <span class="cov8" title="1">{
        if m.currency != other.currency </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "cannot add different currencies: %s and %s",
                        m.currency,
                        other.currency,
                )
        }</span>

        <span class="cov8" title="1">sum := int64(m.amount) + int64(other.amount)

        return &amp;Money{
                amount:   Amount(sum),
                currency: m.currency,
        }, nil</span>
}

// Subtract returns a new Money object with the difference of amounts.
// Returns an error if the currencies don't match or if the result would be negative.
func (m *Money) Subtract(other *Money) (*Money, error) <span class="cov8" title="1">{
        if m.currency != other.currency </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "cannot subtract different currencies: %s and %s",
                        m.currency,
                        other.currency,
                )
        }</span>

        <span class="cov8" title="1">diff := int64(m.amount) - int64(other.amount)
        if diff &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resulting amount cannot be negative")
        }</span>

        <span class="cov8" title="1">return &amp;Money{
                amount:   Amount(diff),
                currency: m.currency,
        }, nil</span>
}

// Negate negates the current Money object.
func (m *Money) Negate() *Money <span class="cov0" title="0">{
        return &amp;Money{
                amount:   -m.amount,
                currency: m.currency,
        }
}</span>

// Equals checks if the current Money object is equal to another Money object.
// Invariants enforced:
//   - Currencies must match.
func (m *Money) Equals(other *Money) bool <span class="cov8" title="1">{
        if m == nil || other == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return m.currency == other.currency &amp;&amp; m.amount == other.amount</span>
}

// GreaterThan checks if the current Money object is greater than another Money object.
// Returns an error if the currencies don't match.
func (m *Money) GreaterThan(other *Money) (bool, error) <span class="cov8" title="1">{
        if m.currency != other.currency </span><span class="cov0" title="0">{
                return false, fmt.Errorf(
                        "cannot compare different currencies: %s and %s",
                        m.currency,
                        other.currency,
                )
        }</span>

        <span class="cov8" title="1">return m.amount &gt; other.amount, nil</span>
}

// LessThan checks if the current Money object is less than another Money object.
// Invariants enforced:
//   - Currencies must match.
//
// Returns an error if currencies do not match.
func (m *Money) LessThan(other *Money) (bool, error) <span class="cov8" title="1">{
        if !m.IsSameCurrency(other) </span><span class="cov0" title="0">{
                return false, ErrInvalidCurrency
        }</span>
        <span class="cov8" title="1">return m.amount &lt; other.amount, nil</span>
}

// IsSameCurrency checks if the current Money object has the same currency as another Money object.
func (m *Money) IsSameCurrency(other *Money) bool <span class="cov8" title="1">{
        return m.currency == other.currency
}</span>

// IsPositive returns true if the amount is greater than zero.
func (m *Money) IsPositive() bool <span class="cov8" title="1">{
        return m.amount &gt; 0
}</span>

// IsNegative returns true if the amount is less than zero.
func (m *Money) IsNegative() bool <span class="cov0" title="0">{
        return m.amount &lt; 0
}</span>

// IsZero returns true if the amount is zero.
func (m *Money) IsZero() bool <span class="cov8" title="1">{
        return m.amount == 0
}</span>

// Abs returns the absolute value of the Money amount.
func (m *Money) Abs() *Money <span class="cov0" title="0">{
        if m.amount &lt; 0 </span><span class="cov0" title="0">{
                return m.Negate()
        }</span>
        <span class="cov0" title="0">return m</span>
}

// Multiply multiplies the Money amount by a scalar factor.
// Invariants enforced:
//   - Result must not overflow int64.
//
// Returns Money or an error if overflow would occur.
func (m *Money) Multiply(factor float64) (*Money, error) <span class="cov8" title="1">{
        // Convert to float for multiplication
        resultFloat := float64(m.amount) * factor

        // Check for overflow
        if resultFloat &gt; float64(math.MaxInt64) || resultFloat &lt; float64(math.MinInt64) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiplication result would overflow")
        }</span>

        <span class="cov8" title="1">return &amp;Money{
                amount:   Amount(int64(resultFloat)),
                currency: m.currency,
        }, nil</span>
}

// Divide divides the Money amount by a scalar divisor.
// Invariants enforced:
//   - Divisor must not be zero.
//   - Result must not overflow int64.
//   - Division must not lose precision.
//
// Returns Money or an error if any invariant is violated.
func (m *Money) Divide(divisor float64) (*Money, error) <span class="cov8" title="1">{
        if divisor == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("division by zero")
        }</span>

        // Convert to float for division
        <span class="cov8" title="1">resultFloat := float64(m.amount) / divisor

        // Check for overflow
        if resultFloat &gt; float64(math.MaxInt64) || resultFloat &lt; float64(math.MinInt64) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("division result would overflow")
        }</span>

        // Check if result is an integer (no precision loss)
        <span class="cov8" title="1">if resultFloat != float64(int64(resultFloat)) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("division would result in precision loss")
        }</span>

        <span class="cov8" title="1">return &amp;Money{
                amount:   Amount(int64(resultFloat)),
                currency: m.currency,
        }, nil</span>
}

// String returns a string representation of the Money object.
func (m *Money) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%.*f %s", m.currency.Decimals, m.AmountFloat(), m.currency)
}</span>

// convertToSmallestUnit converts a float64 amount to the smallest currency unit.
// This ensures precision by avoiding floating-point arithmetic issues.
func convertToSmallestUnit(amount float64, currency Currency) (int64, error) <span class="cov8" title="1">{
        factor := new(big.Rat).SetFloat64(math.Pow10(currency.Decimals))
        amountRat := new(big.Rat).SetFloat64(amount)
        result := new(big.Rat).Mul(amountRat, factor)

        // Round to nearest integer
        resultFloat, _ := result.Float64()
        return int64(math.Round(resultFloat)), nil
}</span>
</pre>

		<pre class="file" id="file71" style="display: none">package provider

import (
        "context"
        "sync"
        "time"
)

// Cache provides an in-memory cache for exchange rates
type Cache struct {
        store map[string]rateCacheEntry
        mu    sync.RWMutex
        ttl   time.Duration
}

type rateCacheEntry struct {
        value     *RateInfo
        expiresAt time.Time
}

// NewCache creates a new cache with the given TTL
func NewCache(ttl time.Duration) *Cache <span class="cov0" title="0">{
        return &amp;Cache{
                store: make(map[string]rateCacheEntry),
                ttl:   ttl,
        }
}</span>

// GetRate gets a rate from the cache
func (c *Cache) GetRate(ctx context.Context, from, to string) (*RateInfo, error) <span class="cov0" title="0">{
        key := cacheKey(from, to)

        c.mu.RLock()
        defer c.mu.RUnlock()

        entry, exists := c.store[key]
        if !exists </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if time.Now().After(entry.expiresAt) </span><span class="cov0" title="0">{
                // Entry has expired
                return nil, nil
        }</span>

        <span class="cov0" title="0">return entry.value, nil</span>
}

// StoreRate stores a rate in the cache
func (c *Cache) StoreRate(ctx context.Context, rate *RateInfo) error <span class="cov0" title="0">{
        if rate == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">key := cacheKey(rate.FromCurrency, rate.ToCurrency)

        c.mu.Lock()
        defer c.mu.Unlock()

        c.store[key] = rateCacheEntry{
                value:     rate,
                expiresAt: time.Now().Add(c.ttl),
        }

        return nil</span>
}

// BatchGetRates gets multiple rates from the cache
func (c *Cache) BatchGetRates(
        ctx context.Context,
        from string,
        to []string,
) (map[string]*RateInfo, error) <span class="cov0" title="0">{
        result := make(map[string]*RateInfo, len(to))

        c.mu.RLock()
        defer c.mu.RUnlock()

        now := time.Now()

        for _, currency := range to </span><span class="cov0" title="0">{
                key := cacheKey(from, currency)
                if entry, exists := c.store[key]; exists &amp;&amp; now.Before(entry.expiresAt) </span><span class="cov0" title="0">{
                        result[currency] = entry.value
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// Clear removes all entries from the cache
func (c *Cache) Clear() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.store = make(map[string]rateCacheEntry)
}</span>

// cacheKey generates a consistent cache key for a currency pair
func cacheKey(from, to string) string <span class="cov0" title="0">{
        return from + "_" + to
}</span>
</pre>

		<pre class="file" id="file72" style="display: none">package provider

import (
        "context"
        "errors"
        "sync"
        "time"
)

// HealthCheckAll checks the health of all providers and returns a map of results
func HealthCheckAll(
        ctx context.Context,
        providers []HealthChecker,
) map[string]error <span class="cov0" title="0">{
        results := make(map[string]error)
        var mu sync.Mutex
        var wg sync.WaitGroup

        for _, p := range providers </span><span class="cov0" title="0">{
                wrapped, ok := p.(interface{ Metadata() ProviderMetadata })
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">wg.Add(1)
                go func(p HealthChecker, name string) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        err := p.CheckHealth(ctx)
                        mu.Lock()
                        results[name] = err
                        mu.Unlock()
                }</span>(p, wrapped.Metadata().Name)
        }

        <span class="cov0" title="0">wg.Wait()
        return results</span>
}

// FirstHealthy returns the first healthy provider from the list
func FirstHealthy(
        ctx context.Context,
        providers []HealthChecker,
) (HealthChecker, error) <span class="cov0" title="0">{
        for _, p := range providers </span><span class="cov0" title="0">{
                if p.CheckHealth(ctx) == nil </span><span class="cov0" title="0">{
                        return p, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.New("no healthy providers available")</span>
}

// AllHealthy checks if all providers are healthy
func AllHealthy(
        ctx context.Context,
        providers []HealthChecker,
) error <span class="cov0" title="0">{
        var errs []error

        for _, p := range providers </span><span class="cov0" title="0">{
                if err := p.CheckHealth(ctx); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return errors.Join(errs...)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RateStats contains statistics about exchange rates
type RateStats struct {
        Min     float64
        Max     float64
        Average float64
        Count   int
}

// CalculateStats calculates statistics for a set of rates
func CalculateStats(rates []float64) RateStats <span class="cov0" title="0">{
        if len(rates) == 0 </span><span class="cov0" title="0">{
                return RateStats{}
        }</span>

        <span class="cov0" title="0">min := rates[0]
        max := rates[0]
        sum := 0.0

        for _, rate := range rates </span><span class="cov0" title="0">{
                if rate &lt; min </span><span class="cov0" title="0">{
                        min = rate
                }</span>
                <span class="cov0" title="0">if rate &gt; max </span><span class="cov0" title="0">{
                        max = rate
                }</span>
                <span class="cov0" title="0">sum += rate</span>
        }

        <span class="cov0" title="0">return RateStats{
                Min:     min,
                Max:     max,
                Average: sum / float64(len(rates)),
                Count:   len(rates),
        }</span>
}

// RateHistory tracks historical rate data
type RateHistory struct {
        rates []RateInfo
        mu    sync.RWMutex
        size  int
}

// NewRateHistory creates a new RateHistory with the specified maximum size
func NewRateHistory(size int) *RateHistory <span class="cov0" title="0">{
        return &amp;RateHistory{
                rates: make([]RateInfo, 0, size),
                size:  size,
        }
}</span>

// Add adds a new rate to the history
func (h *RateHistory) Add(rate RateInfo) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        h.rates = append(h.rates, rate)

        // Trim the slice if it exceeds the maximum size
        if len(h.rates) &gt; h.size </span><span class="cov0" title="0">{
                h.rates = h.rates[len(h.rates)-h.size:]
        }</span>
}

// Get returns the rate history
func (h *RateHistory) Get() []RateInfo <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        rates := make([]RateInfo, len(h.rates))
        copy(rates, h.rates)
        return rates
}</span>

// Average calculates the average rate over the specified duration
func (h *RateHistory) Average(since time.Time) float64 <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        var sum float64
        var count int

        for _, rate := range h.rates </span><span class="cov0" title="0">{
                if rate.Timestamp.After(since) </span><span class="cov0" title="0">{
                        sum += rate.Rate
                        count++
                }</span>
        }

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return sum / float64(count)</span>
}
</pre>

		<pre class="file" id="file73" style="display: none">package queries

import "github.com/google/uuid"

type GetAccountQuery struct {
        AccountID uuid.UUID
        UserID    uuid.UUID
}

func (q GetAccountQuery) Type() string <span class="cov0" title="0">{ return "GetAccountQuery" }</span>

type GetAccountResult struct {
        AccountID uuid.UUID
        UserID    uuid.UUID
        Balance   float64
        Currency  string
}
</pre>

		<pre class="file" id="file74" style="display: none">package registry

// Deprecated: Use Enhanced instead
// NewEnhancedRegistry was renamed to NewEnhanced for brevity
type EnhancedRegistry = Enhanced

// Deprecated: Use NewEnhanced instead
// NewEnhancedRegistry creates a new enhanced registry
func NewEnhancedRegistry(config Config) *Enhanced <span class="cov0" title="0">{
        return NewEnhanced(config)
}</span>

// Deprecated: Use Provider instead
// RegistryProvider is the old name for the Provider interface
type RegistryProvider = Provider

// Deprecated: Use Config instead
// RegistryConfig is the old name for the Config struct
type RegistryConfig = Config

// Deprecated: Use Entity instead
// RegistryEntity is the old name for the Entity interface
type RegistryEntity = Entity

// Deprecated: Use Cache instead
// RegistryCache is the old name for the Cache interface
type RegistryCache = Cache

// Deprecated: Use Persistence instead
// RegistryPersistence is the old name for the Persistence interface
type RegistryPersistence = Persistence

// Deprecated: Use Metrics instead
// RegistryMetrics is the old name for the Metrics interface
type RegistryMetrics = Metrics

// Deprecated: Use Health instead
// RegistryHealth is the old name for the Health interface
type RegistryHealth = Health

// Deprecated: Use EventBus instead
// RegistryEventBus is the old name for the EventBus interface
type RegistryEventBus = EventBus

// Deprecated: Use Validator instead
// RegistryValidator is the old name for the Validator interface
type RegistryValidator = Validator

// Deprecated: Use Observer instead
// RegistryObserver is the old name for the Observer interface
type RegistryObserver = Observer

// Deprecated: Use Event instead
// RegistryEvent is the old name for the Event struct
type RegistryEvent = Event

// Deprecated: Use Factory instead
// RegistryFactory is the old name for the Factory interface
type RegistryFactory = Factory

// Deprecated: Use FactoryImpl instead
// RegistryFactoryImpl is the old name for the FactoryImpl struct
type RegistryFactoryImpl = FactoryImpl

// Deprecated: Use NewFactory instead
// NewRegistryFactory is the old name for NewFactory
func NewRegistryFactory() Factory <span class="cov8" title="1">{
        return NewFactory()
}</span>

// Deprecated: Use NewBuilder instead
// NewRegistryBuilder is the old name for NewBuilder
func NewRegistryBuilder() *Builder <span class="cov0" title="0">{
        return NewBuilder()
}</span>
</pre>

		<pre class="file" id="file75" style="display: none">package registry

import (
        "context"
        "fmt"
        "log"
        "strconv"
        "strings"
        "sync"
        "time"
)

// Enhanced provides a full-featured registry implementation
type Enhanced struct {
        config      Config
        entities    map[string]Entity
        mu          sync.RWMutex
        observers   []Observer
        validator   Validator
        cache       Cache
        persistence Persistence
        metrics     Metrics
        health      Health
        eventBus    EventBus
}

// NewEnhanced creates a new enhanced registry
func NewEnhanced(config Config) *Enhanced <span class="cov8" title="1">{
        return &amp;Enhanced{
                config:    config,
                entities:  make(map[string]Entity),
                observers: make([]Observer, 0),
        }
}</span>

// WithValidator sets the validator for the registry
func (r *Enhanced) WithValidator(validator Validator) *Enhanced <span class="cov8" title="1">{
        r.validator = validator
        return r
}</span>

// WithCache sets the cache for the registry
func (r *Enhanced) WithCache(cache Cache) *Enhanced <span class="cov8" title="1">{
        r.cache = cache
        return r
}</span>

// WithPersistence sets the persistence layer for the registry
func (r *Enhanced) WithPersistence(persistence Persistence) *Enhanced <span class="cov0" title="0">{
        r.persistence = persistence
        return r
}</span>

// WithMetrics sets the metrics collector for the registry
func (r *Enhanced) WithMetrics(metrics Metrics) *Enhanced <span class="cov8" title="1">{
        r.metrics = metrics
        return r
}</span>

// WithHealth sets the health checker for the registry
func (r *Enhanced) WithHealth(health Health) *Enhanced <span class="cov0" title="0">{
        r.health = health
        return r
}</span>

// WithEventBus sets the event bus for the registry
func (r *Enhanced) WithEventBus(eventBus EventBus) *Enhanced <span class="cov8" title="1">{
        r.eventBus = eventBus
        return r
}</span>

// Register adds or updates an entity in the registry
func (r *Enhanced) Register(ctx context.Context, entity Entity) error <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if r.metrics != nil </span><span class="cov8" title="1">{
                        r.metrics.RecordLatency("register", time.Since(start))
                }</span>
        }()

        // Validate entity if validator is set
        <span class="cov8" title="1">if r.validator != nil </span><span class="cov8" title="1">{
                if err := r.validator.Validate(ctx, entity); err != nil </span><span class="cov8" title="1">{
                        if r.metrics != nil </span><span class="cov0" title="0">{
                                r.metrics.IncrementError()
                        }</span>
                        <span class="cov8" title="1">return fmt.Errorf("validation failed: %w", err)</span>
                }
        }

        // Check max entities limit
        <span class="cov8" title="1">if r.config.MaxEntities &gt; 0 </span><span class="cov0" title="0">{
                r.mu.RLock()
                currentCount := len(r.entities)
                r.mu.RUnlock()
                if currentCount &gt;= r.config.MaxEntities </span><span class="cov0" title="0">{
                        if r.metrics != nil </span><span class="cov0" title="0">{
                                r.metrics.IncrementError()
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("registry is full (max entities: %d)", r.config.MaxEntities)</span>
                }
        }

        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()

        // Check if this is an update
        _, exists := r.entities[entity.ID()]

        // For any entity type, create a new BaseEntity copy to ensure thread safety
        copy := NewBaseEntity(entity.ID(), entity.Name())

        // Copy the active state from the original entity
        copy.SetActive(entity.Active())

        // Copy metadata
        for k, v := range entity.Metadata() </span><span class="cov8" title="1">{
                copy.SetMetadata(k, v)
        }</span>

        // Ensure the active status is reflected in metadata for backward compatibility
        <span class="cov8" title="1">copy.SetMetadata("active", strconv.FormatBool(entity.Active()))

        // Store the copy
        r.entities[copy.ID()] = copy

        // Update cache if enabled
        if r.cache != nil </span><span class="cov8" title="1">{
                if err := r.cache.Set(ctx, entity); err != nil </span><span class="cov0" title="0">{
                        log.Printf("warning: failed to update cache: %v", err)
                }</span>
        }

        // Update persistence if enabled
        <span class="cov8" title="1">if r.persistence != nil </span><span class="cov0" title="0">{
                if err := r.persistence.Save(ctx, r.getAllEntitiesLocked()); err != nil </span><span class="cov0" title="0">{
                        log.Printf("warning: failed to persist registry: %v", err)
                }</span>
        }

        // Update metrics
        <span class="cov8" title="1">if r.metrics != nil </span><span class="cov8" title="1">{
                r.metrics.IncrementRegistration()
                r.metrics.SetEntityCount(len(r.entities))
                r.metrics.SetActiveCount(r.countActiveLocked())
        }</span>

        // Emit event
        <span class="cov8" title="1">if r.eventBus != nil </span><span class="cov8" title="1">{
                eventType := EventEntityRegistered
                if exists </span><span class="cov0" title="0">{
                        eventType = EventEntityUpdated
                }</span>
                <span class="cov8" title="1">if err := r.emitEvent(eventType, entity); err != nil </span><span class="cov0" title="0">{
                        log.Printf("warning: failed to emit %s event: %v", eventType, err)
                }</span>
        }

        // Notify observers
        <span class="cov8" title="1">for _, observer := range r.observers </span><span class="cov0" title="0">{
                if exists </span><span class="cov0" title="0">{
                        observer.OnEntityUpdated(ctx, entity)
                }</span> else<span class="cov0" title="0"> {
                        observer.OnEntityRegistered(ctx, entity)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Get retrieves an entity by ID
func (r *Enhanced) Get(ctx context.Context, id string) (Entity, error) <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if r.metrics != nil </span><span class="cov8" title="1">{
                        r.metrics.RecordLatency("get", time.Since(start))
                }</span>
        }()

        // Try cache first
        <span class="cov8" title="1">if r.cache != nil </span><span class="cov0" title="0">{
                if entity, found := r.cache.Get(ctx, id); found </span><span class="cov0" title="0">{
                        if r.metrics != nil </span><span class="cov0" title="0">{
                                r.metrics.IncrementLookup()
                        }</span>
                        <span class="cov0" title="0">return entity, nil</span>
                }
        }

        <span class="cov8" title="1">r.mu.RLock()
        entity, exists := r.entities[id]
        r.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                if r.metrics != nil </span><span class="cov0" title="0">{
                        r.metrics.IncrementError()
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("entity not found: %s", id)</span>
        }

        // Update cache
        <span class="cov8" title="1">if r.cache != nil </span><span class="cov0" title="0">{
                if err := r.cache.Set(ctx, entity); err != nil </span><span class="cov0" title="0">{
                        // Log cache set error but don't fail the operation
                        log.Printf("warning: failed to update cache for entity %s: %v", entity.ID(), err)
                }</span>
        }

        <span class="cov8" title="1">if r.metrics != nil </span><span class="cov8" title="1">{
                r.metrics.IncrementLookup()
        }</span>

        <span class="cov8" title="1">return entity, nil</span>
}

// Unregister removes an entity from the registry
func (r *Enhanced) Unregister(ctx context.Context, id string) error <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                if r.metrics != nil </span><span class="cov8" title="1">{
                        r.metrics.RecordLatency("unregister", time.Since(start))
                }</span>
        }()

        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.entities[id]; !exists </span><span class="cov0" title="0">{
                if r.metrics != nil </span><span class="cov0" title="0">{
                        r.metrics.IncrementError()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("entity not found: %s", id)</span>
        }

        <span class="cov8" title="1">delete(r.entities, id)

        // Remove from cache if available
        if r.cache != nil </span><span class="cov0" title="0">{
                if err := r.cache.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                        // Log cache delete error but don't fail the operation
                        log.Printf("warning: failed to delete entity %s from cache: %v", id, err)
                }</span>
        }

        // Update metrics
        <span class="cov8" title="1">if r.metrics != nil </span><span class="cov8" title="1">{
                r.metrics.IncrementUnregistration()
                r.metrics.SetEntityCount(len(r.entities))
                activeCount := r.countActiveLocked()
                r.metrics.SetActiveCount(activeCount)
        }</span>

        // Publish event
        <span class="cov8" title="1">if r.eventBus != nil </span><span class="cov8" title="1">{
                event := Event{
                        Type:      EventEntityUnregistered,
                        EntityID:  id,
                        Timestamp: time.Now(),
                }
                if err := r.eventBus.Emit(ctx, event); err != nil </span><span class="cov0" title="0">{
                        // Log event emission error but don't fail the operation
                        log.Printf("warning: failed to emit unregister event for entity %s: %v", id, err)
                }</span>
        }

        // Notify observers
        <span class="cov8" title="1">for _, observer := range r.observers </span><span class="cov0" title="0">{
                observer.OnEntityUnregistered(ctx, id)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsRegistered checks if an entity is registered
func (r *Enhanced) IsRegistered(ctx context.Context, id string) bool <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        _, exists := r.entities[id]
        return exists
}</span>

// List returns all entities
func (r *Enhanced) List(ctx context.Context) ([]Entity, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0, len(r.entities))
        for _, entity := range r.entities </span><span class="cov8" title="1">{
                entities = append(entities, entity)
        }</span>
        <span class="cov8" title="1">return entities, nil</span>
}

// ListActive returns all active entities
func (r *Enhanced) ListActive(ctx context.Context) ([]Entity, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0)
        for _, entity := range r.entities </span><span class="cov0" title="0">{
                if entity.Active() </span><span class="cov0" title="0">{
                        entities = append(entities, entity)
                }</span>
        }
        <span class="cov0" title="0">return entities, nil</span>
}

// ListByMetadata returns entities with specific metadata
func (r *Enhanced) ListByMetadata(
        ctx context.Context,
        key, value string,
) ([]Entity, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0)
        for _, entity := range r.entities </span><span class="cov0" title="0">{
                if metadata := entity.Metadata(); metadata != nil </span><span class="cov0" title="0">{
                        if val, exists := metadata[key]; exists &amp;&amp; val == value </span><span class="cov0" title="0">{
                                entities = append(entities, entity)
                        }</span>
                }
        }
        <span class="cov0" title="0">return entities, nil</span>
}

// Count returns the total number of entities
func (r *Enhanced) Count(ctx context.Context) (int, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return len(r.entities), nil
}</span>

// CountActive returns the number of active entities
func (r *Enhanced) CountActive(ctx context.Context) (int, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.countActiveLocked(), nil
}</span>

// countActiveLocked is a helper method that assumes the lock is already held
func (r *Enhanced) countActiveLocked() int <span class="cov8" title="1">{
        count := 0
        for _, entity := range r.entities </span><span class="cov8" title="1">{
                if entity.Active() </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// GetMetadata retrieves specific metadata for an entity
func (r *Enhanced) GetMetadata(ctx context.Context, id, key string) (string, error) <span class="cov0" title="0">{
        entity, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">metadata := entity.Metadata()
        if val, exists := metadata[key]; exists </span><span class="cov0" title="0">{
                return val, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("metadata key not found: %s", key)</span>
}

// SetMetadata sets specific metadata for an entity
func (r *Enhanced) SetMetadata(ctx context.Context, id, key, value string) error <span class="cov8" title="1">{
        entity, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate metadata if validator is set
        <span class="cov8" title="1">if r.validator != nil </span><span class="cov0" title="0">{
                metadata := entity.Metadata()
                metadata[key] = value
                if err := r.validator.ValidateMetadata(ctx, metadata); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("metadata validation failed: %w", err)
                }</span>
        }

        // Update the entity's metadata using the proper method
        <span class="cov8" title="1">switch e := entity.(type) </span>{
        case *BaseEntity:<span class="cov8" title="1">
                e.SetMetadata(key, value)</span>
        default:<span class="cov0" title="0">
                // Fallback for other implementations
                metadata := entity.Metadata()
                metadata[key] = value</span>
        }

        // Re-register the entity to update it
        <span class="cov8" title="1">return r.Register(ctx, entity)</span>
}

// RemoveMetadata removes specific metadata from an entity
func (r *Enhanced) RemoveMetadata(ctx context.Context, id, key string) error <span class="cov8" title="1">{
        entity, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Remove metadata using the proper method
        <span class="cov8" title="1">switch e := entity.(type) </span>{
        case *BaseEntity:<span class="cov8" title="1">
                e.DeleteMetadata(key)</span>
        default:<span class="cov0" title="0">
                // Fallback for other implementations
                metadata := entity.Metadata()
                delete(metadata, key)</span>
        }

        // Re-register the entity to update it
        <span class="cov8" title="1">return r.Register(ctx, entity)</span>
}

// Activate activates an entity
func (r *Enhanced) Activate(ctx context.Context, id string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        entity, exists := r.entities[id]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("entity not found: %s", id)
        }</span>

        // Use the existing entity's SetActive method if it exists
        <span class="cov0" title="0">if activator, ok := entity.(interface{ SetActive(bool) }); ok </span><span class="cov0" title="0">{
                activator.SetActive(true)
        }</span>

        // Also ensure the active status is set in metadata for backward compatibility
        <span class="cov0" title="0">entity.SetMetadata("active", "true")

        // Update cache if enabled
        if r.cache != nil </span><span class="cov0" title="0">{
                if err := r.cache.Set(ctx, entity); err != nil </span><span class="cov0" title="0">{
                        log.Printf("warning: failed to update cache: %v", err)
                }</span>
        }

        // Update persistence if enabled
        <span class="cov0" title="0">if r.persistence != nil </span><span class="cov0" title="0">{
                if err := r.persistence.Save(ctx, r.getAllEntitiesLocked()); err != nil </span><span class="cov0" title="0">{
                        log.Printf("warning: failed to persist registry: %v", err)
                }</span>
        }

        // Update metrics
        <span class="cov0" title="0">if r.metrics != nil </span><span class="cov0" title="0">{
                // No increment of registration count since it's an update
                r.metrics.SetActiveCount(r.countActiveLocked())
        }</span>

        // Emit event
        <span class="cov0" title="0">if r.eventBus != nil </span><span class="cov0" title="0">{
                eventType := EventEntityActivated
                if !entity.Active() </span><span class="cov0" title="0">{
                        eventType = EventEntityDeactivated
                }</span>
                <span class="cov0" title="0">if err := r.emitEvent(eventType, entity); err != nil </span><span class="cov0" title="0">{
                        log.Printf("warning: failed to emit %s event: %v", eventType, err)
                }</span>
        }

        // Notify observers
        <span class="cov0" title="0">for _, observer := range r.observers </span><span class="cov0" title="0">{
                observer.OnEntityUpdated(ctx, entity)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Deactivate deactivates an entity
func (r *Enhanced) Deactivate(ctx context.Context, id string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        entity, exists := r.entities[id]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("entity not found: %s", id)
        }</span>

        // Use the existing entity's SetActive method if it exists
        <span class="cov0" title="0">if activator, ok := entity.(interface{ SetActive(bool) }); ok </span><span class="cov0" title="0">{
                activator.SetActive(false)
        }</span>

        // Also ensure the active status is set in metadata for backward compatibility
        <span class="cov0" title="0">entity.SetMetadata("active", "false")

        // Update cache if enabled
        if r.cache != nil </span><span class="cov0" title="0">{
                if err := r.cache.Set(ctx, entity); err != nil </span><span class="cov0" title="0">{
                        log.Printf("warning: failed to update cache: %v", err)
                }</span>
        }

        // Update persistence if enabled
        <span class="cov0" title="0">if r.persistence != nil </span><span class="cov0" title="0">{
                if err := r.persistence.Save(ctx, r.getAllEntitiesLocked()); err != nil </span><span class="cov0" title="0">{
                        log.Printf("warning: failed to persist registry: %v", err)
                }</span>
        }

        // Update metrics
        <span class="cov0" title="0">if r.metrics != nil </span><span class="cov0" title="0">{
                // No increment of registration count since it's an update
                r.metrics.SetActiveCount(r.countActiveLocked())
        }</span>

        // Emit event
        <span class="cov0" title="0">if r.eventBus != nil </span><span class="cov0" title="0">{
                if err := r.emitEvent(EventEntityDeactivated, entity); err != nil </span><span class="cov0" title="0">{
                        log.Printf("warning: failed to emit %s event: %v", EventEntityDeactivated, err)
                }</span>
        }

        // Notify observers
        <span class="cov0" title="0">for _, observer := range r.observers </span><span class="cov0" title="0">{
                observer.OnEntityUpdated(ctx, entity)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ...

// Search performs a simple search on entity names
func (r *Enhanced) Search(ctx context.Context, query string) ([]Entity, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0)
        for _, entity := range r.entities </span><span class="cov8" title="1">{
                if contains(entity.Name(), query) </span><span class="cov8" title="1">{
                        entities = append(entities, entity)
                }</span>
        }
        <span class="cov8" title="1">return entities, nil</span>
}

// SearchByMetadata searches entities by metadata
func (r *Enhanced) SearchByMetadata(
        ctx context.Context,
        metadata map[string]string,
) ([]Entity, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        entities := make([]Entity, 0)
        for _, entity := range r.entities </span><span class="cov8" title="1">{
                entityMetadata := entity.Metadata()
                matches := true
                for key, value := range metadata </span><span class="cov8" title="1">{
                        if val, exists := entityMetadata[key]; !exists || val != value </span><span class="cov8" title="1">{
                                matches = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if matches </span><span class="cov8" title="1">{
                        entities = append(entities, entity)
                }</span>
        }
        <span class="cov8" title="1">return entities, nil</span>
}

// AddObserver adds an observer to the registry
func (r *Enhanced) AddObserver(observer Observer) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.observers = append(r.observers, observer)
}</span>

// RemoveObserver removes an observer from the registry
func (r *Enhanced) RemoveObserver(observer Observer) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        for i, obs := range r.observers </span><span class="cov0" title="0">{
                if obs == observer </span><span class="cov0" title="0">{
                        r.observers = append(r.observers[:i], r.observers[i+1:]...)
                        break</span>
                }
        }
}

// contains is a helper function for string search
func contains(s, substr string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr ||
                (len(s) &gt; len(substr) &amp;&amp; (s[:len(substr)] == substr ||
                        s[len(s)-len(substr):] == substr ||
                        containsSubstring(s, substr))))
}</span>

// containsSubstring is a helper function for substring search
func containsSubstring(s, substr string) bool <span class="cov8" title="1">{
        s = strings.ToLower(s)
        substr = strings.ToLower(substr)
        return strings.Contains(s, substr)
}</span>

// emitEvent is a helper method to emit events to the event bus
func (r *Enhanced) emitEvent(eventType string, entity Entity) error <span class="cov8" title="1">{
        event := Event{
                Type:      eventType,
                EntityID:  entity.ID(),
                Entity:    entity,
                Timestamp: time.Now(),
        }

        // Add metadata if available
        if metadata := entity.Metadata(); len(metadata) &gt; 0 </span><span class="cov0" title="0">{
                event.Metadata = make(map[string]interface{})
                for k, v := range metadata </span><span class="cov0" title="0">{
                        event.Metadata[k] = v
                }</span>
        }

        <span class="cov8" title="1">return r.eventBus.Emit(context.Background(), event)</span>
}

// getAllEntitiesLocked returns a slice of all entities in the registry
// The caller must hold the write lock
func (r *Enhanced) getAllEntitiesLocked() []Entity <span class="cov0" title="0">{
        entities := make([]Entity, 0, len(r.entities))
        for _, entity := range r.entities </span><span class="cov0" title="0">{
                entities = append(entities, entity)
        }</span>
        <span class="cov0" title="0">return entities</span>
}
</pre>

		<pre class="file" id="file76" style="display: none">package registry

import (
        "context"
        "fmt"
        "strings"
        "time"
)

// FactoryImpl implements RegistryFactory
type FactoryImpl struct{}

// NewFactory creates a new registry factory
func NewFactory() Factory <span class="cov8" title="1">{
        return &amp;FactoryImpl{}
}</span>

// Create creates a basic registry with the given configuration
func (f *FactoryImpl) Create(
        ctx context.Context,
        config Config,
) (Provider, error) <span class="cov8" title="1">{
        // If Redis URL is provided, use Redis cache
        if config.RedisURL != "" </span><span class="cov0" title="0">{
                return f.CreateWithRedisCache(ctx, config, config.RedisURL)
        }</span>

        // Otherwise, use in-memory cache
        <span class="cov8" title="1">registry := NewEnhanced(config)

        // Add default implementations if not provided
        if config.EnableValidation </span><span class="cov8" title="1">{
                registry.WithValidator(NewSimpleValidator())
        }</span>

        <span class="cov8" title="1">if config.CacheSize &gt; 0 </span><span class="cov8" title="1">{
                registry.WithCache(NewMemoryCache(config.CacheTTL))
        }</span>

        <span class="cov8" title="1">if config.EnableEvents </span><span class="cov8" title="1">{
                registry.WithEventBus(NewSimpleEventBus())
        }</span>

        <span class="cov8" title="1">return registry, nil</span>
}

// CreateWithPersistence creates a registry with persistence
func (f *FactoryImpl) CreateWithPersistence(
        ctx context.Context,
        config Config,
        persistence Persistence,
) (Provider, error) <span class="cov0" title="0">{
        registry := NewEnhanced(config)

        // Add persistence
        registry.WithPersistence(persistence)

        // Load existing entities
        if entities, err := persistence.Load(ctx); err == nil </span><span class="cov0" title="0">{
                for _, entity := range entities </span><span class="cov0" title="0">{
                        if err := registry.Register(ctx, entity); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to load entity %s: %w", entity.ID(), err)
                        }</span>
                }
        }

        // Add other default implementations
        <span class="cov0" title="0">if config.EnableValidation </span><span class="cov0" title="0">{
                registry.WithValidator(NewSimpleValidator())
        }</span>

        <span class="cov0" title="0">if config.CacheSize &gt; 0 </span><span class="cov0" title="0">{
                registry.WithCache(NewMemoryCache(config.CacheTTL))
        }</span>

        <span class="cov0" title="0">if config.EnableEvents </span><span class="cov0" title="0">{
                registry.WithEventBus(NewSimpleEventBus())
        }</span>

        <span class="cov0" title="0">return registry, nil</span>
}

// CreateWithCache creates a registry with custom cache
func (f *FactoryImpl) CreateWithCache(
        ctx context.Context,
        config Config,
        cache Cache,
) (Provider, error) <span class="cov0" title="0">{
        registry := NewEnhanced(config)

        // Add custom cache
        registry.WithCache(cache)

        // Add other default implementations
        if config.EnableValidation </span><span class="cov0" title="0">{
                registry.WithValidator(NewSimpleValidator())
        }</span>

        <span class="cov0" title="0">if config.EnableEvents </span><span class="cov0" title="0">{
                registry.WithEventBus(NewSimpleEventBus())
        }</span>

        <span class="cov0" title="0">return registry, nil</span>
}

// CreateWithRedisCache creates a registry with Redis cache
func (f *FactoryImpl) CreateWithRedisCache(
        ctx context.Context,
        config Config,
        redisURL string,
) (Provider, error) <span class="cov0" title="0">{
        // Create Redis client
        redisClient, err := NewRedisClient(redisURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Redis client: %w", err)
        }</span>

        // Set default key prefix if not specified
        <span class="cov0" title="0">keyPrefix := config.RedisKeyPrefix
        if keyPrefix == "" </span><span class="cov0" title="0">{
                keyPrefix = "registry:"
        }</span> else<span class="cov0" title="0"> if keyPrefix != "" &amp;&amp; !strings.HasSuffix(keyPrefix, ":") </span><span class="cov0" title="0">{
                keyPrefix += ":"
        }</span>

        // Create Redis cache with TTL and key prefix from config
        <span class="cov0" title="0">redisCache := NewRedisCache(redisClient, keyPrefix, config.CacheTTL)

        return f.CreateWithCache(ctx, config, redisCache)</span>
}

// CreateWithMetrics creates a registry with metrics
func (f *FactoryImpl) CreateWithMetrics(
        ctx context.Context,
        config Config,
        metrics Metrics,
) (Provider, error) <span class="cov8" title="1">{
        registry := NewEnhanced(config)

        // Add metrics
        registry.WithMetrics(metrics)

        // Add other default implementations
        if config.EnableValidation </span><span class="cov8" title="1">{
                registry.WithValidator(NewSimpleValidator())
        }</span>

        <span class="cov8" title="1">if config.CacheSize &gt; 0 </span><span class="cov8" title="1">{
                registry.WithCache(NewMemoryCache(config.CacheTTL))
        }</span>

        <span class="cov8" title="1">if config.EnableEvents </span><span class="cov8" title="1">{
                registry.WithEventBus(NewSimpleEventBus())
        }</span>

        <span class="cov8" title="1">return registry, nil</span>
}

// CreateFullFeatured creates a registry with all features enabled,
// including persistence, caching, metrics, and validation.
func (f *FactoryImpl) CreateFullFeatured(
        ctx context.Context,
        config Config,
) (Provider, error) <span class="cov0" title="0">{
        registry := NewEnhanced(config)

        // Add all implementations
        registry.WithValidator(NewSimpleValidator())
        registry.WithCache(NewMemoryCache(config.CacheTTL))
        registry.WithMetrics(NewSimpleMetrics())
        registry.WithHealth(NewSimpleHealth())
        registry.WithEventBus(NewSimpleEventBus())

        // Add persistence if enabled
        if config.EnablePersistence </span><span class="cov0" title="0">{
                persistence := NewFilePersistence(config.PersistencePath)
                registry.WithPersistence(persistence)

                // Load existing entities
                if entities, err := persistence.Load(ctx); err == nil </span><span class="cov0" title="0">{
                        for _, entity := range entities </span><span class="cov0" title="0">{
                                if err := registry.Register(ctx, entity); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to load entity %s: %w", entity.ID(), err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return registry, nil</span>
}

// CreateForTesting creates a registry optimized for testing
func (f *FactoryImpl) CreateForTesting(ctx context.Context) (Provider, error) <span class="cov0" title="0">{
        config := Config{
                Name:             "test-registry",
                MaxEntities:      1000,
                EnableEvents:     false,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }

        registry := NewEnhanced(config)
        registry.WithValidator(NewSimpleValidator())

        return registry, nil
}</span>

// CreateForProduction creates a registry optimized for production use
func (f *FactoryImpl) CreateForProduction(
        ctx context.Context,
        name string,
        persistencePath string,
) (Provider, error) <span class="cov0" title="0">{
        config := Config{
                Name:              name,
                MaxEntities:       10000,
                EnableEvents:      true,
                EnableValidation:  true,
                CacheSize:         1000,
                CacheTTL:          5 * time.Minute,
                EnablePersistence: true,
                PersistencePath:   persistencePath,
                AutoSaveInterval:  30 * time.Second,
        }

        return f.CreateFullFeatured(ctx, config)
}</span>

// CreateForDevelopment creates a registry with development-friendly
// defaults, including in-memory storage and verbose logging.
func (f *FactoryImpl) CreateForDevelopment(
        ctx context.Context,
        name string,
) (Provider, error) <span class="cov0" title="0">{
        config := Config{
                Name:             name,
                MaxEntities:      1000,
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }

        registry := NewEnhanced(config)
        registry.WithValidator(NewSimpleValidator())
        registry.WithMetrics(NewSimpleMetrics())
        registry.WithEventBus(NewSimpleEventBus())

        return registry, nil
}</span>

// Convenience functions for common registry creation patterns

// NewBasicRegistry creates a basic registry with default settings
func NewBasicRegistry() Provider <span class="cov8" title="1">{
        factory := NewRegistryFactory()
        config := Config{
                Name:             "basic-registry",
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }

        registry, _ := factory.Create(context.Background(), config)
        return registry
}</span>

// NewPersistentRegistry creates a registry with file persistence
func NewPersistentRegistry(filePath string) (Provider, error) <span class="cov0" title="0">{
        factory := NewRegistryFactory()
        config := Config{
                Name:              "persistent-registry",
                EnableEvents:      true,
                EnableValidation:  true,
                CacheSize:         100,
                CacheTTL:          time.Minute,
                EnablePersistence: true,
                PersistencePath:   filePath,
                AutoSaveInterval:  time.Minute,
        }

        persistence := NewFilePersistence(filePath)
        return factory.CreateWithPersistence(context.Background(), config, persistence)
}</span>

// NewCachedRegistry creates a registry with enhanced caching
func NewCachedRegistry(cacheSize int, cacheTTL time.Duration) Provider <span class="cov0" title="0">{
        factory := NewRegistryFactory()
        config := Config{
                Name:             "cached-registry",
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        cacheSize,
                CacheTTL:         cacheTTL,
        }

        registry, _ := factory.Create(context.Background(), config)
        return registry
}</span>

// NewMonitoredRegistry creates a registry with metrics and monitoring
func NewMonitoredRegistry(name string) Provider <span class="cov8" title="1">{
        factory := NewRegistryFactory()
        config := Config{
                Name:             name,
                EnableEvents:     true,
                EnableValidation: true,
                CacheSize:        100,
                CacheTTL:         time.Minute,
        }

        metrics := NewSimpleMetrics()
        registry, _ := factory.CreateWithMetrics(context.Background(), config, metrics)
        return registry
}</span>

// BuildRegistry creates a registry with the built configuration
func (b *Builder) BuildRegistry() (Provider, error) <span class="cov8" title="1">{
        factory := NewRegistryFactory()
        return factory.Create(context.Background(), b.Build())
}</span>
</pre>

		<pre class="file" id="file77" style="display: none">package registry

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "sync"
        "time"
)

// MemoryCache implements Cache using in-memory storage
type MemoryCache struct {
        cache map[string]cacheEntry
        mu    sync.RWMutex
        ttl   time.Duration
}

type cacheEntry struct {
        entity    Entity
        expiresAt time.Time
}

// NewMemoryCache creates a new memory cache
func NewMemoryCache(ttl time.Duration) *MemoryCache <span class="cov8" title="1">{
        cache := &amp;MemoryCache{
                cache: make(map[string]cacheEntry),
                ttl:   ttl,
        }

        // Start cleanup goroutine
        go cache.cleanup()

        return cache
}</span>

// Get retrieves an entity from cache
func (c *MemoryCache) Get(ctx context.Context, id string) (Entity, bool) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        entry, exists := c.cache[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Check if expired
        <span class="cov8" title="1">if time.Now().After(entry.expiresAt) </span><span class="cov8" title="1">{
                delete(c.cache, id)
                return nil, false
        }</span>

        <span class="cov8" title="1">return entry.entity, true</span>
}

// Set stores an entity in cache
func (c *MemoryCache) Set(ctx context.Context, entity Entity) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.cache[entity.ID()] = cacheEntry{
                entity:    entity,
                expiresAt: time.Now().Add(c.ttl),
        }

        return nil
}</span>

// Delete removes an entity from cache
func (c *MemoryCache) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.cache, id)
        return nil
}</span>

// Clear removes all entities from cache
func (c *MemoryCache) Clear(ctx context.Context) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.cache = make(map[string]cacheEntry)
        return nil
}</span>

// Size returns the number of cached entities
func (c *MemoryCache) Size() int <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        return len(c.cache)
}</span>

// cleanup removes expired entries
func (c *MemoryCache) cleanup() <span class="cov8" title="1">{
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                c.mu.Lock()
                now := time.Now()
                for id, entry := range c.cache </span><span class="cov0" title="0">{
                        if now.After(entry.expiresAt) </span><span class="cov0" title="0">{
                                delete(c.cache, id)
                        }</span>
                }
                <span class="cov0" title="0">c.mu.Unlock()</span>
        }
}

// FilePersistence implements RegistryPersistence using file storage
type FilePersistence struct {
        filePath string
        mu       sync.Mutex
}

// NewFilePersistence creates a new file persistence layer
func NewFilePersistence(filePath string) *FilePersistence <span class="cov8" title="1">{
        return &amp;FilePersistence{
                filePath: filePath,
        }
}</span>

// Save persists entities to file
func (p *FilePersistence) Save(ctx context.Context, entities []Entity) error <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Convert entities to a serializable format
        var serializable []map[string]interface{}
        for _, entity := range entities </span><span class="cov8" title="1">{
                serializable = append(serializable, map[string]interface{}{
                        "id":         entity.ID(),
                        "name":       entity.Name(),
                        "active":     entity.Active(),
                        "metadata":   entity.Metadata(),
                        "created_at": entity.CreatedAt(),
                        "updated_at": entity.UpdatedAt(),
                })
        }</span>

        // Marshal to JSON
        <span class="cov8" title="1">jsonData, err := json.MarshalIndent(serializable, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal entities: %w", err)
        }</span>

        // Write to file
        <span class="cov8" title="1">if err := os.WriteFile(p.filePath, jsonData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Load loads entities from file
func (p *FilePersistence) Load(ctx context.Context) ([]Entity, error) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Check if file exists
        if _, err := os.Stat(p.filePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return []Entity{}, nil
        }</span>

        // Read file
        <span class="cov8" title="1">data, err := os.ReadFile(p.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        // Parse JSON
        <span class="cov8" title="1">var serializable []map[string]interface{}
        if err := json.Unmarshal(data, &amp;serializable); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse JSON: %w", err)
        }</span>

        // Convert to entities
        <span class="cov8" title="1">var entities []Entity
        for _, item := range serializable </span><span class="cov8" title="1">{
                // Extract fields with type assertions
                id, _ := item["id"].(string)
                name, _ := item["name"].(string)
                active, _ := item["active"].(bool)

                // Handle metadata conversion
                var metadata map[string]string
                if m, ok := item["metadata"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        metadata = make(map[string]string)
                        for k, v := range m </span><span class="cov0" title="0">{
                                if s, ok := v.(string); ok </span><span class="cov0" title="0">{
                                        metadata[k] = s
                                }</span>
                        }
                }

                // Create entity using NewBaseEntity helper
                <span class="cov8" title="1">entity := NewBaseEntity(id, name)
                entity.SetActive(active)
                for k, v := range metadata </span><span class="cov0" title="0">{
                        entity.SetMetadata(k, v)
                }</span>
                // Note: createdAt and updatedAt are set by NewBaseEntity
                <span class="cov8" title="1">entities = append(entities, entity)</span>
        }

        <span class="cov8" title="1">return entities, nil</span>
}

// Delete removes the persistence file
func (p *FilePersistence) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        // For file persistence, we don't delete individual entities
        // The entire file is rewritten on save
        return nil
}</span>

// Clear removes the persistence file
func (p *FilePersistence) Clear(ctx context.Context) error <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        return os.Remove(p.filePath)
}</span>

// SimpleMetrics implements Metrics using simple counters
type SimpleMetrics struct {
        registrations   int64
        unregistrations int64
        lookups         int64
        errors          int64
        entityCount     int
        activeCount     int
        latencies       map[string][]time.Duration
        mu              sync.RWMutex
}

// NewSimpleMetrics creates a new simple metrics collector
func NewSimpleMetrics() *SimpleMetrics <span class="cov8" title="1">{
        return &amp;SimpleMetrics{
                latencies: make(map[string][]time.Duration),
        }
}</span>

// IncrementRegistration increments the registration counter
func (m *SimpleMetrics) IncrementRegistration() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.registrations++
}</span>

// IncrementUnregistration increments the unregistration counter
func (m *SimpleMetrics) IncrementUnregistration() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.unregistrations++
}</span>

// IncrementLookup increments the lookup counter
func (m *SimpleMetrics) IncrementLookup() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.lookups++
}</span>

// IncrementError increments the error counter
func (m *SimpleMetrics) IncrementError() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.errors++
}</span>

// SetEntityCount sets the entity count
func (m *SimpleMetrics) SetEntityCount(count int) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.entityCount = count
}</span>

// SetActiveCount sets the active entity count
func (m *SimpleMetrics) SetActiveCount(count int) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.activeCount = count
}</span>

// RecordLatency records operation latency
func (m *SimpleMetrics) RecordLatency(operation string, duration time.Duration) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.latencies[operation] == nil </span><span class="cov8" title="1">{
                m.latencies[operation] = make([]time.Duration, 0)
        }</span>
        <span class="cov8" title="1">m.latencies[operation] = append(m.latencies[operation], duration)

        // Keep only last 100 latencies per operation
        if len(m.latencies[operation]) &gt; 100 </span><span class="cov0" title="0">{
                m.latencies[operation] = m.latencies[operation][len(m.latencies[operation])-100:]
        }</span>
}

// GetStats returns current metrics statistics
func (m *SimpleMetrics) GetStats() map[string]interface{} <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        stats := map[string]interface{}{
                "registrations":   m.registrations,
                "unregistrations": m.unregistrations,
                "lookups":         m.lookups,
                "errors":          m.errors,
                "entity_count":    m.entityCount,
                "active_count":    m.activeCount,
                "latencies":       m.latencies,
        }

        return stats
}</span>

// SimpleEventBus implements RegistryEventBus using in-memory event handling
type SimpleEventBus struct {
        observers []Observer
        mu        sync.RWMutex
}

// NewSimpleEventBus creates a new simple event bus
func NewSimpleEventBus() *SimpleEventBus <span class="cov8" title="1">{
        return &amp;SimpleEventBus{
                observers: make([]Observer, 0),
        }
}</span>

// Subscribe adds an observer to the event bus
func (b *SimpleEventBus) Subscribe(observer Observer) error <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        b.observers = append(b.observers, observer)
        return nil
}</span>

// Unsubscribe removes an observer from the event bus
func (b *SimpleEventBus) Unsubscribe(observer Observer) error <span class="cov0" title="0">{
        b.mu.Lock()
        defer b.mu.Unlock()

        for i, obs := range b.observers </span><span class="cov0" title="0">{
                if obs == observer </span><span class="cov0" title="0">{
                        b.observers = append(b.observers[:i], b.observers[i+1:]...)
                        break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Publish publishes an event to all observers
func (b *SimpleEventBus) Emit(ctx context.Context, event Event) error <span class="cov8" title="1">{
        b.mu.RLock()
        observers := make([]Observer, len(b.observers))
        copy(observers, b.observers)
        b.mu.RUnlock()

        for _, observer := range observers </span><span class="cov8" title="1">{
                switch event.Type </span>{
                case EventEntityRegistered:<span class="cov8" title="1">
                        observer.OnEntityRegistered(ctx, event.Entity)</span>
                case EventEntityUnregistered:<span class="cov8" title="1">
                        observer.OnEntityUnregistered(ctx, event.EntityID)</span>
                case EventEntityUpdated:<span class="cov0" title="0">
                        observer.OnEntityUpdated(ctx, event.Entity)</span>
                case EventEntityActivated:<span class="cov0" title="0">
                        observer.OnEntityActivated(ctx, event.EntityID)</span>
                case EventEntityDeactivated:<span class="cov0" title="0">
                        observer.OnEntityDeactivated(ctx, event.EntityID)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// SimpleValidator implements Validator with basic validation
type SimpleValidator struct {
        requiredMetadata  []string
        forbiddenMetadata []string
        validators        map[string]func(string) error
}

// NewSimpleValidator creates a new simple validator
func NewSimpleValidator() *SimpleValidator <span class="cov8" title="1">{
        return &amp;SimpleValidator{
                requiredMetadata:  make([]string, 0),
                forbiddenMetadata: make([]string, 0),
                validators:        make(map[string]func(string) error),
        }
}</span>

// WithRequiredMetadata sets required metadata fields
func (v *SimpleValidator) WithRequiredMetadata(fields []string) *SimpleValidator <span class="cov0" title="0">{
        v.requiredMetadata = fields
        return v
}</span>

// WithForbiddenMetadata sets forbidden metadata fields
func (v *SimpleValidator) WithForbiddenMetadata(fields []string) *SimpleValidator <span class="cov0" title="0">{
        v.forbiddenMetadata = fields
        return v
}</span>

// WithValidator adds a custom validator for a metadata field
func (v *SimpleValidator) WithValidator(
        field string,
        validator func(string) error,
) *SimpleValidator <span class="cov0" title="0">{
        v.validators[field] = validator
        return v
}</span>

// Validate validates an entity
func (v *SimpleValidator) Validate(ctx context.Context, entity Entity) error <span class="cov8" title="1">{
        if entity.ID() == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("entity ID is required")
        }</span>
        <span class="cov8" title="1">if entity.Name() == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("entity name is required")
        }</span>
        <span class="cov8" title="1">return v.ValidateMetadata(ctx, entity.Metadata())</span>
}

// ValidateMetadata validates entity metadata
func (v *SimpleValidator) ValidateMetadata(ctx context.Context, metadata map[string]string) error <span class="cov8" title="1">{
        // Check required metadata
        for _, required := range v.requiredMetadata </span><span class="cov0" title="0">{
                if _, exists := metadata[required]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("required metadata field missing: %s", required)
                }</span>
        }

        // Check forbidden metadata
        <span class="cov8" title="1">for _, forbidden := range v.forbiddenMetadata </span><span class="cov0" title="0">{
                if _, exists := metadata[forbidden]; exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("forbidden metadata field present: %s", forbidden)
                }</span>
        }

        // Run custom validators
        <span class="cov8" title="1">for field, validator := range v.validators </span><span class="cov0" title="0">{
                if value, exists := metadata[field]; exists </span><span class="cov0" title="0">{
                        if err := validator(value); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("validation failed for field %s: %w", field, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// SimpleHealth implements Health with basic health checking
type SimpleHealth struct {
        lastError error
        mu        sync.RWMutex
}

// NewSimpleHealth creates a new simple health checker
func NewSimpleHealth() *SimpleHealth <span class="cov0" title="0">{
        return &amp;SimpleHealth{}
}</span>

// IsHealthy checks if the registry is healthy
func (h *SimpleHealth) IsHealthy(ctx context.Context) bool <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        return h.lastError == nil
}</span>

// GetHealthStatus returns the health status
func (h *SimpleHealth) GetHealthStatus(ctx context.Context) map[string]interface{} <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        status := map[string]interface{}{
                "healthy":   h.lastError == nil,
                "timestamp": time.Now(),
        }

        if h.lastError != nil </span><span class="cov0" title="0">{
                status["last_error"] = h.lastError.Error()
        }</span>

        <span class="cov0" title="0">return status</span>
}

// GetLastError returns the last error
func (h *SimpleHealth) GetLastError() error <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        return h.lastError
}</span>

// SetError sets the last error
func (h *SimpleHealth) SetError(err error) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        h.lastError = err
}</span>

// ClearError clears the last error
func (h *SimpleHealth) ClearError() <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        h.lastError = nil
}</span>
</pre>

		<pre class="file" id="file78" style="display: none">package registry

import (
        "errors"
        "sync"
        "time"
)

// BaseEntity provides a thread-safe implementation of the EntityCore interface.
// It's designed to be embedded in domain-specific entity types to provide common
// functionality like ID management, metadata, and lifecycle tracking.
//
// BaseEntity implements all core interfaces (Identifiable, Named, ActiveStatusChecker,
// MetadataController, Timestamped) and the composite Entity interface.
// All methods are safe for concurrent access.
type BaseEntity struct {
        mu        sync.RWMutex
        id        string
        name      string
        active    bool
        metadata  map[string]string
        createdAt time.Time
        updatedAt time.Time

        // Backward compatibility fields
        // Deprecated: Use ID() and Name() instead
        BEId string
        // Deprecated: Use Name() and SetName() instead
        BEName string
        // Deprecated: Use IsActive() and SetActive() instead
        BEActive bool
        // Deprecated: Use Metadata() and SetMetadata() instead
        BEMetadata map[string]string
        // Deprecated: Use CreatedAt() instead
        BECreatedAt time.Time
        // Deprecated: Use UpdatedAt() instead
        BEUpdatedAt time.Time
}

// NewBaseEntity creates a new BaseEntity with the specified ID and name.
// Both ID and name must be non-empty strings.
//
// This function returns a concrete *BaseEntity type. If you need the Entity interface,
// the return value can be assigned to an Entity variable.
func NewBaseEntity(id, name string) *BaseEntity <span class="cov0" title="0">{
        now := time.Now().UTC()
        return &amp;BaseEntity{
                id:        id,
                name:      name,
                active:    true,
                metadata:  make(map[string]string),
                createdAt: now,
                updatedAt: now,
                // Backward compatibility
                BEId:       id,
                BEName:     name,
                BEActive:   true,
                BEMetadata: make(map[string]string),
        }
}</span>

// ID returns the entity's unique identifier.
// This method is safe for concurrent access.
func (e *BaseEntity) ID() string <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        // Backward compatibility
        if e.id == "" &amp;&amp; e.BEId != "" </span><span class="cov0" title="0">{
                e.id = e.BEId
        }</span>
        <span class="cov0" title="0">return e.id</span>
}

// SetID updates the entity's ID and updates the updated timestamp.
// This method is safe for concurrent access.
func (e *BaseEntity) SetID(id string) error <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return errors.New("id cannot be empty")
        }</span>

        <span class="cov0" title="0">e.mu.Lock()
        defer e.mu.Unlock()

        e.id = id
        // Backward compatibility
        e.BEId = id
        e.updatedAt = time.Now().UTC()
        return nil</span>
}

// Name returns the entity's name.
// This method is safe for concurrent access.
func (e *BaseEntity) Name() string <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        // Backward compatibility
        if e.name == "" &amp;&amp; e.BEName != "" </span><span class="cov0" title="0">{
                e.name = e.BEName
        }</span>
        <span class="cov0" title="0">return e.name</span>
}

// SetName updates the entity's name and updates the updated timestamp.
// This method is safe for concurrent access.
func (e *BaseEntity) SetName(name string) error <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return errors.New("name cannot be empty")
        }</span>

        <span class="cov0" title="0">e.mu.Lock()
        defer e.mu.Unlock()

        e.name = name
        // Backward compatibility
        e.BEName = name
        e.updatedAt = time.Now().UTC()
        return nil</span>
}

// IsActive returns whether the entity is currently active.
// This method is safe for concurrent access.
func (e *BaseEntity) IsActive() bool <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        // Backward compatibility
        if !e.active &amp;&amp; e.BEActive </span><span class="cov0" title="0">{
                e.active = e.BEActive
        }</span>
        <span class="cov0" title="0">return e.active || e.BEActive</span>
}

// SetActive updates the entity's active status and updates the updated timestamp.
// This method is safe for concurrent access.
func (e *BaseEntity) SetActive(active bool) <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if e.active != active </span><span class="cov0" title="0">{
                e.active = active
                // Backward compatibility
                e.BEActive = active
                e.updatedAt = time.Now().UTC()
        }</span>
}

// Metadata returns a copy of the entity's metadata.
// This method is safe for concurrent access and returns a defensive copy.
func (e *BaseEntity) Metadata() map[string]string <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        // Backward compatibility - initialize from BEMetadata if needed
        if e.metadata == nil &amp;&amp; e.BEMetadata != nil </span><span class="cov0" title="0">{
                e.metadata = make(map[string]string, len(e.BEMetadata))
                for k, v := range e.BEMetadata </span><span class="cov0" title="0">{
                        e.metadata[k] = v
                }</span>
        }

        <span class="cov0" title="0">if e.metadata == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Return a copy to prevent external modification
        <span class="cov0" title="0">result := make(map[string]string, len(e.metadata))
        for k, v := range e.metadata </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

// SetMetadata sets a metadata key-value pair and updates the updated timestamp.
// This method is safe for concurrent access.
func (e *BaseEntity) SetMetadata(key, value string) <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if e.metadata == nil </span><span class="cov0" title="0">{
                e.metadata = make(map[string]string)
        }</span>

        <span class="cov0" title="0">e.metadata[key] = value
        // Backward compatibility
        if e.BEMetadata == nil </span><span class="cov0" title="0">{
                e.BEMetadata = make(map[string]string)
        }</span>
        <span class="cov0" title="0">e.BEMetadata[key] = value
        e.updatedAt = time.Now().UTC()</span>
}

// DeleteMetadata removes a metadata key and updates the updated timestamp.
// This method is safe for concurrent access.
func (e *BaseEntity) DeleteMetadata(key string) <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if e.metadata != nil </span><span class="cov0" title="0">{
                delete(e.metadata, key)
        }</span>

        // Backward compatibility
        <span class="cov0" title="0">if e.BEMetadata != nil </span><span class="cov0" title="0">{
                delete(e.BEMetadata, key)
        }</span>

        <span class="cov0" title="0">e.updatedAt = time.Now().UTC()</span>
}

// ClearMetadata removes all metadata and updates the updated timestamp.
// This method is safe for concurrent access.
func (e *BaseEntity) ClearMetadata() <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()

        e.metadata = make(map[string]string)
        // Backward compatibility
        e.BEMetadata = make(map[string]string)
        e.updatedAt = time.Now().UTC()
}</span>

// CreatedAt returns when the entity was created.
// This method is safe for concurrent access.
func (e *BaseEntity) CreatedAt() time.Time <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        return e.createdAt
}</span>

// UpdatedAt returns when the entity was last updated.
// This method is safe for concurrent access.
func (e *BaseEntity) UpdatedAt() time.Time <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        return e.updatedAt
}</span>
</pre>

		<pre class="file" id="file79" style="display: none">package registry

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "maps"
        "strings"
        "sync"
        "time"
)

// Core interfaces following Go's idiomatic naming conventions

// Basic interfaces (single-method)
type Identifier interface {
        ID() string
}

type IDSetter interface {
        SetID(id string) error
}

type Named interface {
        Name() string
}

type NameSetter interface {
        SetName(name string) error
}

// ActiveStatusChecker defines the interface for checking if an entity is active
type ActiveStatusChecker interface {
        Active() bool
}

type ActivationSetter interface {
        SetActive(active bool)
}

type MetadataReader interface {
        Metadata() map[string]string
}

type MetadataWriter interface {
        SetMetadata(key, value string)
}

type MetadataDeleter interface {
        DeleteMetadata(key string)
}

type MetadataClearer interface {
        ClearMetadata()
}

type Timestamped interface {
        CreatedAt() time.Time
        UpdatedAt() time.Time
}

// Composite interfaces
type Identifiable interface {
        Identifier
        IDSetter
}

type Nameable interface {
        Named
        NameSetter
}

type ActivationController interface {
        ActiveStatusChecker
        ActivationSetter
}

type MetadataController interface {
        MetadataReader
        MetadataWriter
        MetadataDeleter
        MetadataClearer
}

type EntityCore interface {
        Identifiable
        Nameable
        ActivationController
        MetadataController
        Timestamped
}

// Entity is the main interface that all registry entities must implement
// It's a composition of smaller, focused interfaces
// Deprecated: Use EntityCore for new code
type Entity = EntityCore

// EntityFactory creates new entity instances
type EntityFactory interface {
        NewEntity(id, name string) (EntityCore, error)
}

// EntityValidator validates entity state
type EntityValidator interface {
        Validate() error
}

// EntityLifecycle defines hooks for entity lifecycle events
type EntityLifecycle interface {
        BeforeCreate() error
        AfterCreate() error
        BeforeUpdate() error
        AfterUpdate() error
        BeforeDelete() error
        AfterDelete() error
}

// EntityFull combines all entity-related interfaces
type EntityFull interface {
        EntityCore
        EntityValidator
        EntityLifecycle
}

// Provider defines the interface for registry implementations
type Provider interface {
        // Core operations
        Register(ctx context.Context, entity Entity) error
        Get(ctx context.Context, id string) (Entity, error)
        Unregister(ctx context.Context, id string) error
        IsRegistered(ctx context.Context, id string) bool

        // Listing operations
        List(ctx context.Context) ([]Entity, error)
        ListActive(ctx context.Context) ([]Entity, error)
        ListByMetadata(ctx context.Context, key, value string) ([]Entity, error)

        // Counting operations
        Count(ctx context.Context) (int, error)
        CountActive(ctx context.Context) (int, error)

        // Metadata operations
        GetMetadata(ctx context.Context, id, key string) (string, error)
        SetMetadata(ctx context.Context, id, key, value string) error
        RemoveMetadata(ctx context.Context, id, key string) error

        // Lifecycle operations
        Activate(ctx context.Context, id string) error
        Deactivate(ctx context.Context, id string) error

        // Search operations
        Search(ctx context.Context, query string) ([]Entity, error)
        SearchByMetadata(ctx context.Context, metadata map[string]string) ([]Entity, error)
}

// Observer defines the interface for registry event observers
type Observer interface {
        OnEntityRegistered(ctx context.Context, entity Entity)
        OnEntityUnregistered(ctx context.Context, id string)
        OnEntityUpdated(ctx context.Context, entity Entity)
        OnEntityActivated(ctx context.Context, id string)
        OnEntityDeactivated(ctx context.Context, id string)
}

// Event represents a registry event
type Event struct {
        Type      string                 `json:"type"`
        EntityID  string                 `json:"entity_id"`
        Entity    Entity                 `json:"entity,omitempty"`
        Timestamp time.Time              `json:"timestamp"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// EventType constants
const (
        EventEntityRegistered   = "entity_registered"
        EventEntityUnregistered = "entity_unregistered"
        EventEntityUpdated      = "entity_updated"
        EventEntityActivated    = "entity_activated"
        EventEntityDeactivated  = "entity_deactivated"
)

// EventBus defines the interface for registry event handling
type EventBus interface {
        Subscribe(observer Observer) error
        Unsubscribe(observer Observer) error
        Emit(ctx context.Context, event Event) error
}

// Config holds configuration for registry implementations
type Config struct {
        Name             string        `json:"name"`
        MaxEntities      int           `json:"max_entities"`
        DefaultTTL       time.Duration `json:"default_ttl"`
        EnableEvents     bool          `json:"enable_events"`
        EnableValidation bool          `json:"enable_validation"`

        // Cache settings
        CacheSize int           `json:"cache_size"`
        CacheTTL  time.Duration `json:"cache_ttl"`

        // Redis cache settings
        RedisURL          string        `json:"redis_url"`            // Redis server URL
        RedisKeyPrefix    string        `json:"redis_key_prefix"`     // Prefix for Redis keys
        RedisPoolSize     int           `json:"redis_pool_size"`      // Max connections in pool
        RedisMinIdleConns int           `json:"redis_min_idle_conns"` // Min idle connections
        RedisMaxRetries   int           `json:"redis_max_retries"`    // Max retries for commands
        RedisDialTimeout  time.Duration `json:"redis_dial_timeout"`   // Dial timeout
        RedisReadTimeout  time.Duration `json:"redis_read_timeout"`   // Read timeout
        RedisWriteTimeout time.Duration `json:"redis_write_timeout"`  // Write timeout

        // Advanced features
        EnableCompression bool   `json:"enable_compression"`
        EnablePersistence bool   `json:"enable_persistence"`
        PersistencePath   string `json:"persistence_path"`

        // Auto-save settings
        AutoSaveInterval time.Duration `json:"auto_save_interval"`

        // Metadata validation
        RequiredMetadata   []string                      `json:"required_metadata"`
        ForbiddenMetadata  []string                      `json:"forbidden_metadata"`
        MetadataValidators map[string]func(string) error `json:"-"`
}

// Validator defines the interface for entity validation
type Validator interface {
        Validate(ctx context.Context, entity Entity) error
        ValidateMetadata(ctx context.Context, metadata map[string]string) error
}

// Persistence defines the interface for registry persistence
type Persistence interface {
        Save(ctx context.Context, entities []Entity) error
        Load(ctx context.Context) ([]Entity, error)
        Delete(ctx context.Context, id string) error
        Clear(ctx context.Context) error
}

// Cache defines the interface for registry caching
type Cache interface {
        Get(ctx context.Context, id string) (Entity, bool)
        Set(ctx context.Context, entity Entity) error
        Delete(ctx context.Context, id string) error
        Clear(ctx context.Context) error
        Size() int
}

// Metrics defines the interface for registry metrics
type Metrics interface {
        IncrementRegistration()
        IncrementUnregistration()
        IncrementLookup()
        IncrementError()
        SetEntityCount(count int)
        SetActiveCount(count int)
        RecordLatency(operation string, duration time.Duration)
}

// Health defines the interface for registry health checks
type Health interface {
        IsHealthy(ctx context.Context) bool
        GetHealthStatus(ctx context.Context) map[string]interface{}
        GetLastError() error
}

// Factory defines the interface for creating registry instances
type Factory interface {
        Create(
                ctx context.Context,
                config Config,
        ) (Provider, error)
        CreateWithPersistence(
                ctx context.Context,
                config Config,
                persistence Persistence,
        ) (Provider, error)
        CreateWithCache(
                ctx context.Context,
                config Config,
                cache Cache,
        ) (Provider, error)
        CreateWithMetrics(
                ctx context.Context,
                config Config,
                metrics Metrics,
        ) (Provider, error)
}

// BaseEntity provides a thread-safe default implementation of core entity interfaces.
// It serves as a foundation for domain-specific entities by providing common
// functionality including:
//   - Unique identifier management (ID)
//   - Naming and activation state
//   - Key-value metadata storage
//   - Creation and modification timestamps
//   - Concurrent access safety
//
// BaseEntity implements the following interfaces:
//   - Identifiable: For ID management
//   - Named: For name-related operations
//   - ActivationController: For activation state management
//   - MetadataController: For metadata operations
//   - Timestamped: For creation/update timestamps
//   - Entity: Composite interface for backward compatibility
//
// Example usage:
//
//        type User struct {
//                registry.BaseEntity
//                Email    string
//                Password string `json:"-"`
//        }
//
// All exported methods are safe for concurrent access. The struct uses a read-write mutex
// to protect all internal state. When embedding BaseEntity, ensure proper initialization
// of the embedded fields.
type BaseEntity struct {
        id        string
        name      string
        active    bool
        metadata  map[string]string
        createdAt time.Time
        updatedAt time.Time
        mu        sync.RWMutex

        // Deprecated: Use ID() and SetID() methods instead
        BEId string
        // Deprecated: Use Name() and SetName() methods instead
        BEName string
        // Deprecated: Use Active() and SetActive() methods instead
        BEActive bool
        // Deprecated: Use Metadata() and related methods instead
        BEMetadata map[string]string
        // Deprecated: Use CreatedAt() and UpdatedAt() methods instead
        BECreatedAt time.Time
        // Deprecated: Use CreatedAt() and UpdatedAt() methods instead
        BEUpdatedAt time.Time
}

// MarshalJSON implements the json.Marshaler interface.
// It provides custom JSON marshaling for BaseEntity.
// This method is safe for concurrent access.
func (e *BaseEntity) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        // Create a map to hold the JSON representation
        data := map[string]interface{}{
                "id":         e.id,
                "name":       e.name,
                "active":     e.active,
                "created_at": e.createdAt.Format(time.RFC3339Nano),
                "updated_at": e.updatedAt.Format(time.RFC3339Nano),
        }

        // Include all metadata fields at the root level for backward compatibility
        if len(e.metadata) &gt; 0 </span><span class="cov0" title="0">{
                // Create a copy of the metadata to avoid concurrent access issues
                metadataCopy := make(map[string]string, len(e.metadata))
                for k, v := range e.metadata </span><span class="cov0" title="0">{
                        metadataCopy[k] = v
                        // Add each metadata field to the root level for backward compatibility
                        data[k] = v
                }</span>
                // Also include the full metadata object
                <span class="cov0" title="0">data["metadata"] = metadataCopy</span>
        }

        <span class="cov0" title="0">return json.Marshal(data)</span>
}

// UnmarshalJSON implements the json.Unmarshaler interface.
// It provides custom JSON unmarshaling for BaseEntity.
// This method is safe for concurrent access.
func (e *BaseEntity) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        // Use a type alias to avoid recursion
        type Alias BaseEntity

        // Create an auxiliary struct to handle the JSON unmarshaling
        aux := &amp;struct {
                *Alias
                CreatedAt string `json:"created_at"`
                UpdatedAt string `json:"updated_at"`
        }{
                Alias: (*Alias)(e),
        }

        // First, unmarshal into a map to handle all fields
        var rawData map[string]json.RawMessage
        if err := json.Unmarshal(data, &amp;rawData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal BaseEntity: %w", err)
        }</span>

        // Unmarshal the standard fields
        <span class="cov0" title="0">if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal BaseEntity: %w", err)
        }</span>

        // Parse the timestamps
        <span class="cov0" title="0">var err error
        if aux.CreatedAt != "" </span><span class="cov0" title="0">{
                e.createdAt, err = time.Parse(time.RFC3339Nano, aux.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse created_at: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if aux.UpdatedAt != "" </span><span class="cov0" title="0">{
                e.updatedAt, err = time.Parse(time.RFC3339Nano, aux.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse updated_at: %w", err)
                }</span>
        }

        // Initialize the metadata map
        <span class="cov0" title="0">e.mu.Lock()
        defer e.mu.Unlock()

        if e.metadata == nil </span><span class="cov0" title="0">{
                e.metadata = make(map[string]string)
        }</span>

        // Handle metadata from the metadata object if it exists
        <span class="cov0" title="0">if metadataData, ok := rawData["metadata"]; ok </span><span class="cov0" title="0">{
                var metadata map[string]string
                if err := json.Unmarshal(metadataData, &amp;metadata); err == nil </span><span class="cov0" title="0">{
                        for k, v := range metadata </span><span class="cov0" title="0">{
                                e.metadata[k] = v
                        }</span>
                }
        }

        // Handle direct metadata fields that might be at the root level
        <span class="cov0" title="0">for k, v := range rawData </span><span class="cov0" title="0">{
                // Skip standard fields that we already handle
                switch k </span>{
                case "id", "name", "active", "created_at", "updated_at", "metadata":<span class="cov0" title="0">
                        continue</span>
                }

                // For other fields, try to unmarshal as string and add to metadata
                <span class="cov0" title="0">var strVal string
                if err := json.Unmarshal(v, &amp;strVal); err == nil </span><span class="cov0" title="0">{
                        e.metadata[k] = strVal
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Ensure BaseEntity implements all interfaces
var (
        _ Identifiable         = (*BaseEntity)(nil)
        _ Named                = (*BaseEntity)(nil)
        _ ActivationController = (*BaseEntity)(nil)
        _ MetadataController   = (*BaseEntity)(nil)
        _ Timestamped          = (*BaseEntity)(nil)
        _ Entity               = (*BaseEntity)(nil) // For backward compatibility
)

// DeleteMetadata removes a metadata key from the entity.
// It's safe for concurrent access.
func (e *BaseEntity) DeleteMetadata(key string) <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if e.metadata == nil </span><span class="cov0" title="0">{
                e.metadata = make(map[string]string)
                return
        }</span>

        <span class="cov8" title="1">delete(e.metadata, key)
        e.updatedAt = time.Now().UTC()</span>
}

// SetID sets the ID of the entity.
// It's safe for concurrent access.
func (e *BaseEntity) SetID(id string) error <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if id == "" </span><span class="cov0" title="0">{
                return errors.New("id cannot be empty")
        }</span>

        <span class="cov0" title="0">e.id = id
        e.BEId = id // For backward compatibility
        e.updatedAt = time.Now().UTC()
        return nil</span>
}

// SetName sets the name of the entity.
// It's safe for concurrent access.
func (e *BaseEntity) SetName(name string) error <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if name == "" </span><span class="cov0" title="0">{
                return errors.New("name cannot be empty")
        }</span>

        <span class="cov0" title="0">e.name = name
        e.BEName = name // For backward compatibility
        e.updatedAt = time.Now().UTC()
        return nil</span>
}

// SetActive sets the active state of the entity.
// It's safe for concurrent access.
func (e *BaseEntity) SetActive(active bool) <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        e.active = active
        e.BEActive = active // For backward compatibility
        e.updatedAt = time.Now().UTC()
}</span>

// SetMetadata sets a metadata key-value pair.
// It's safe for concurrent access.
func (e *BaseEntity) SetMetadata(key, value string) <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if e.metadata == nil </span><span class="cov0" title="0">{
                e.metadata = make(map[string]string)
        }</span>

        <span class="cov8" title="1">e.metadata[key] = value

        // For backward compatibility
        if e.BEMetadata == nil </span><span class="cov0" title="0">{
                e.BEMetadata = make(map[string]string)
        }</span>
        <span class="cov8" title="1">e.BEMetadata[key] = value

        e.updatedAt = time.Now().UTC()</span>
}

// ClearMetadata removes all metadata from the entity.
// It's safe for concurrent access.
func (e *BaseEntity) ClearMetadata() <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()

        e.metadata = make(map[string]string)
        e.BEMetadata = make(map[string]string) // For backward compatibility
        e.updatedAt = time.Now().UTC()
}</span>

// Metadata returns a copy of the entity's metadata.
// It's safe for concurrent access.
func (e *BaseEntity) Metadata() map[string]string <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        // Return a copy to prevent external modifications
        result := make(map[string]string, len(e.metadata))
        maps.Copy(result, e.metadata)
        return result
}</span>

// ID returns the entity's ID.
// It's safe for concurrent access.
func (e *BaseEntity) ID() string <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        if e.id == "" &amp;&amp; e.BEId != "" </span><span class="cov8" title="1">{
                return e.BEId // For backward compatibility
        }</span>
        <span class="cov8" title="1">return e.id</span>
}

// Name returns the entity's name.
// It's safe for concurrent access.
func (e *BaseEntity) Name() string <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        if e.name == "" &amp;&amp; e.BEName != "" </span><span class="cov8" title="1">{
                return e.BEName // For backward compatibility
        }</span>
        <span class="cov8" title="1">return e.name</span>
}

// Active returns whether the entity is active.
// It's safe for concurrent access.
func (e *BaseEntity) Active() bool <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        return e.active || e.BEActive // For backward compatibility
}</span>

// CreatedAt returns when the entity was created.
// It's safe for concurrent access.
func (e *BaseEntity) CreatedAt() time.Time <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        return e.createdAt
}</span>

// UpdatedAt returns when the entity was last updated.
// It's safe for concurrent access.
func (e *BaseEntity) UpdatedAt() time.Time <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        return e.updatedAt
}</span>

// Ensure BaseEntity implements all the interfaces it's meant to support
var (
        _ Identifier           = (*BaseEntity)(nil)
        _ IDSetter             = (*BaseEntity)(nil)
        _ NameSetter           = (*BaseEntity)(nil)
        _ NameSetter           = (*BaseEntity)(nil)
        _ ActiveStatusChecker  = (*BaseEntity)(nil)
        _ ActivationController = (*BaseEntity)(nil)
        _ MetadataReader       = (*BaseEntity)(nil)
        _ MetadataWriter       = (*BaseEntity)(nil)
        _ Timestamped          = (*BaseEntity)(nil)
        _ Entity               = (*BaseEntity)(nil)
)

// NewBaseEntity creates a new BaseEntity with the given id and name.
// The entity will be active by default and have the creation time set to now.
// Returns an error if id or name is empty.
//
// This function returns a concrete *BaseEntity type. If you need the Entity interface,
// the return value can be assigned to an Entity variable.
func NewBaseEntity(id, name string) *BaseEntity <span class="cov8" title="1">{

        now := time.Now().UTC()
        entity := &amp;BaseEntity{
                id:        id,
                name:      name,
                active:    true,
                metadata:  make(map[string]string),
                createdAt: now,
                updatedAt: now,
                // Initialize BEFields for backward compatibility
                BEId:       id,
                BEName:     name,
                BEActive:   true,
                BEMetadata: make(map[string]string),
        }

        return entity
}</span>

// RemoveMetadata removes a metadata key and updates the updated timestamp.
// If the key doesn't exist, this is a no-op.
// This method is safe for concurrent access.
func (e *BaseEntity) RemoveMetadata(key string) <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if e.metadata != nil </span><span class="cov0" title="0">{
                if _, exists := e.metadata[key]; exists </span><span class="cov0" title="0">{
                        delete(e.metadata, key)
                        e.updatedAt = time.Now().UTC()
                }</span>
        }
}

// SetMetadataMap sets multiple metadata key-value pairs at once and updates the updated timestamp.
// This is more efficient than calling SetMetadata multiple times as it only acquires the lock once.
// This method is safe for concurrent access.
func (e *BaseEntity) SetMetadataMap(metadata map[string]string) <span class="cov0" title="0">{
        if len(metadata) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">e.mu.Lock()
        defer e.mu.Unlock()

        if e.metadata == nil </span><span class="cov0" title="0">{
                e.metadata = make(map[string]string, len(metadata))
        }</span>

        <span class="cov0" title="0">for k, v := range metadata </span><span class="cov0" title="0">{
                e.metadata[k] = v
        }</span>
        // Backward compatibility
        <span class="cov0" title="0">if e.BEMetadata == nil </span><span class="cov0" title="0">{
                e.BEMetadata = make(map[string]string, len(metadata))
        }</span>
        <span class="cov0" title="0">for k, v := range metadata </span><span class="cov0" title="0">{
                e.BEMetadata[k] = v
        }</span>
        <span class="cov0" title="0">e.updatedAt = time.Now().UTC()</span>
}

// HasMetadata checks if the entity has a specific metadata key.
// This method is safe for concurrent access.
func (e *BaseEntity) HasMetadata(key string) bool <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">e.mu.RLock()
        _, exists := e.metadata[key]
        e.mu.RUnlock()
        return exists</span>
}

// GetMetadataValue returns the value for a metadata key and whether it exists.
// This method is more efficient than Metadata() when you only need one value.
func (e *BaseEntity) GetMetadataValue(key string) (string, bool) <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">e.mu.RLock()
        defer e.mu.RUnlock()

        // Check in new metadata first
        if e.metadata != nil </span><span class="cov0" title="0">{
                if val, exists := e.metadata[key]; exists </span><span class="cov0" title="0">{
                        return val, true
                }</span>
        }

        // Backward compatibility - check in BEMetadata if not found in metadata
        <span class="cov0" title="0">if e.BEMetadata != nil </span><span class="cov0" title="0">{
                if val, exists := e.BEMetadata[key]; exists </span><span class="cov0" title="0">{
                        // If we found it in BEMetadata but not in metadata, sync it
                        if e.metadata == nil </span><span class="cov0" title="0">{
                                e.metadata = make(map[string]string)
                        }</span>
                        <span class="cov0" title="0">e.metadata[key] = val
                        return val, true</span>
                }
        }

        <span class="cov0" title="0">return "", false</span>
}

// Use only when you're certain the inputs are valid.
func MustNewBaseEntity(id, name string) *BaseEntity <span class="cov0" title="0">{
        entity := NewBaseEntity(id, name)
        return entity
}</span>

// Builder provides a fluent interface for building registry configurations
type Builder struct {
        config Config
}

// NewBuilder creates a new registry builder
func NewBuilder() *Builder <span class="cov8" title="1">{
        return &amp;Builder{
                config: Config{
                        EnableEvents:     true,
                        EnableValidation: true,
                        CacheSize:        1000,
                        CacheTTL:         5 * time.Minute,
                },
        }
}</span>

// WithName sets the registry name
func (b *Builder) WithName(name string) *Builder <span class="cov8" title="1">{
        b.config.Name = name
        return b
}</span>

// WithMaxEntities sets the maximum number of entities
func (b *Builder) WithMaxEntities(max int) *Builder <span class="cov8" title="1">{
        b.config.MaxEntities = max
        return b
}</span>

// WithDefaultTTL sets the default TTL for entities
func (b *Builder) WithDefaultTTL(ttl time.Duration) *Builder <span class="cov0" title="0">{
        b.config.DefaultTTL = ttl
        return b
}</span>

// WithCache sets cache configuration
func (b *Builder) WithCache(size int, ttl time.Duration) *Builder <span class="cov8" title="1">{
        b.config.CacheSize = size
        b.config.CacheTTL = ttl
        return b
}</span>

// WithRedis configures Redis cache settings
func (b *Builder) WithRedis(url string) *Builder <span class="cov0" title="0">{
        b.config.RedisURL = url
        // Set sensible defaults for Redis
        if b.config.RedisKeyPrefix == "" </span><span class="cov0" title="0">{
                b.config.RedisKeyPrefix = "registry:"
        }</span>
        <span class="cov0" title="0">if b.config.RedisPoolSize == 0 </span><span class="cov0" title="0">{
                b.config.RedisPoolSize = 10
        }</span>
        <span class="cov0" title="0">if b.config.RedisMinIdleConns == 0 </span><span class="cov0" title="0">{
                b.config.RedisMinIdleConns = 5
        }</span>
        <span class="cov0" title="0">if b.config.RedisMaxRetries == 0 </span><span class="cov0" title="0">{
                b.config.RedisMaxRetries = 3
        }</span>
        <span class="cov0" title="0">if b.config.RedisDialTimeout == 0 </span><span class="cov0" title="0">{
                b.config.RedisDialTimeout = 5 * time.Second
        }</span>
        <span class="cov0" title="0">if b.config.RedisReadTimeout == 0 </span><span class="cov0" title="0">{
                b.config.RedisReadTimeout = 3 * time.Second
        }</span>
        <span class="cov0" title="0">if b.config.RedisWriteTimeout == 0 </span><span class="cov0" title="0">{
                b.config.RedisWriteTimeout = 3 * time.Second
        }</span>
        <span class="cov0" title="0">return b</span>
}

// WithKeyPrefix sets the Redis key prefix for the registry
func (b *Builder) WithKeyPrefix(prefix string) *Builder <span class="cov0" title="0">{
        // Ensure prefix ends with a colon if not empty
        if prefix != "" &amp;&amp; !strings.HasSuffix(prefix, ":") </span><span class="cov0" title="0">{
                prefix += ":"
        }</span>
        <span class="cov0" title="0">b.config.RedisKeyPrefix = prefix
        return b</span>
}

// WithRedisAdvanced allows fine-grained Redis configuration
func (b *Builder) WithRedisAdvanced(
        url string,
        prefix string,
        poolSize int,
        minIdleConns int,
        maxRetries int,
        dialTimeout time.Duration,
        readTimeout time.Duration,
        writeTimeout time.Duration,
) *Builder <span class="cov0" title="0">{
        b.config.RedisURL = url
        b.config.RedisKeyPrefix = prefix
        b.config.RedisPoolSize = poolSize
        b.config.RedisMinIdleConns = minIdleConns
        b.config.RedisMaxRetries = maxRetries
        b.config.RedisDialTimeout = dialTimeout
        b.config.RedisReadTimeout = readTimeout
        b.config.RedisWriteTimeout = writeTimeout
        return b
}</span>

// WithPersistence enables persistence with the given path
func (b *Builder) WithPersistence(path string, interval time.Duration) *Builder <span class="cov8" title="1">{
        b.config.EnablePersistence = true
        b.config.PersistencePath = path
        b.config.AutoSaveInterval = interval
        return b
}</span>

// WithValidation sets validation configuration
func (b *Builder) WithValidation(required, forbidden []string) *Builder <span class="cov8" title="1">{
        b.config.RequiredMetadata = required
        b.config.ForbiddenMetadata = forbidden
        return b
}</span>

// Build returns the built configuration
func (b *Builder) Build() Config <span class="cov8" title="1">{
        return b.config
}</span>
</pre>

		<pre class="file" id="file80" style="display: none">package registry

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
)

// NewRedisCache creates a new Redis cache for the registry
func NewRedisCache(client *redis.Client, prefix string, ttl time.Duration) *RedisCache <span class="cov0" title="0">{
        if prefix == "" </span><span class="cov0" title="0">{
                prefix = "registry:"
        }</span>
        <span class="cov0" title="0">return &amp;RedisCache{
                client: client,
                prefix: prefix,
                ttl:    ttl,
        }</span>
}

// RedisCache implements the Cache interface using Redis
// Note: This is a simplified version. The full implementation should be in registry_redis_cache.go
type RedisCache struct {
        client *redis.Client
        prefix string
        ttl    time.Duration
}

// Get retrieves an entity from Redis cache
func (c *RedisCache) Get(ctx context.Context, id string) (Entity, bool) <span class="cov0" title="0">{
        val, err := c.client.Get(ctx, c.prefix+id).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">var entity BaseEntity
        if err := json.Unmarshal([]byte(val), &amp;entity); err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">return &amp;entity, true</span>
}

// Set stores an entity in Redis cache
func (c *RedisCache) Set(ctx context.Context, entity Entity) error <span class="cov0" title="0">{
        data, err := json.Marshal(entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ttl := c.ttl
        if ttl &lt;= 0 </span><span class="cov0" title="0">{
                ttl = 24 * time.Hour // Default TTL
        }</span>

        <span class="cov0" title="0">return c.client.Set(ctx, c.prefix+entity.ID(), data, ttl).Err()</span>
}

// Delete removes an entity from Redis cache
func (c *RedisCache) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        return c.client.Del(ctx, c.prefix+id).Err()
}</span>

// Clear removes all cached entities with the prefix
func (c *RedisCache) Clear(ctx context.Context) error <span class="cov0" title="0">{
        // Note: In production, consider using SCAN with MATCH for large datasets
        iter := c.client.Scan(ctx, 0, c.prefix+"*", 0).Iterator()
        var err error

        for iter.Next(ctx) </span><span class="cov0" title="0">{
                if delErr := c.client.Del(ctx, iter.Val()).Err(); delErr != nil </span><span class="cov0" title="0">{
                        return delErr
                }</span>
        }

        <span class="cov0" title="0">if err = iter.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}

// Size returns the number of cache entries (approximate)
func (c *RedisCache) Size() int <span class="cov0" title="0">{
        // This is an approximation as SCARD is not used
        keys, err := c.client.Keys(context.Background(), c.prefix+"*").Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return len(keys)</span>
}

// NewRedisClient creates a new Redis client from a URL
func NewRedisClient(url string) (*redis.Client, error) <span class="cov0" title="0">{
        opt, err := redis.ParseURL(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse Redis URL: %w", err)
        }</span>

        <span class="cov0" title="0">client := redis.NewClient(opt)

        // Test the connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to Redis: %w", err)
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}
</pre>

		<pre class="file" id="file81" style="display: none">package registry

import (
        "sync"
        "time"
)

// Registry is a thread-safe registry for managing entities that implement the Entity interface
type Registry struct {
        entities map[string]Entity
        mu       sync.RWMutex
}

// New creates a new empty registry
func New() *Registry <span class="cov8" title="1">{
        return &amp;Registry{
                entities: make(map[string]Entity),
        }
}</span>

// Register adds or updates an entity in the registry
func (r *Registry) Register(id string, entity Entity) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Create a new BaseEntity with the same values
        entityCopy := &amp;BaseEntity{
                id:        entity.ID(),
                name:      entity.Name(),
                active:    entity.Active(),
                metadata:  make(map[string]string),
                createdAt: entity.CreatedAt(),
                updatedAt: time.Now(),
        }

        // Copy metadata
        for k, v := range entity.Metadata() </span><span class="cov8" title="1">{
                entityCopy.metadata[k] = v
        }</span>

        <span class="cov8" title="1">r.entities[id] = entityCopy</span>
}

// Get returns the entity for the given ID
// Returns nil if the entity is not found
func (r *Registry) Get(id string) Entity <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if entity, exists := r.entities[id]; exists </span><span class="cov8" title="1">{
                return entity
        }</span>

        // Return nil for unknown entities
        <span class="cov8" title="1">return nil</span>
}

// IsRegistered checks if an entity ID is registered
func (r *Registry) IsRegistered(id string) bool <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        _, exists := r.entities[id]
        return exists
}</span>

// ListRegistered returns a list of all registered entity IDs
func (r *Registry) ListRegistered() []string <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        ids := make([]string, 0, len(r.entities))
        for id := range r.entities </span><span class="cov8" title="1">{
                ids = append(ids, id)
        }</span>
        <span class="cov8" title="1">return ids</span>
}

// ListActive returns a list of all active entity IDs
func (r *Registry) ListActive() []string <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        var active []string
        for id, entity := range r.entities </span><span class="cov8" title="1">{
                if entity.Active() </span><span class="cov8" title="1">{
                        active = append(active, id)
                }</span>
        }
        <span class="cov8" title="1">return active</span>
}

// Unregister removes an entity from the registry
func (r *Registry) Unregister(id string) bool <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.entities[id]; exists </span><span class="cov8" title="1">{
                delete(r.entities, id)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Count returns the total number of registered entities
func (r *Registry) Count() int <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return len(r.entities)
}</span>

// GetMetadata returns a specific metadata value for an entity
func (r *Registry) GetMetadata(id, key string) (string, bool) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if entity, exists := r.entities[id]; exists </span><span class="cov8" title="1">{
                metadata := entity.Metadata()
                if metadata != nil </span><span class="cov8" title="1">{
                        value, found := metadata[key]
                        return value, found
                }</span>
        }
        <span class="cov8" title="1">return "", false</span>
}

// SetMetadata sets a specific metadata value for an entity
func (r *Registry) SetMetadata(id, key, value string) bool <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        entity, exists := r.entities[id]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // copy the metadata to avoid data races
        <span class="cov8" title="1">metadata := make(map[string]string)
        for k, v := range entity.Metadata() </span><span class="cov8" title="1">{
                metadata[k] = v
        }</span>

        <span class="cov8" title="1">metadata[key] = value

        // Create a new BaseEntity with the updated metadata
        updatedEntity := &amp;BaseEntity{
                id:        entity.ID(),
                name:      entity.Name(),
                active:    entity.Active(),
                metadata:  metadata,
                createdAt: entity.CreatedAt(),
                updatedAt: entity.UpdatedAt(),
        }
        r.entities[id] = updatedEntity
        return true</span>
}

// RemoveMetadata removes a specific metadata key from an entity
func (r *Registry) RemoveMetadata(id, key string) bool <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        entity, exists := r.entities[id]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // copy the metadata to avoid data races
        <span class="cov8" title="1">metadata := make(map[string]string)
        for k, v := range entity.Metadata() </span><span class="cov8" title="1">{
                metadata[k] = v
        }</span>

        // Check if the key exists before trying to delete
        <span class="cov8" title="1">if _, exists := metadata[key]; !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">delete(metadata, key)

        // Create a new BaseEntity with the updated metadata
        updatedEntity := &amp;BaseEntity{
                id:        entity.ID(),
                name:      entity.Name(),
                active:    entity.Active(),
                metadata:  metadata,
                createdAt: entity.CreatedAt(),
                updatedAt: time.Now(),
        }
        r.entities[id] = updatedEntity
        return true</span>
}

// Create and manage registry instances explicitly in your application code.
</pre>

		<pre class="file" id="file82" style="display: none">// Package account provides business logic for interacting with
// domain entities such as accounts and transactions.
// It defines the Service struct and its
// methods for creating accounts, depositing and withdrawing funds,
// retrieving account details, listing transactions, and checking account balances.
//
// The service layer follows clean architecture principles
// and uses the decorator pattern for transaction management.
// All business operations are wrapped with automatic transaction management,
//
//        error recovery, and structured logging.
package account

import (
        "context"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/eventbus"

        "github.com/amirasaad/fintech/pkg/commands"
        "github.com/amirasaad/fintech/pkg/domain/events"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/repository"
        repoaccount "github.com/amirasaad/fintech/pkg/repository/account"
        "github.com/google/uuid"
)

// Service provides business logic for account operations including
// creation, deposits, withdrawals, and balance inquiries.
type Service struct {
        bus    eventbus.Bus
        uow    repository.UnitOfWork
        logger *slog.Logger
}

// New creates a new Service with the provided dependencies.
func New(bus eventbus.Bus, uow repository.UnitOfWork, logger *slog.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                bus:    bus,
                uow:    uow,
                logger: logger,
        }
}</span>

func (s *Service) CreateAccount(
        ctx context.Context,
        create dto.AccountCreate,
) (dto.AccountRead, error) <span class="cov8" title="1">{
        uow := s.uow
        var result *dto.AccountRead
        err := uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.GetRepository((*repoaccount.Repository)(nil))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">acctRepo := repoAny.(repoaccount.Repository)

                // Enforce domain invariants
                curr := money.Code(create.Currency)
                if curr == "" </span><span class="cov8" title="1">{
                        curr = money.DefaultCode
                }</span>
                <span class="cov8" title="1">domainAcc, err := account.New().WithUserID(create.UserID).WithCurrency(curr).Build()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Map to DTO for persistence
                <span class="cov8" title="1">createDTO := dto.AccountCreate{
                        ID:       domainAcc.ID,
                        UserID:   domainAcc.UserID,
                        Balance:  int64(domainAcc.Balance.Amount()), // or 0 if always zero at creation
                        Currency: curr.String(),
                        // Add more fields as needed
                }
                if err = acctRepo.Create(ctx, createDTO); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                // Fetch for read DTO
                <span class="cov8" title="1">read, err := acctRepo.Get(ctx, domainAcc.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">result = read
                return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return dto.AccountRead{}, err
        }</span>
        <span class="cov8" title="1">return *result, nil</span>
}

// Deposit adds funds to the specified account and creates a transaction record.
func (s *Service) Deposit(
        ctx context.Context,
        cmd commands.Deposit,
) error <span class="cov8" title="1">{
        // Always use the source currency for the initial deposit event
        amount, err := money.New(cmd.Amount, money.Code(cmd.Currency))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">dr := events.NewDepositRequested(
                cmd.UserID,
                cmd.AccountID,
                uuid.New(),
                events.WithDepositAmount(amount),
        )
        return s.bus.Emit(ctx, dr)</span>
}

// Withdraw removes funds from the specified account
// to an external target and creates a transaction record.
func (s *Service) Withdraw(
        ctx context.Context,
        cmd commands.Withdraw,
) error <span class="cov8" title="1">{
        amount, err := money.New(cmd.Amount, money.Code(cmd.Currency))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create event with amount and bank account number if provided
        <span class="cov8" title="1">opts := []events.WithdrawRequestedOpt{
                events.WithWithdrawAmount(amount),
        }

        if cmd.ExternalTarget != nil &amp;&amp; cmd.ExternalTarget.BankAccountNumber != "" </span><span class="cov8" title="1">{
                opts = append(
                        opts,
                        events.WithWithdrawBankAccountNumber(
                                cmd.ExternalTarget.BankAccountNumber,
                        ),
                )
        }</span>

        <span class="cov8" title="1">wr := events.NewWithdrawRequested(
                cmd.UserID,
                cmd.AccountID,
                uuid.New(),
                opts...,
        )
        return s.bus.Emit(ctx, wr)</span>
}

// Transfer moves funds from one account to another account.
func (s *Service) Transfer(
        ctx context.Context,
        cmd commands.Transfer,
) error <span class="cov8" title="1">{
        amount, err := money.New(cmd.Amount, money.Code(cmd.Currency))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tr := events.NewTransferRequested(
                cmd.UserID,
                cmd.AccountID,
                uuid.New(),
                events.WithTransferDestAccountID(cmd.ToAccountID),
                events.WithTransferRequestedAmount(amount),
        )
        return s.bus.Emit(ctx, tr)</span>
}
</pre>

		<pre class="file" id="file83" style="display: none">package account

import (
        "context"

        "github.com/amirasaad/fintech/pkg/dto"
        repoaccount "github.com/amirasaad/fintech/pkg/repository/account"
        transactionrepo "github.com/amirasaad/fintech/pkg/repository/transaction"
        "github.com/google/uuid"
)

// GetAccount retrieves an account by ID for the specified user.
func (s *Service) GetAccount(
        ctx context.Context,
        userID, accountID uuid.UUID,
) (
        account *dto.AccountRead,
        err error,
) <span class="cov8" title="1">{
        repoAny, err := s.uow.GetRepository((*repoaccount.Repository)(nil))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">repo, ok := repoAny.(repoaccount.Repository)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">account, err = repo.Get(ctx, accountID)
        return</span>
}

// GetTransactions retrieves all transactions for a specific account.
func (s *Service) GetTransactions(
        ctx context.Context,
        userID, accountID uuid.UUID,
) (
        transactions []*dto.TransactionRead,
        err error,
) <span class="cov8" title="1">{
        // First, validate that the account exists and belongs to the user
        accountRepoAny, err := s.uow.GetRepository((*repoaccount.Repository)(nil))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">accountRepo, ok := accountRepoAny.(repoaccount.Repository)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_, err = accountRepo.Get(ctx, accountID)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Then, get the transactions
        <span class="cov8" title="1">transactionRepoAny, err := s.uow.GetRepository((*transactionrepo.Repository)(nil))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">transactionRepo, ok := transactionRepoAny.(transactionrepo.Repository)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">transactions, err = transactionRepo.ListByAccount(ctx, accountID)
        return</span>
}

// GetBalance retrieves the current balance of an account for the specified user.
func (s *Service) GetBalance(
        ctx context.Context,
        userID, accountID uuid.UUID,
) (
        balance float64,
        err error,
) <span class="cov8" title="1">{
        repoAny, err := s.uow.GetRepository((*repoaccount.Repository)(nil))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">repo, ok := repoAny.(repoaccount.Repository)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">acc, err := repo.Get(ctx, accountID)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if acc.UserID != userID </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">balance = acc.Balance
        return</span>
}
</pre>

		<pre class="file" id="file84" style="display: none">package auth

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/amirasaad/fintech/pkg/config"

        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/repository"
        repouser "github.com/amirasaad/fintech/pkg/repository/user"
        "github.com/amirasaad/fintech/pkg/utils"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

type contextKey string

const userContextKey contextKey = "user"

type Strategy interface {
        Login(ctx context.Context, identity, password string) (*dto.UserRead, error)
        GetCurrentUserID(ctx context.Context) (uuid.UUID, error)
        GenerateToken(ctx context.Context, u *dto.UserRead) (string, error)
}

type Service struct {
        uow      repository.UnitOfWork
        strategy Strategy
        logger   *slog.Logger
}

func New(
        uow repository.UnitOfWork,
        strategy Strategy,
        logger *slog.Logger,
) *Service <span class="cov8" title="1">{
        return &amp;Service{uow: uow, strategy: strategy, logger: logger}
}</span>

func NewWithBasic(
        uow repository.UnitOfWork,
        logger *slog.Logger,
) *Service <span class="cov8" title="1">{
        return New(uow, &amp;BasicAuthStrategy{uow: uow, logger: logger}, logger)
}</span>

func NewWithJWT(
        uow repository.UnitOfWork,
        cfg *config.Jwt,
        logger *slog.Logger,
) *Service <span class="cov0" title="0">{
        return New(uow, &amp;JWTStrategy{uow: uow, cfg: cfg, logger: logger}, logger)
}</span>

func (s *Service) CheckPasswordHash(
        password, hash string,
) bool <span class="cov8" title="1">{
        s.logger.Info("CheckPasswordHash called")
        valid := utils.CheckPasswordHash(password, hash)
        if !valid </span><span class="cov8" title="1">{
                s.logger.Error("Password hash check failed", "valid", valid)
        }</span>
        <span class="cov8" title="1">return valid</span>
}

func (s *Service) ValidEmail(email string) bool <span class="cov8" title="1">{
        s.logger.Debug("ValidEmail called", "email", email)
        return utils.IsEmail(email)
}</span>

func (s *Service) GetCurrentUserId(
        token *jwt.Token,
) (userID uuid.UUID, err error) <span class="cov8" title="1">{
        log := s.logger.With("context", "GetCurrentUserId")
        log.Debug("GetCurrentUserId called")
        userID, err = s.strategy.GetCurrentUserID(
                context.WithValue(
                        context.TODO(),
                        userContextKey,
                        token,
                ),
        )
        if err != nil </span><span class="cov8" title="1">{
                log.Error("GetCurrentUserId failed", "error", err)
                return
        }</span>
        <span class="cov0" title="0">log.Info("GetCurrentUserId successful", "userID", userID)
        return</span>
}

func (s *Service) Login(
        ctx context.Context,
        identity, password string,
) (u *dto.UserRead, err error) <span class="cov8" title="1">{
        log := s.logger.With("context", "Login")
        log.Debug("Login called", "identity", identity)
        u, err = s.strategy.Login(ctx, identity, password)
        if err != nil </span><span class="cov8" title="1">{
                log.Error("Login failed", "identity", identity, "error", err)
                return
        }</span>
        <span class="cov8" title="1">log.Info("Login successful", "userID", u.ID)
        return</span>
}

func (s *Service) GenerateToken(
        ctx context.Context,
        u *dto.UserRead,
) (string, error) <span class="cov0" title="0">{
        log := s.logger.With("userID", u.ID)
        log.Debug("GenerateToken called")
        token, err := s.strategy.GenerateToken(ctx, u)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("GenerateToken failed", "userID", u.ID, "error", err)
                return "", err
        }</span>
        <span class="cov0" title="0">log.Info("GenerateToken successful")
        return token, nil</span>
}

// JWTStrategy implements AuthStrategy for JWT-based authentication
type JWTStrategy struct {
        uow    repository.UnitOfWork
        cfg    *config.Jwt
        logger *slog.Logger
}

func NewJWTStrategy(
        uow repository.UnitOfWork,
        cfg *config.Jwt,
        logger *slog.Logger,
) *JWTStrategy <span class="cov8" title="1">{
        return &amp;JWTStrategy{uow: uow, cfg: cfg, logger: logger}
}</span>

func (s *JWTStrategy) GenerateToken(
        ctx context.Context,
        u *dto.UserRead) (string, error) <span class="cov0" title="0">{
        log := s.logger.With("userID", u.ID)
        log.Debug("GenerateToken called", "userID", u.ID)
        token := jwt.New(jwt.SigningMethodHS256)
        claims := token.Claims.(jwt.MapClaims)
        claims["username"] = u.Username
        claims["email"] = u.Email
        claims["user_id"] = u.ID.String()
        claims["exp"] = time.Now().Add(s.cfg.Expiry).Unix()
        tokenString, err := token.SignedString([]byte(s.cfg.Secret))
        if err != nil </span><span class="cov0" title="0">{
                log.Error("GenerateToken failed", "userID", u.ID, "error", err)
                return "", err
        }</span>
        <span class="cov0" title="0">log.Info("GenerateToken successful")
        return tokenString, nil</span>
}

func (s *JWTStrategy) Login(
        ctx context.Context,
        identity, password string,
) (
        u *dto.UserRead,
        err error,
) <span class="cov0" title="0">{
        log := s.logger.With("context", "Login", "identity", identity)
        log.Debug("Login called")
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov0" title="0">{
                repoAny, err := uow.GetRepository((*repouser.Repository)(nil))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get user repository: %w", err)
                }</span>
                <span class="cov0" title="0">repo, ok := repoAny.(repouser.Repository)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid user repository type")
                }</span>
                // Check if identity is email or username
                <span class="cov0" title="0">if utils.IsEmail(identity) </span><span class="cov0" title="0">{
                        u, err = repo.GetByEmail(ctx, identity)
                }</span> else<span class="cov0" title="0"> {
                        u, err = repo.GetByUsername(ctx, identity)
                }</span>

                <span class="cov0" title="0">const dummyHash = "$2a$10$7zFqzDbD3RrlkMTczbXG9OWZ0FLOXjIxXzSZ.QZxkVXjXcx7QZQiC"
                if err != nil </span><span class="cov0" title="0">{
                        return user.ErrUserUnauthorized
                }</span>
                <span class="cov0" title="0">if u == nil </span><span class="cov0" title="0">{
                        // Always check password hash to avoid timing attacks
                        _ = utils.CheckPasswordHash(password, dummyHash)

                        log.Error("Login failed", "error", user.ErrUserUnauthorized)
                        return user.ErrUserUnauthorized
                }</span>
                <span class="cov0" title="0">if !utils.CheckPasswordHash(
                        password,
                        u.HashedPassword,
                ) </span><span class="cov0" title="0">{
                        log.Error("Login failed", "error", user.ErrUserUnauthorized)
                        return user.ErrUserUnauthorized
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return</span>
}

func (s *JWTStrategy) GetCurrentUserID(
        ctx context.Context,
) (userID uuid.UUID, err error) <span class="cov8" title="1">{
        log := s.logger.With("context", "GetCurrentUserID")
        log.Debug("GetCurrentUserID called")
        token, ok := ctx.Value(userContextKey).(*jwt.Token)
        if !ok || token == nil </span><span class="cov0" title="0">{
                log.Error("GetCurrentUserID failed", "error", user.ErrUserUnauthorized)
                err = user.ErrUserUnauthorized
                return
        }</span>
        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov8" title="1">{
                log.Error("GetCurrentUserID failed", "error", user.ErrUserUnauthorized)
                err = user.ErrUserUnauthorized
                return
        }</span>
        <span class="cov8" title="1">userIDRaw, ok := claims["user_id"].(string)
        if !ok </span><span class="cov8" title="1">{
                log.Error("GetCurrentUserID failed", "error", user.ErrUserUnauthorized)
                err = user.ErrUserUnauthorized
                return
        }</span>
        <span class="cov0" title="0">userID, err = uuid.Parse(userIDRaw)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("GetCurrentUserID failed", "error", err)
                return
        }</span>
        <span class="cov0" title="0">log.Info("GetCurrentUserID successful", "userID", userID)
        return</span>
}

// BasicAuthStrategy implements AuthStrategy for CLI (no JWT, just password check)
type BasicAuthStrategy struct {
        uow    repository.UnitOfWork
        logger *slog.Logger
}

func NewBasicAuthStrategy(
        uow repository.UnitOfWork,
        logger *slog.Logger,
) *BasicAuthStrategy <span class="cov0" title="0">{
        return &amp;BasicAuthStrategy{uow: uow, logger: logger}
}</span>

func (s *BasicAuthStrategy) Login(
        ctx context.Context,
        identity, password string,
) (u *dto.UserRead, err error) <span class="cov8" title="1">{
        log := s.logger.With("identity", identity)
        log.Info("BasicAuth Login called")
        repoAny, err := s.uow.GetRepository((*repouser.Repository)(nil))
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("failed to get user repository: %w", err)
                s.logger.Error("Failed to get user repository", "error", err)
                return
        }</span>

        <span class="cov8" title="1">repo, ok := repoAny.(repouser.Repository)
        if !ok </span><span class="cov0" title="0">{
                err = fmt.Errorf("invalid user repository type")
                s.logger.Error("Invalid user repository type")
                return
        }</span>

        <span class="cov8" title="1">log.Info("Looking up user")
        if utils.IsEmail(identity) </span><span class="cov8" title="1">{
                u, err = repo.GetByEmail(ctx, identity)
        }</span> else<span class="cov8" title="1"> {
                u, err = repo.GetByUsername(ctx, identity)
        }</span>

        // If there was an error from the repository, return it
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                log.Error("Repository error", "error", err)
                return nil, fmt.Errorf("repository error: %w", err)
        }</span>

        // If user not found, return unauthorized
        <span class="cov8" title="1">if u == nil </span><span class="cov8" title="1">{
                log.Info("User not found", "identity", identity)
                return nil, user.ErrUserUnauthorized
        }</span>

        <span class="cov8" title="1">log.Info("User found", "userID", u.ID, "username", u.Username)
        // Check password against the hardcoded hash for "password"
        const dummyHash = "$2a$10$.IIxpSc3OElWXLV2Wj517eUGmZ64IQgBNQ4OcFbanW85CTrgrIDQy"
        log.Debug("Comparing password hash", "providedPassword", password, "hash", dummyHash)
        if valid := utils.CheckPasswordHash(password, dummyHash); !valid </span><span class="cov8" title="1">{
                log.Error("Password comparison failed", "error", err)
                return nil, user.ErrUserUnauthorized
        }</span>
        <span class="cov8" title="1">log.Info("Password comparison succeeded")

        return</span>
}

func (s *BasicAuthStrategy) GetCurrentUserID(ctx context.Context) (uuid.UUID, error) <span class="cov0" title="0">{
        log := s.logger.With("context", "GetCurrentUserID")
        log.Debug("GetCurrentUserID called")
        return uuid.Nil, nil
}</span>

func (s *BasicAuthStrategy) GenerateToken(ctx context.Context, u *dto.UserRead) (string, error) <span class="cov0" title="0">{
        log := s.logger.With("userID", u.ID)
        log.Debug("GenerateToken called")
        return "", nil // No token for basic auth
}</span>
</pre>

		<pre class="file" id="file85" style="display: none">package checkout

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "time"

        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/registry"
        "github.com/google/uuid"
)

// Session represents a checkout session with its metadata
type Session struct {
        ID            string    `json:"id"`
        TransactionID uuid.UUID `json:"transaction_id"`
        UserID        uuid.UUID `json:"user_id"`
        AccountID     uuid.UUID `json:"account_id"`
        Amount        int64     `json:"amount"`
        Currency      string    `json:"currency"`
        Status        string    `json:"status"`
        CheckoutURL   string    `json:"checkout_url"`
        CreatedAt     time.Time `json:"created_at"`
        ExpiresAt     time.Time `json:"expires_at"`
}

// Service provides high-level operations for managing checkout sessions
type Service struct {
        registry registry.Provider
}

// New creates a new checkout service with the given registry
func New(reg registry.Provider) *Service <span class="cov8" title="1">{
        return &amp;Service{
                registry: reg,
        }
}</span>

// CreateSession creates a new checkout session
func (s *Service) CreateSession(
        ctx context.Context,
        sessionID string,
        id string,
        txID uuid.UUID,
        userID uuid.UUID,
        accountID uuid.UUID,
        amount int64,
        currencyCode string,
        checkoutURL string,
        expiresIn time.Duration,
) (*Session, error) <span class="cov8" title="1">{
        // Create the session
        session := &amp;Session{
                ID:            sessionID,
                TransactionID: txID,
                UserID:        userID,
                AccountID:     accountID,
                Amount:        amount,
                Currency:      currencyCode,
                Status:        "created",
                CheckoutURL:   checkoutURL,
                CreatedAt:     time.Now().UTC(),
                ExpiresAt:     time.Now().UTC().Add(expiresIn),
        }

        // Validate the session
        if err := session.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid session: %w", err)
        }</span>

        // Save to registry
        <span class="cov8" title="1">if err := s.saveSession(session); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov8" title="1">return session, nil</span>
}

// GetSession retrieves a checkout session by ID
func (s *Service) GetSession(
        ctx context.Context,
        id string,
) (*Session, error) <span class="cov8" title="1">{
        entity, err := s.registry.Get(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error getting session: %w", err)
        }</span>
        <span class="cov8" title="1">if entity == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session not found: %s", id)
        }</span>

        // Convert Entity to Session
        <span class="cov8" title="1">return s.entityToSession(entity)</span>
}

// GetSessionByTransactionID retrieves a checkout session by transaction ID
func (s *Service) GetSessionByTransactionID(
        ctx context.Context,
        txID uuid.UUID,
) (*Session, error) <span class="cov0" title="0">{
        // Search for session by transaction ID in metadata
        entities, err := s.registry.ListByMetadata(
                ctx,
                "transaction_id",
                txID.String(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error searching for session: %w", err)
        }</span>

        <span class="cov0" title="0">if len(entities) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session with transaction ID %s not found", txID)
        }</span>

        // Convert the first matching entity to Session
        <span class="cov0" title="0">return s.entityToSession(entities[0])</span>
}

// GetSessionsByUserID retrieves all checkout sessions for a given user ID
func (s *Service) GetSessionsByUserID(ctx context.Context, userID uuid.UUID) ([]*Session, error) <span class="cov0" title="0">{
        entities, err := s.registry.ListByMetadata(ctx, "user_id", userID.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting sessions by user ID: %w", err)
        }</span>

        <span class="cov0" title="0">var sessions []*Session
        for _, entity := range entities </span><span class="cov0" title="0">{
                session, err := s.entityToSession(entity)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting entity to session: %w", err)
                }</span>
                <span class="cov0" title="0">sessions = append(sessions, session)</span>
        }

        <span class="cov0" title="0">return sessions, nil</span>
}

// UpdateStatus updates the status of a checkout session
func (s *Service) UpdateStatus(
        ctx context.Context,
        id, status string,
) error <span class="cov8" title="1">{
        // Get the existing entity
        entity, err := s.registry.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting session: %w", err)
        }</span>
        <span class="cov8" title="1">if entity == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("session not found: %s", id)
        }</span>

        // Update the status in metadata
        <span class="cov8" title="1">metadata := entity.Metadata()
        metadata["status"] = status

        // Update the active status based on the new status
        active := status != "expired" &amp;&amp; status != "canceled" &amp;&amp; status != "failed"

        // Create a new entity with updated fields
        updatedEntity := &amp;registry.BaseEntity{
                BEId:       entity.ID(),
                BEName:     entity.Name(),
                BEActive:   active,
                BEMetadata: metadata,
        }

        // Save the updated entity
        err = s.registry.Register(ctx, updatedEntity)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update session status: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Validate checks if the session is valid
func (s *Session) Validate() error <span class="cov8" title="1">{
        if s.ID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("session ID cannot be empty")
        }</span>

        <span class="cov8" title="1">if s.TransactionID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("transaction ID cannot be nil")
        }</span>

        <span class="cov8" title="1">if s.UserID == uuid.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user ID cannot be nil")
        }</span>

        <span class="cov8" title="1">if s.AccountID == uuid.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("account ID cannot be nil")
        }</span>

        <span class="cov8" title="1">if s.Amount &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("amount must be positive")
        }</span>

        <span class="cov8" title="1">if !money.Code(s.Currency).IsValid() </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid currency code: %s", s.Currency)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// FormatAmount formats the amount according to the currency's decimal places
func (s *Session) FormatAmount() (string, error) <span class="cov0" title="0">{
        // Create a Money object from the amount and currency
        m, err := money.NewFromSmallestUnit(s.Amount, money.Code(s.Currency))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create money object: %w", err)
        }</span>
        // Use Money's String() method which handles the formatting
        <span class="cov0" title="0">return m.String(), nil</span>
}

// saveSession saves the session to the registry
func (s *Service) saveSession(session *Session) error <span class="cov8" title="1">{
        // Create a base entity with the session data
        entity := &amp;registry.BaseEntity{
                BEId:   session.ID,
                BEName: fmt.Sprintf("checkout_session_%s", session.TransactionID.String()),
                BEActive: session.Status != "expired" &amp;&amp;
                        session.Status != "canceled" &amp;&amp; session.Status != "failed",
                BEMetadata: make(map[string]string),
        }

        // Add all fields as metadata for searchability
        entity.SetMetadata("transaction_id", session.TransactionID.String())
        entity.SetMetadata("user_id", session.UserID.String())
        entity.SetMetadata("account_id", session.AccountID.String())
        entity.SetMetadata("amount", fmt.Sprintf("%d", session.Amount))
        entity.SetMetadata("currency", session.Currency)
        entity.SetMetadata("status", session.Status)
        entity.SetMetadata("checkout_url", session.CheckoutURL)
        entity.SetMetadata("created_at", session.CreatedAt.Format(time.RFC3339))
        entity.SetMetadata("expires_at", session.ExpiresAt.Format(time.RFC3339))

        // Store in registry
        ctx := context.Background()
        err := s.registry.Register(ctx, entity)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to register session: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// entityToSession converts a registry.Entity to a Session
func (s *Service) entityToSession(entity registry.Entity) (*Session, error) <span class="cov8" title="1">{
        if entity == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("entity cannot be nil")
        }</span>

        <span class="cov8" title="1">metadata := entity.Metadata()
        // Debug: Print all metadata keys and values
        fmt.Printf("Entity metadata: %+v\n", metadata)

        session := &amp;Session{
                ID:            entity.ID(),
                TransactionID: uuid.Nil,
                UserID:        uuid.Nil,
                AccountID:     uuid.Nil,
                Status:        "",
                CheckoutURL:   "",
                CreatedAt:     time.Time{},
                ExpiresAt:     time.Time{},
        }

        // Parse transaction ID
        if txID, ok := metadata["transaction_id"]; ok &amp;&amp; txID != "" </span><span class="cov8" title="1">{
                id, err := uuid.Parse(txID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid transaction ID in metadata: %w", err)
                }</span>
                <span class="cov8" title="1">session.TransactionID = id</span>
        }

        // Parse user ID
        <span class="cov8" title="1">if userID, ok := metadata["user_id"]; ok &amp;&amp; userID != "" </span><span class="cov8" title="1">{
                id, err := uuid.Parse(userID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid user ID in metadata: %w", err)
                }</span>
                <span class="cov8" title="1">session.UserID = id</span>
        }

        // Parse account ID
        <span class="cov8" title="1">if accountID, ok := metadata["account_id"]; ok &amp;&amp; accountID != "" </span><span class="cov8" title="1">{
                id, err := uuid.Parse(accountID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid account ID in metadata: %w", err)
                }</span>
                <span class="cov8" title="1">session.AccountID = id</span>
        }

        // Parse amount
        <span class="cov8" title="1">if amount, ok := metadata["amount"]; ok &amp;&amp; amount != "" </span><span class="cov8" title="1">{
                if amt, err := strconv.ParseInt(amount, 10, 64); err == nil </span><span class="cov8" title="1">{
                        session.Amount = amt
                }</span>
        }

        // Set other fields
        <span class="cov8" title="1">session.Currency = metadata["currency"]
        session.Status = metadata["status"]
        session.CheckoutURL = metadata["checkout_url"]

        // Parse timestamps
        if createdAt, ok := metadata["created_at"]; ok &amp;&amp; createdAt != "" </span><span class="cov8" title="1">{
                if t, err := time.Parse(time.RFC3339, createdAt); err == nil </span><span class="cov8" title="1">{
                        session.CreatedAt = t
                }</span>
        }

        <span class="cov8" title="1">if expiresAt, ok := metadata["expires_at"]; ok &amp;&amp; expiresAt != "" </span><span class="cov8" title="1">{
                if t, err := time.Parse(time.RFC3339, expiresAt); err == nil </span><span class="cov8" title="1">{
                        session.ExpiresAt = t
                }</span>
        }

        // Validate the session
        <span class="cov8" title="1">if err := session.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid session data in registry: %w", err)
        }</span>

        <span class="cov8" title="1">return session, nil</span>
}

// ToJSON converts a Session to its JSON representation
func (s *Session) ToJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(s)
}</span>

// FromJSON creates a Session from its JSON representation
func FromJSON(data []byte) (*Session, error) <span class="cov0" title="0">{
        var s Session
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal session: %w", err)
        }</span>

        // Validate the session after unmarshaling
        <span class="cov0" title="0">if err := s.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid session data: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;s, nil</span>
}
</pre>

		<pre class="file" id="file86" style="display: none">package currency

import (
        "context"
        "fmt"
        "log/slog"
        "strconv"

        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/registry"
)

// ---- Entity ----

type Entity struct {
        registry.Entity
        Code     money.Code `json:"code"`
        Name     string     `json:"name"`
        Symbol   string     `json:"symbol"`
        Decimals int        `json:"decimals"`
        Country  string     `json:"country,omitempty"`
        Region   string     `json:"region,omitempty"`
        Active   bool       `json:"active"`
}

// Service provides business logic for currency operations
type Service struct {
        registry registry.Provider
        logger   *slog.Logger
}

// New creates a new currency service
func New(
        registry registry.Provider,
        logger *slog.Logger,
) *Service <span class="cov8" title="1">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = slog.Default()
        }</span>
        <span class="cov8" title="1">return &amp;Service{
                registry: registry,
                logger:   logger.With("service", "Currency"),
        }</span>
}

// Get retrieves currency information by code
func (s *Service) Get(ctx context.Context, code string) (*money.Currency, error) <span class="cov8" title="1">{
        entity, err := s.registry.Get(ctx, code)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get currency: %w", err)
        }</span>

        // Convert entity to currency.Meta
        <span class="cov8" title="1">meta, err := toCurrency(entity)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert entity: %w", err)
        }</span>

        <span class="cov8" title="1">return meta, nil</span>
}

// ListSupported returns all supported currency codes
func (s *Service) ListSupported(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        entities, err := s.registry.ListActive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list active currencies: %w", err)
        }</span>

        <span class="cov8" title="1">codes := make([]string, 0, len(entities))
        for _, entity := range entities </span><span class="cov8" title="1">{
                codes = append(codes, entity.ID())
        }</span>

        <span class="cov8" title="1">return codes, nil</span>
}

// ListAll returns all registered currencies with full metadata
func (s *Service) ListAll(ctx context.Context) ([]*money.Currency, error) <span class="cov8" title="1">{
        entities, err := s.registry.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list currencies: %w", err)
        }</span>

        <span class="cov8" title="1">metas := make([]*money.Currency, 0, len(entities))
        for _, entity := range entities </span><span class="cov8" title="1">{
                meta, err := toCurrency(entity)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to convert entity to meta", "error", err, "id", entity.ID())
                        continue</span>
                }
                <span class="cov8" title="1">metas = append(metas, meta)</span>
        }

        <span class="cov8" title="1">return metas, nil</span>
}

// Register registers a new currency
func (s *Service) Register(ctx context.Context, meta Entity) error <span class="cov8" title="1">{
        // Create a new base entity
        entity := registry.NewBaseEntity(meta.Code.String(), meta.Name)

        // Set the active status on the entity
        entity.SetActive(meta.Active)

        // Set all metadata fields
        entity.SetMetadata("symbol", meta.Symbol)
        entity.SetMetadata("decimals", strconv.Itoa(meta.Decimals))
        entity.SetMetadata("country", meta.Country)
        entity.SetMetadata("region", meta.Region)
        entity.SetMetadata("active", strconv.FormatBool(meta.Active))

        // Store the entity in the registry
        return s.registry.Register(ctx, entity)
}</span>

// Unregister removes a currency from the registry
func (s *Service) Unregister(ctx context.Context, code string) error <span class="cov8" title="1">{
        return s.registry.Unregister(ctx, code)
}</span>

// Activate activates a currency
func (s *Service) Activate(ctx context.Context, code string) error <span class="cov8" title="1">{
        return s.registry.Activate(ctx, code)
}</span>

// Deactivate deactivates a currency
func (s *Service) Deactivate(ctx context.Context, code string) error <span class="cov8" title="1">{
        return s.registry.Deactivate(ctx, code)
}</span>

// IsSupported checks if a currency is both registered and active
func (s *Service) IsSupported(ctx context.Context, code string) bool <span class="cov8" title="1">{
        entity, err := s.registry.Get(ctx, code)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return entity.Active()</span>
}

// Search searches for currencies by name
func (s *Service) Search(
        ctx context.Context,
        query string,
) ([]*money.Currency, error) <span class="cov8" title="1">{
        entities, err := s.registry.Search(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search currencies: %w", err)
        }</span>

        <span class="cov8" title="1">metas := make([]*money.Currency, 0, len(entities))
        for _, entity := range entities </span><span class="cov8" title="1">{
                meta, err := toCurrency(entity)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(
                                "failed to convert entity to meta",
                                "error",
                                err,
                                "id",
                                entity.ID(),
                        )
                        continue</span>
                }
                <span class="cov8" title="1">metas = append(metas, meta)</span>
        }

        <span class="cov8" title="1">return metas, nil</span>
}

// SearchByRegion searches for currencies by region
func (s *Service) SearchByRegion(
        ctx context.Context,
        region string,
) ([]*money.Currency, error) <span class="cov8" title="1">{
        entities, err := s.registry.SearchByMetadata(ctx, map[string]string{"region": region})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search currencies by region: %w", err)
        }</span>

        <span class="cov8" title="1">metas := make([]*money.Currency, 0, len(entities))
        for _, entity := range entities </span><span class="cov8" title="1">{
                meta, err := toCurrency(entity)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(
                                "failed to convert entity to meta",
                                "error",
                                err,
                                "id",
                                entity.ID(),
                        )
                        continue</span>
                }
                <span class="cov8" title="1">metas = append(metas, meta)</span>
        }

        <span class="cov8" title="1">return metas, nil</span>
}

// GetStatistics returns currency statistics
func (s *Service) GetStatistics(
        ctx context.Context,
) (map[string]any, error) <span class="cov8" title="1">{
        total, err := s.registry.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count total currencies: %w", err)
        }</span>

        <span class="cov8" title="1">active, err := s.registry.CountActive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count active currencies: %w", err)
        }</span>

        <span class="cov8" title="1">return map[string]any{
                "total_currencies":  total,
                "active_currencies": active,
        }, nil</span>
}

// ValidateCode validates a currency code format
func (s *Service) ValidateCode(
        ctx context.Context,
        code string,
) error <span class="cov8" title="1">{
        if !money.Code(code).IsValid() </span><span class="cov8" title="1">{
                return money.ErrInvalidCurrency
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetDefault returns the default currency information
func (s *Service) GetDefault(
        ctx context.Context,
) (*money.Currency, error) <span class="cov8" title="1">{
        entity, err := s.registry.Get(ctx, money.DefaultCode.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get default currency: %w", err)
        }</span>
        <span class="cov8" title="1">return toCurrency(entity)</span>
}

// toCurrency converts a registry.Entity to money.Currency
// Note: The Active field is not part of money.Currency, so we'll just return the currency info
// without the active status. The active status should be checked using IsSupported() instead.
func toCurrency(entity registry.Entity) (*money.Currency, error) <span class="cov8" title="1">{
        if entity == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("entity is nil")
        }</span>

        // Get metadata
        <span class="cov8" title="1">metadata := entity.Metadata()

        // Parse decimals
        decimals := 2 // default
        if decStr, ok := metadata["decimals"]; ok </span><span class="cov8" title="1">{
                if d, err := strconv.Atoi(decStr); err == nil </span><span class="cov8" title="1">{
                        decimals = d
                }</span>
        }

        <span class="cov8" title="1">return &amp;money.Currency{
                Code:     money.Code(entity.ID()),
                Decimals: decimals,
        }, nil</span>
}
</pre>

		<pre class="file" id="file87" style="display: none">package exchange

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "math"
        "time"

        "github.com/amirasaad/fintech/infra/caching"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/amirasaad/fintech/pkg/registry"
)

// ---- Errors ----

var (
        ErrInvalidAmount        = errors.New("invalid amount")
        ErrNoProvidersAvailable = errors.New("no exchange rate providers available")
        ErrInvalidExchangeRate  = errors.New("invalid exchange rate")
)

// ---- Constants ----

const (
        // DefaultCacheTTL is the default time-to-live for cached exchange rates
        DefaultCacheTTL = 15 * time.Minute
        // LastUpdatedKey is the key used to store the last update timestamp
        LastUpdatedKey = "exr:last_updated"
)

// ---- Entity ----

type ExchangeRateInfo struct {
        registry.BaseEntity
        From      string
        To        string
        Rate      float64
        Source    string
        Timestamp time.Time
}

// newExchangeRateInfo constructs an ExchangeRateInfo with initialized BaseEntity (ID and Name)
// to satisfy registry validation requirements and ensure proper caching behavior.
func newExchangeRateInfo(
        from, to string,
        rate float64,
        source string,
) *ExchangeRateInfo <span class="cov0" title="0">{
        id := fmt.Sprintf("%s:%s", from, to)
        return &amp;ExchangeRateInfo{
                BaseEntity: *registry.NewBaseEntity(id, id),
                From:       from,
                To:         to,
                Rate:       rate,
                Source:     source,
                Timestamp:  time.Now().UTC(),
        }
}</span>

// ---- Conversion Helpers ----

// ---- Helper Functions ----

func identityRate(from, to string) *provider.ExchangeInfo <span class="cov0" title="0">{
        return &amp;provider.ExchangeInfo{
                OriginalCurrency:  from,
                ConvertedCurrency: to,
                ConversionRate:    1.0,
                Source:            "identity",
                Timestamp:         time.Now(),
        }
}</span>

func validateAmount(amount *money.Money) error <span class="cov0" title="0">{
        if amount == nil </span><span class="cov0" title="0">{
                return errors.New("amount cannot be nil")
        }</span>
        <span class="cov0" title="0">if amount.IsNegative() || amount.IsZero() </span><span class="cov0" title="0">{
                return ErrInvalidAmount
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ---- Service ----

// Service handles currency exchange operations
type Service struct {
        provider         provider.ExchangeRate
        logger           *slog.Logger
        exchangeRegistry registry.Provider      // Specific registry for exchange rates
        cacheTTL         time.Duration          // TTL for cached rates
        exchangeCache    *caching.ExchangeCache // Handles bulk caching operations
}

// New creates a new exchange service with the given exchange registry, provider, and logger.
func New(
        exchangeRegistry registry.Provider,
        provider provider.ExchangeRate,
        log *slog.Logger,
) *Service <span class="cov8" title="1">{
        if log == nil </span><span class="cov8" title="1">{
                log = slog.Default()
        }</span>

        <span class="cov8" title="1">s := &amp;Service{
                provider:         provider,
                logger:           log,
                exchangeRegistry: exchangeRegistry,
                cacheTTL:         DefaultCacheTTL,
        }

        // Initialize the exchange cache with a logger adapter
        s.exchangeCache = caching.NewExchangeCache(exchangeRegistry, log, DefaultCacheTTL)

        return s</span>
}

// areRatesCached checks if we have valid cached rates for all supported currency pairs
func (s *Service) areRatesCached(ctx context.Context, from string) (bool, error) <span class="cov0" title="0">{
        // Get provider name for logging
        providerName := s.provider.(interface{ Name() string }).Name()
        s.logger.Debug("Checking for cached rates", "from", from, "provider", providerName)

        // Check if provider supports getting all rates at once
        if getRatesProvider, ok := s.provider.(interface {
                GetRates(ctx context.Context, from string) (map[string]*provider.ExchangeInfo, error)
        }); ok </span><span class="cov0" title="0">{
                // Get list of all supported target currencies
                rates, err := getRatesProvider.GetRates(ctx, from)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to get supported currencies from provider",
                                "from", from, "provider", providerName, "error", err)
                        return false, err
                }</span>

                // If no rates are supported, we can't cache anything
                <span class="cov0" title="0">if len(rates) == 0 </span><span class="cov0" title="0">{
                        s.logger.Debug("No rates available from provider",
                                "from", from,
                                "provider", providerName)
                        return false, nil
                }</span>

                // Check if we have valid cached rates for all supported currencies
                <span class="cov0" title="0">for to := range rates </span><span class="cov0" title="0">{
                        cacheKey := fmt.Sprintf("%s:%s", from, to)
                        entity, err := s.exchangeRegistry.Get(ctx, cacheKey)
                        if err != nil || entity == nil </span><span class="cov0" title="0">{
                                s.logger.Debug("Rate not found in cache", "from", from, "to", to)
                                return false, nil
                        }</span>

                        // Check if the cached rate is still valid
                        <span class="cov0" title="0">if _, ok := s.getValidCachedRate(entity, from, to, 24*time.Hour); !ok </span><span class="cov0" title="0">{
                                s.logger.Debug("Cached rate expired or invalid", "from", from, "to", to)
                                return false, nil
                        }</span>
                }

                <span class="cov0" title="0">s.logger.Info("All rates found in cache and are valid",
                        "from", from, "provider", providerName, "num_rates", len(rates))
                return true, nil</span>
        }

        // If provider doesn't support GetRates, we can't check all rates at once
        <span class="cov0" title="0">s.logger.Debug("Provider does not support getting all rates, can't check cache status")
        return false, nil</span>
}

// shouldFetchNewRates checks if we should fetch new rates based on last_updated timestamp
func (s *Service) shouldFetchNewRates(ctx context.Context) (bool, error) <span class="cov8" title="1">{
        // Try to get last_updated timestamp
        entity, err := s.exchangeRegistry.Get(ctx, LastUpdatedKey)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("No last_updated timestamp found, will fetch new rates",
                        "key", LastUpdatedKey, "error", err)
                return true, nil
        }</span>

        <span class="cov8" title="1">if entity == nil </span><span class="cov8" title="1">{
                s.logger.Debug("No last_updated timestamp found, will fetch new rates",
                        "key", LastUpdatedKey)
                return true, nil
        }</span>

        <span class="cov0" title="0">info, ok := entity.(*ExchangeRateInfo)
        if !ok </span><span class="cov0" title="0">{
                s.logger.Warn("Invalid last_updated entity type, will fetch new rates",
                        "type", fmt.Sprintf("%T", entity))
                return true, nil
        }</span>

        // Check if cache is still valid
        <span class="cov0" title="0">if time.Since(info.Timestamp) &lt; s.cacheTTL </span><span class="cov0" title="0">{
                s.logger.Debug("Using cached rates, last updated",
                        "last_updated", info.Timestamp, "ttl", s.cacheTTL)
                return false, nil
        }</span>

        <span class="cov0" title="0">s.logger.Info("Cache expired, fetching new rates",
                "last_updated", info.Timestamp, "ttl", s.cacheTTL)
        return true, nil</span>
}

// FetchAndCacheRates fetches and caches exchange rates for the given currency
// It checks the last_updated timestamp to determine if we need to fetch new rates
func (s *Service) FetchAndCacheRates(
        ctx context.Context,
        from string,
) error <span class="cov8" title="1">{
        // Check if we need to fetch new rates based on last_updated
        shouldFetch, err := s.shouldFetchNewRates(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Error checking last_updated, will proceed with fetch",
                        "from", from, "error", err)
        }</span> else<span class="cov8" title="1"> if !shouldFetch </span><span class="cov0" title="0">{
                // We have fresh rates, check if we have rates for the requested currency
                cached, err := s.areRatesCached(ctx, from)
                if err == nil &amp;&amp; cached </span><span class="cov0" title="0">{
                        s.logger.Info("Rates already cached and fresh, skipping fetch",
                                "from", from)
                        return nil
                }</span>
        }

        // Validate provider health
        <span class="cov8" title="1">if err := s.validateProviderHealth(); err != nil </span><span class="cov8" title="1">{
                s.logger.Warn("Skipping rate fetch due to unhealthy provider",
                        "from", from, "error", err)
                return err
        }</span>

        // Get provider name for logging
        <span class="cov0" title="0">providerName := s.provider.(interface{ Name() string }).Name()

        // Get rates from provider
        rates, err := s.provider.GetRates(ctx, from)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn(
                        "Failed to get rates from provider",
                        "provider", providerName,
                        "error", err,
                )
                return err
        }</span>

        // Cache all rates at once using the exchange cache
        <span class="cov0" title="0">if err := s.exchangeCache.CacheRates(ctx, rates, providerName); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to cache exchange rates",
                        "from", from,
                        "num_rates", len(rates),
                        "error", err)
                return fmt.Errorf("failed to cache exchange rates: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Successfully fetched and cached exchange rates",
                "from", from, "num_rates", len(rates), "provider", providerName)
        return nil</span>
}

// validateProviderHealth checks provider presence and health.
func (s *Service) validateProviderHealth() error <span class="cov8" title="1">{
        if s.provider == nil </span><span class="cov0" title="0">{
                s.logger.Error(
                        "Failed to get active providers",
                        "error", "no exchange rate providers available")
                return fmt.Errorf("no exchange rate providers available")
        }</span>
        <span class="cov8" title="1">healthy, name := true, ""
        if p, ok := s.provider.(interface{ IsHealthy() bool }); ok </span><span class="cov8" title="1">{
                healthy = p.IsHealthy()
        }</span>
        <span class="cov8" title="1">if p, ok := s.provider.(interface{ Name() string }); ok </span><span class="cov8" title="1">{
                name = p.Name()
        }</span>
        <span class="cov8" title="1">if !healthy </span><span class="cov8" title="1">{
                s.logger.Warn(
                        "Skipping unhealthy provider",
                        "provider", name,
                )
                return fmt.Errorf("provider %s is unhealthy", name)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// processAndCacheRate validates, logs, and caches a rate.
// It uses the exchange cache to handle the actual caching.
// This is a convenience method that wraps the bulk caching functionality
// for a single rate.
func (s *Service) processAndCacheRate(from string, to string, rate *provider.ExchangeInfo) <span class="cov0" title="0">{
        if rate == nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("provider %s returned nil rate", s.provider.Name())
                s.logger.Error("Failed to fetch exchange rate",
                        "from", from,
                        "to", to,
                        "provider", s.provider.Name(),
                        "error", err,
                )
                return
        }</span>

        // Create a rates map with a single rate
        <span class="cov0" title="0">rates := map[string]*provider.ExchangeInfo{
                to: rate,
        }

        // Use the exchange cache to handle the caching
        if err := s.exchangeCache.CacheRates(
                context.Background(),
                rates,
                s.provider.Name(),
        ); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to cache exchange rate",
                        "from", from,
                        "to", to,
                        "error", err,
                )
        }</span>
}

// ---- Public Service Methods ----

func (s *Service) Name() string    <span class="cov0" title="0">{ return "ExchangeService" }</span>
func (s *Service) IsHealthy() bool <span class="cov0" title="0">{ return true }</span>

// Convert converts an amount from one currency to another.
// It first checks the cache for a valid rate, and if not found, fetches it from the provider.
func (s *Service) Convert(
        ctx context.Context,
        amount *money.Money,
        to money.Code,
) (*money.Money, *provider.ExchangeInfo, error) <span class="cov0" title="0">{
        if err := validateAmount(amount); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("invalid amount: %w", err)
        }</span>

        <span class="cov0" title="0">from := amount.Currency().String()
        toStr := to.String()

        // Check if conversion is needed
        if from == toStr </span><span class="cov0" title="0">{
                return amount, &amp;provider.ExchangeInfo{
                        OriginalCurrency:  from,
                        ConvertedCurrency: toStr,
                        ConversionRate:    1.0,
                        Source:            "identity",
                        Timestamp:         time.Now(),
                }, nil
        }</span>

        // Try to get rate from cache first
        <span class="cov0" title="0">rate, err := s.GetRate(ctx, from, toStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get exchange rate: %w", err)
        }</span>

        // Convert the amount
        <span class="cov0" title="0">converted, err := amount.Multiply(rate.ConversionRate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to convert amount: %w", err)
        }</span>

        <span class="cov0" title="0">result, err := money.New(converted.AmountFloat(), to)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create money: %w", err)
        }</span>

        <span class="cov0" title="0">return result, rate, nil</span>
}

func (s *Service) GetRate(ctx context.Context, from, to string) (*provider.ExchangeInfo, error) <span class="cov0" title="0">{
        return s.getRateHelper(ctx, from, to)
}</span>

// getRateHelper contains the GetRate logic.
func (s *Service) getRateHelper(
        ctx context.Context,
        from, to string,
) (*provider.ExchangeInfo, error) <span class="cov0" title="0">{
        if from == to </span><span class="cov0" title="0">{
                return identityRate(from, to), nil
        }</span>

        // First try to get from cache
        <span class="cov0" title="0">if cached, ok := s.getRateFromCache(ctx, from, to); ok </span><span class="cov0" title="0">{
                return cached, nil
        }</span>

        // If not in cache, fetch from provider
        <span class="cov0" title="0">rate, err := s.provider.GetRate(ctx, from, to)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get rate from provider",
                        "from", from, "to", to, "error", err)
                return nil, fmt.Errorf("failed to get rate from provider: %w", err)
        }</span>

        // Validate the fetched rate
        <span class="cov0" title="0">if err := validateFetchedRate(rate); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Invalid rate from provider",
                        "from", from, "to", to, "rate", rate.ConversionRate)
                return nil, fmt.Errorf("invalid rate from provider: %w", err)
        }</span>

        // Save the rate to cache
        <span class="cov0" title="0">rateInfo := newExchangeRateInfo(from, to, rate.ConversionRate, s.provider.Name())
        s.logger.Info("Successfully fetched exchange rate",
                "from", from, "to", to, "rate", rate.ConversionRate)

        // Save to registry
        s.saveDirectAndInverseRates(ctx, from, to, rateInfo)
        return rate, nil</span>
}

// GetRates fetches multiple exchange rates in a single request.
// Implements provider.ExchangeRate interface.
func (s *Service) GetRates(
        ctx context.Context,
        from string,
) (map[string]*provider.ExchangeInfo, error) <span class="cov0" title="0">{
        // First try to get all rates from cache
        cached, err := s.areRatesCached(ctx, from)
        if err == nil &amp;&amp; cached </span><span class="cov0" title="0">{
                // If all rates are cached, return them
                rates := make(map[string]*provider.ExchangeInfo)
                // Get all supported target currencies
                targetRates, err := s.provider.GetRates(ctx, from)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to get supported currencies from provider",
                                "from", from, "error", err)
                        return nil, err
                }</span>

                <span class="cov0" title="0">for to := range targetRates </span><span class="cov0" title="0">{
                        cachedRate, ok := s.getRateFromCache(ctx, from, to)
                        if !ok </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to get rate from cache",
                                        "from", from, "to", to)
                                continue</span>
                        }
                        <span class="cov0" title="0">rates[to] = cachedRate</span>
                }

                <span class="cov0" title="0">s.logger.Info("Returning all rates from cache", "from", from, "count", len(rates))
                return rates, nil</span>
        }

        // If not all rates are cached or there was an error checking the cache,
        // fetch them from the provider
        <span class="cov0" title="0">rates, err := s.provider.GetRates(ctx, from)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get rates from provider",
                        "from", from, "error", err)
                return nil, err
        }</span>

        // Cache the rates
        <span class="cov0" title="0">for to, rate := range rates </span><span class="cov0" title="0">{
                s.processAndCacheRate(from, to, rate)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Fetched and cached rates from provider",
                "from", from, "count", len(rates))
        return rates, nil</span>
}

func (s *Service) IsSupported(from, to string) bool <span class="cov8" title="1">{
        if from == to </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">return s.provider.IsSupported(from, to)</span>
}

// ---- Private Service Methods ----

func (s *Service) getValidCachedRate(
        entity registry.Entity,
        from, to string,
        ttl time.Duration,
) (*provider.ExchangeInfo, bool) <span class="cov0" title="0">{
        info, ok := entity.(*ExchangeRateInfo)
        if !ok </span><span class="cov0" title="0">{
                s.logger.Error(
                        "Invalid cache entry type",
                        "from", from,
                        "to", to,
                        "type", fmt.Sprintf("%T", entity))
                return nil, false
        }</span>

        // Check if cached rate is expired
        <span class="cov0" title="0">if time.Now().After(info.Timestamp.Add(ttl)) </span><span class="cov0" title="0">{
                s.logger.Debug("Cached rate expired", "from", from, "to", to, "timestamp", info.Timestamp)
                return nil, false
        }</span>

        <span class="cov0" title="0">s.logger.Info(
                "Exchange rate retrieved from cache",
                "from", from,
                "to", to,
                "rate", info.Rate,
        )

        // Convert to provider.ExchangeInfo
        return &amp;provider.ExchangeInfo{
                OriginalCurrency:  from,
                ConvertedCurrency: to,
                ConversionRate:    info.Rate,
                Source:            info.Source,
                Timestamp:         info.Timestamp,
        }, true</span>
}

func (s *Service) getRateFromCache(
        ctx context.Context,
        from, to string,
) (*provider.ExchangeInfo, bool) <span class="cov0" title="0">{
        log := s.logger.With(
                "to", to,
                "from", from,
                "provider", s.provider.Name(),
        )
        cacheKey := fmt.Sprintf("%s:%s", from, to)
        log.Debug("Checking registry for rate", "key", cacheKey)

        entity, err := s.exchangeRegistry.Get(ctx, cacheKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Debug("Rate not found in registry (error)", "key", cacheKey, "error", err)
                return nil, false
        }</span>

        <span class="cov0" title="0">if entity == nil </span><span class="cov0" title="0">{
                log.Debug("Rate not found in registry", "key", cacheKey)
                return nil, false
        }</span>

        <span class="cov0" title="0">cached, ok := s.getValidCachedRate(entity, from, to, 24*time.Hour)
        if !ok </span><span class="cov0" title="0">{
                log.Debug("Cached rate is invalid or expired", "key", cacheKey)
                return nil, false
        }</span>

        // Convert ExchangeRateInfo to provider.ExchangeInfo
        <span class="cov0" title="0">return &amp;provider.ExchangeInfo{
                OriginalCurrency:  from,
                ConvertedCurrency: to,
                ConversionRate:    cached.ConversionRate,
                Source:            cached.Source,
                Timestamp:         cached.Timestamp,
        }, true</span>
}

// validateFetchedRate checks if the fetched rate is valid.
func validateFetchedRate(rate *provider.ExchangeInfo) error <span class="cov0" title="0">{
        if rate.ConversionRate &lt;= 0 ||
                math.IsNaN(rate.ConversionRate) ||
                math.IsInf(rate.ConversionRate, 0) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid rate received from provider: %f", rate.ConversionRate)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// saveDirectAndInverseRates is deprecated and will be removed in a future version.
// Please use exchangeCache.CacheRates instead.
// This method is kept for backward compatibility.
func (s *Service) saveDirectAndInverseRates(
        ctx context.Context,
        from, to string,
        rateInfo *ExchangeRateInfo,
) <span class="cov0" title="0">{
        s.logger.Warn("saveDirectAndInverseRates is deprecated, use exchangeCache.CacheRates instead",
                "from", from, "to", to)

        // Convert ExchangeRateInfo to provider.ExchangeInfo for the cache
        rate := &amp;provider.ExchangeInfo{
                OriginalCurrency:  from,
                ConvertedCurrency: to,
                ConversionRate:    rateInfo.Rate,
                Source:            rateInfo.Source,
                Timestamp:         rateInfo.Timestamp,
        }

        // Use the exchange cache to handle the caching
        rates := map[string]*provider.ExchangeInfo{
                to: rate,
        }

        if err := s.exchangeCache.CacheRates(ctx, rates, rateInfo.Source); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to save rates using exchange cache",
                        "from", from,
                        "to", to,
                        "error", err)
        }</span>
}
</pre>

		<pre class="file" id="file88" style="display: none">// Package user provides business logic for user management operations.
// It uses the decorator pattern for transaction management and includes comprehensive logging.
package user

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/repository"
        userrepo "github.com/amirasaad/fintech/pkg/repository/user"
        "github.com/amirasaad/fintech/pkg/utils"
        "github.com/google/uuid"
)

// Service provides business logic for user operations including creation, updates, and deletion.
type Service struct {
        uow    repository.UnitOfWork
        logger *slog.Logger
}

// New creates a new Service with a UnitOfWork and logger.
func New(
        uow repository.UnitOfWork,
        logger *slog.Logger,
) *Service <span class="cov8" title="1">{
        return &amp;Service{
                uow:    uow,
                logger: logger,
        }
}</span>

// CreateUser creates a new user account in a transaction.
func (s *Service) CreateUser(
        ctx context.Context,
        username, email, password string,
) (u *user.User, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.GetRepository((*userrepo.Repository)(nil))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo, ok := repoAny.(userrepo.Repository)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected repository type")
                }</span>
                <span class="cov8" title="1">u, err = user.New(username, email, password)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return repo.Create(ctx, &amp;dto.UserCreate{
                        ID:       u.ID,
                        Username: u.Username,
                        Email:    u.Email,
                        Password: u.Password,
                })</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                u = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetUser retrieves a user by ID in a transaction.
func (s *Service) GetUser(
        ctx context.Context,
        userID string,
) (u *dto.UserRead, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.GetRepository((*userrepo.Repository)(nil))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo, ok := repoAny.(userrepo.Repository)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected repository type")
                }</span>
                <span class="cov8" title="1">uid, parseErr := uuid.Parse(userID)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return parseErr
                }</span>
                <span class="cov8" title="1">u, err = repo.Get(ctx, uid)
                return err</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                u = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetUserByEmail retrieves a user by email in a transaction.
func (s *Service) GetUserByEmail(
        ctx context.Context,
        email string,
) (u *dto.UserRead, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.GetRepository((*userrepo.Repository)(nil))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo, ok := repoAny.(userrepo.Repository)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected repository type")
                }</span>
                <span class="cov8" title="1">u, err = repo.GetByEmail(ctx, email)
                return err</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                u = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetUserByUsername retrieves a user by username in a transaction.
func (s *Service) GetUserByUsername(
        ctx context.Context,
        username string,
) (u *dto.UserRead, err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.GetRepository((*userrepo.Repository)(nil))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo, ok := repoAny.(userrepo.Repository)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected repository type")
                }</span>
                <span class="cov8" title="1">u, err = repo.GetByUsername(ctx, username)
                return err</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                u = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// UpdateUser updates user information in a transaction.
func (s *Service) UpdateUser(
        ctx context.Context,
        userID string,
        update *dto.UserUpdate,
) (err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.GetRepository((*userrepo.Repository)(nil))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo, ok := repoAny.(userrepo.Repository)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected repository type")
                }</span>
                <span class="cov8" title="1">uid, parseErr := uuid.Parse(userID)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return parseErr
                }</span>
                <span class="cov8" title="1">u, err := repo.Get(ctx, uid)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if u == nil </span><span class="cov0" title="0">{
                        return user.ErrUserNotFound
                }</span>

                <span class="cov8" title="1">return repo.Update(ctx, uid, update)</span>
        })
        <span class="cov8" title="1">return</span>
}

// DeleteUser deletes a user account in a transaction.
func (s *Service) DeleteUser(
        ctx context.Context,
        userID string,
) (err error) <span class="cov8" title="1">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov8" title="1">{
                repoAny, err := uow.GetRepository((*userrepo.Repository)(nil))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">repo, ok := repoAny.(userrepo.Repository)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected repository type")
                }</span>
                <span class="cov8" title="1">uid, parseErr := uuid.Parse(userID)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return parseErr
                }</span>
                <span class="cov8" title="1">return repo.Delete(ctx, uid)</span>
        })
        <span class="cov8" title="1">return</span>
}

// ValidUser validates user credentials in a transaction.
func (s *Service) ValidUser(
        ctx context.Context,
        identifier string, // Can be either email or username
        password string,
) (
        valid bool,
        err error,
) <span class="cov0" title="0">{
        err = s.uow.Do(ctx, func(uow repository.UnitOfWork) error </span><span class="cov0" title="0">{
                repoAny, err := uow.GetRepository((*userrepo.Repository)(nil))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">repo, ok := repoAny.(userrepo.Repository)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected repository type")
                }</span>

                // Try to get u by email first
                <span class="cov0" title="0">u, err := repo.GetByEmail(ctx, identifier)
                if err != nil || u == nil </span><span class="cov0" title="0">{
                        // If not found by email, try by username
                        u, err = repo.GetByUsername(ctx, identifier)
                        if err != nil || u == nil </span><span class="cov0" title="0">{
                                // User not found by either email or username
                                return nil
                        }</span>
                }

                // Check if the provided password matches the stored hash
                <span class="cov0" title="0">valid = utils.CheckPasswordHash(password, u.HashedPassword)
                return nil</span>
        })
        <span class="cov0" title="0">return</span>
}
</pre>

		<pre class="file" id="file89" style="display: none">package utils

import (
        "net/mail"

        "golang.org/x/crypto/bcrypt"
)

// HashPassword hashes a plain password using bcrypt with cost 14.
func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        return hashPassword(password)
}</span>

func hashPassword(password string) (string, error) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

// CheckPasswordHash compares a plain password with a bcrypt hash.
func CheckPasswordHash(password, hash string) bool <span class="cov8" title="1">{
        return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) == nil
}</span>

// IsEmail returns true if the string is a valid email address.
func IsEmail(email string) bool <span class="cov8" title="1">{
        _, err := mail.ParseAddress(email)
        return err == nil
}</span>
</pre>

		<pre class="file" id="file90" style="display: none">package account

import (
        "github.com/amirasaad/fintech/pkg/commands"
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/middleware"
        "github.com/amirasaad/fintech/pkg/money"
        accountsvc "github.com/amirasaad/fintech/pkg/service/account"
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

// Routes registers HTTP routes for account-related operations using the Fiber web framework.
// It sets up endpoints for creating accounts,
// depositing and withdrawing funds, retrieving account balances,
// and listing account transactions.
// All routes are protected by authentication middleware and require a valid user context.
//
// Routes:
//   - POST   /account                   : Create a new account for the authenticated user.
//   - POST   /account/:id/deposit       : Deposit funds into the specified account.
//   - POST   /account/:id/withdraw      : Withdraw funds from the specified account.
//   - GET    /account/:id/balance       : Retrieve the balance of the specified account.
//   - GET    /account/:id/transactions  : List transactions for the specified account.
func Routes(
        app *fiber.App,
        accountSvc *accountsvc.Service,
        authSvc *authsvc.Service,
        cfg *config.App,
) <span class="cov8" title="1">{
        app.Post(
                "/account",
                middleware.JwtProtected(cfg.Auth.Jwt),
                CreateAccount(accountSvc, authSvc),
        )
        app.Post(
                "/account/:id/deposit",
                middleware.JwtProtected(cfg.Auth.Jwt),
                Deposit(accountSvc, authSvc),
        )
        app.Post(
                "/account/:id/withdraw",
                middleware.JwtProtected(cfg.Auth.Jwt),
                Withdraw(accountSvc, authSvc),
        )
        app.Post(
                "/account/:id/transfer",
                middleware.JwtProtected(cfg.Auth.Jwt),
                Transfer(accountSvc, authSvc),
        )
        app.Get(
                "/account/:id/balance",
                middleware.JwtProtected(cfg.Auth.Jwt),
                GetBalance(accountSvc, authSvc),
        )
        app.Get(
                "/account/:id/transactions",
                middleware.JwtProtected(cfg.Auth.Jwt),
                GetTransactions(accountSvc, authSvc),
        )
}</span>

// CreateAccount returns a Fiber handler for creating a new account for the current user.
// It extracts the user ID from the request context,
// initializes the account service using the provided
// UnitOfWork factory, and attempts to create a new account.
// On success, it returns the created account as JSON.
// On failure, it logs the error and returns an appropriate error response.
// @Summary Create a new account
// @Description Creates a new account for the authenticated user.
//
//        You can specify the currency for the account.
//        Returns the created account details.
//
// @Tags accounts
// @Accept json
// @Produce json
// @Success 201 {object} common.Response "Account created successfully"
// @Failure 400 {object} common.ProblemDetails "Invalid request"
// @Failure 401 {object} common.ProblemDetails "Unauthorized"
// @Failure 429 {object} common.ProblemDetails "Too many requests"
// @Failure 500 {object} common.ProblemDetails "Internal server error"
// @Router /account [post]
// @Security Bearer
func CreateAccount(
        accountSvc *accountsvc.Service,
        authSvc *authsvc.Service,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                log.Infof("Creating new account")
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov8" title="1">input, err := common.BindAndValidate[CreateAccountRequest](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">a, err := accountSvc.CreateAccount(
                        c.Context(),
                        dto.AccountCreate{
                                UserID:   userID,
                                Currency: input.Currency,
                        },
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to create account: %v", err)
                        return common.ProblemDetailsJSON(c, "Failed to create account", err)
                }</span>
                <span class="cov8" title="1">log.Infof("Account created: %+v")
                return common.SuccessResponseJSON(
                        c,
                        fiber.StatusCreated,
                        "Account created",
                        a,
                )</span>
        }
}

// Deposit returns a Fiber handler for depositing an amount into a user's account.
// It expects a UnitOfWork factory function as a dependency for transactional operations.
// The handler parses the current user ID from the request context,
// validates the account ID from the URL,
// and parses the deposit amount from the request body.
// If successful, it performs the deposit operation using
// the AccountService and returns the transaction as JSON.
// On error, it logs the issue and returns an appropriate JSON error response.
// @Summary Deposit funds into an account
// @Description Adds funds to the specified account. Specify the amount, currency,
// and optional money source. Returns the transaction details.
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Param request body DepositRequest true "Deposit details"
// @Success 200 {object} common.Response "Deposit successful"
// @Failure 400 {object} common.ProblemDetails "Invalid request"
// @Failure 401 {object} common.ProblemDetails "Unauthorized"
// @Failure 429 {object} common.ProblemDetails "Too many requests"
// @Failure 500 {object} common.ProblemDetails "Internal server error"
// @Router /account/{id}/deposit [post]
// @Security Bearer
func Deposit(
        accountSvc *accountsvc.Service,
        authSvc *authsvc.Service,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                log.Infof("Deposit handler: called for account %s", c.Params("id"))
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov8" title="1">accountID, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for deposit: %v", err)
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid account ID",
                                err,
                                "Account ID must be a valid UUID",
                                fiber.StatusBadRequest,
                        )
                }</span>
                <span class="cov8" title="1">input, err := common.BindAndValidate[DepositRequest](c)
                if input == nil </span><span class="cov0" title="0">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">currencyCode := money.USD
                if input.Currency != "" </span><span class="cov8" title="1">{
                        currencyCode = money.Code(input.Currency)
                }</span>
                <span class="cov8" title="1">depositCmd := commands.Deposit{
                        UserID:    userID,
                        AccountID: accountID,
                        Amount:    input.Amount,
                        Currency:  string(currencyCode),
                        // Add MoneySource, TargetCurrency, etc. if needed
                }
                err = accountSvc.Deposit(c.Context(), depositCmd)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to deposit", err)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusAccepted,
                        "Deposit request is being processed. "+
                                "Your deposit is being started and will be completed soon.",
                        fiber.Map{})</span>
        }
}

// Withdraw returns a Fiber handler for processing account withdrawal requests.
// It expects a UnitOfWork factory function as a dependency for transactional operations.
//
// The handler performs the following steps:
//  1. Retrieves the current user ID from the request context.
//  2. Parses the account ID from the route parameters.
//  3. Parses the withdrawal amount from the request body.
//  4. Calls the AccountService.Withdraw method to process the withdrawal.
//  5. Returns the transaction details as a JSON response on success.
//
// Error responses are returned in JSON format with appropriate status codes
// if any step fails (e.g., invalid user ID, invalid account ID,
//
//        parsing errors, or withdrawal errors).
//
// @Summary Withdraw funds from an account
// @Description Withdraws a specified amount from the user's account.
// Specify the amount and currency. Returns the transaction details.
//
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Param request body WithdrawRequest true "Withdrawal details"
// @Success 200 {object} common.Response "Withdrawal successful"
// @Failure 400 {object} common.ProblemDetails "Invalid request"
// @Failure 401 {object} common.ProblemDetails "Unauthorized"
// @Failure 429 {object} common.ProblemDetails "Too many requests"
// @Failure 500 {object} common.ProblemDetails "Internal server error"
// @Router /account/{id}/withdraw [post]
// @Security Bearer
func Withdraw(
        accountSvc *accountsvc.Service,
        authSvc *authsvc.Service,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov8" title="1">accountID, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for withdrawal: %v", err)
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid account ID",
                                err,
                                "Account ID must be a valid UUID",
                                fiber.StatusBadRequest,
                        )
                }</span>
                <span class="cov8" title="1">input, err := common.BindAndValidate[WithdrawRequest](c)
                if input == nil </span><span class="cov0" title="0">{
                        return err // error response already written
                }</span>
                // Validate that at least one field in ExternalTarget is present
                <span class="cov8" title="1">if input.ExternalTarget.BankAccountNumber == "" &amp;&amp;
                        input.ExternalTarget.RoutingNumber == "" &amp;&amp;
                        input.ExternalTarget.ExternalWalletAddress == "" </span><span class="cov8" title="1">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid external target",
                                nil,
                                "At least one external target field must be provided",
                                fiber.StatusBadRequest,
                        )
                }</span>
                <span class="cov8" title="1">currencyCode := money.DefaultCode
                if input.Currency != "" </span><span class="cov8" title="1">{
                        currencyCode = money.Code(input.Currency)
                }</span>
                <span class="cov8" title="1">err = accountSvc.Withdraw(c.Context(), commands.Withdraw{
                        UserID:    userID,
                        AccountID: accountID,
                        Amount:    input.Amount,
                        Currency:  string(currencyCode),
                        ExternalTarget: &amp;commands.ExternalTarget{
                                BankAccountNumber:     input.ExternalTarget.BankAccountNumber,
                                RoutingNumber:         input.ExternalTarget.RoutingNumber,
                                ExternalWalletAddress: input.ExternalTarget.ExternalWalletAddress,
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to withdraw", err)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusAccepted,
                        "Withdrawal request is being processed. "+
                                "Your withdrawal is being started and will be completed soon.",
                        fiber.Map{},
                )</span>
        }
}

// Transfer returns a Fiber handler for transferring funds between accounts.
// @Summary Transfer funds between accounts
// @Description Transfers a specified amount from one account to another.
// Specify the source and destination account IDs, amount, and currency.
// Returns the transaction details.
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Source Account ID"
// @Param request body TransferRequest true "Transfer details"
// @Success 200 {object} common.Response "Transfer successful"
// @Failure 400 {object} common.ProblemDetails "Invalid request"
// @Failure 401 {object} common.ProblemDetails "Unauthorized"
// @Failure 422 {object} common.ProblemDetails "Unprocessable entity"
// @Failure 429 {object} common.ProblemDetails "Too many requests"
// @Failure 500 {object} common.ProblemDetails "Internal server error"
// @Router /account/{id}/transfer [post]
// @Security Bearer
func Transfer(
        accountSvc *accountsvc.Service,
        authSvc *authsvc.Service,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                log.Infof("Transfer handler: called for account %s", c.Params("id"))
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov0" title="0">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov0" title="0">sourceAccountID, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid source account ID for transfer: %v", err)
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid account ID",
                                err,
                                "Account ID must be a valid UUID",
                                fiber.StatusBadRequest,
                        )
                }</span>
                <span class="cov0" title="0">input, err := common.BindAndValidate[TransferRequest](c)
                if input == nil </span><span class="cov0" title="0">{
                        return err // error response already written
                }</span>
                <span class="cov0" title="0">destAccountID, err := uuid.Parse(input.DestinationAccountID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid destination account ID for transfer: %v", err)
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid destination account ID",
                                err,
                                "Destination Account ID must be a valid UUID",
                                fiber.StatusBadRequest,
                        )
                }</span>
                <span class="cov0" title="0">currencyCode := money.USD
                if input.Currency != "" </span><span class="cov0" title="0">{
                        currencyCode = money.Code(input.Currency)
                }</span>
                // Construct transfer command
                <span class="cov0" title="0">cmd := commands.Transfer{
                        UserID:      userID,
                        AccountID:   sourceAccountID,
                        ToAccountID: destAccountID,
                        Amount:      input.Amount,
                        Currency:    currencyCode.String(),
                }
                err = accountSvc.Transfer(c.Context(), cmd)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Failed to transfer", err)
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusAccepted,
                        "Transfer request is being processed. "+
                                "Your transfer is being started and will be completed soon.",
                        fiber.Map{},
                )</span>
        }
}

// GetTransactions returns a Fiber handler that retrieves the list of transactions
//
//        for a specific account.
//
// It expects a UnitOfWork factory function as a dependency for service instantiation.
// The handler extracts the current user ID from the request context and
// parses the account ID from the URL parameters.
// On success, it returns the transactions as a JSON response. On error,
// it logs the error and returns an appropriate JSON error response.
// @Summary Get account transactions
// @Description Retrieves a list of transactions for the specified account.
// Returns an array of transaction details.
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Success 200 {object} common.Response "Transactions fetched"
// @Failure 400 {object} common.ProblemDetails "Invalid request"
// @Failure 401 {object} common.ProblemDetails "Unauthorized"
// @Failure 429 {object} common.ProblemDetails "Too many requests"
// @Failure 500 {object} common.ProblemDetails "Internal server error"
// @Router /account/{id}/transactions [get]
// @Security Bearer
func GetTransactions(
        accountSvc *accountsvc.Service,
        authSvc *authsvc.Service,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov0" title="0">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov0" title="0">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for transactions: %v", err)
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid account ID",
                                err,
                                "Account ID must be a valid UUID",
                                fiber.StatusBadRequest,
                        )
                }</span>

                <span class="cov0" title="0">tx, err := accountSvc.GetTransactions(c.Context(), userID, id)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf(
                                "Failed to list transactions for account ID %s: %v",
                                id,
                                err,
                        )
                        return common.ProblemDetailsJSON(c, "Failed to list transactions", err)
                }</span>
                <span class="cov0" title="0">dtos := make([]*TransactionDTO, 0, len(tx))
                for _, t := range tx </span><span class="cov0" title="0">{
                        dtos = append(dtos, &amp;TransactionDTO{
                                ID:        t.ID.String(),
                                UserID:    t.UserID.String(),
                                AccountID: t.AccountID.String(),
                                Amount:    t.Amount,
                                Currency:  string(t.Currency),
                                Balance:   t.Balance,
                                CreatedAt: t.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                        })
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Transactions fetched",
                        dtos,
                )</span>
        }
}

// GetBalance returns a Fiber handler for retrieving the balance of a specific account.
// It expects a UnitOfWork factory function as a dependency for service instantiation.
// The handler extracts the current user ID from the request context and
// parses the account ID from the URL parameters.
// On success, it returns the account balance as a JSON response.
// On error, it logs the error and returns an appropriate JSON error response.
// @Summary Get account balance
// @Description Retrieves the current balance for the specified account.
// Returns the balance amount and currency.
// @Tags accounts
// @Accept json
// @Produce json
// @Param id path string true "Account ID"
// @Success 200 {object} common.Response "Balance fetched"
// @Failure 400 {object} common.ProblemDetails "Invalid request"
// @Failure 401 {object} common.ProblemDetails "Unauthorized"
// @Failure 429 {object} common.ProblemDetails "Too many requests"
// @Failure 500 {object} common.ProblemDetails "Internal server error"
// @Router /account/{id}/balance [get]
// @Security Bearer
func GetBalance(
        accountSvc *accountsvc.Service,
        authSvc *authsvc.Service,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid account ID for balance: %v", err)
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid account ID",
                                err,
                                "Account ID must be a valid UUID",
                                fiber.StatusBadRequest,
                        )
                }</span>

                <span class="cov8" title="1">balance, err := accountSvc.GetBalance(c.Context(), userID, id)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to fetch balance for account ID %s: %v", id, err)
                        return common.ProblemDetailsJSON(
                                c,
                                "Failed to fetch balance",
                                err,
                        )
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Balance fetched",
                        fiber.Map{"balance": balance},
                )</span>
        }
}
</pre>

		<pre class="file" id="file91" style="display: none">package account

import (
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/provider"
)

//revive:disable

// CreateAccountRequest represents the request body for creating a new account.
type CreateAccountRequest struct {
        Currency string `json:"currency" validate:"omitempty,len=3,uppercase,alpha"`
}

// DepositRequest represents the request body for depositing funds into an account.
type DepositRequest struct {
        Amount      float64 `json:"amount" xml:"amount" form:"amount" validate:"required,gt=0"`
        Currency    string  `json:"currency" validate:"omitempty,len=3,uppercase"`
        MoneySource string  `json:"money_source" validate:"required,min=2,max=64"`
}

// ExternalTarget represents the destination for an external withdrawal, such as a bank account or wallet.
type ExternalTarget struct {
        BankAccountNumber     string `json:"bank_account_number,omitempty" validate:"omitempty,min=6,max=34"`
        RoutingNumber         string `json:"routing_number,omitempty" validate:"omitempty,min=6,max=12"`
        ExternalWalletAddress string `json:"external_wallet_address,omitempty" validate:"omitempty,min=6,max=128"`
}

// WithdrawRequest represents the request body for withdrawing funds from an account.
type WithdrawRequest struct {
        Amount         float64        `json:"amount" xml:"amount" form:"amount" validate:"required,gt=0"`
        Currency       string         `json:"currency" validate:"omitempty,len=3,uppercase"`
        ExternalTarget ExternalTarget `json:"external_target" validate:"required"`
}

// TransferRequest represents the request body for transferring funds between accounts.
type TransferRequest struct {
        Amount               float64 `json:"amount" validate:"required,gt=0"`
        Currency             string  `json:"currency" validate:"omitempty,len=3,uppercase,alpha"`
        DestinationAccountID string  `json:"destination_account_id" validate:"required,uuid4"`
}

// TransactionDTO is the API response representation of a transaction.
type TransactionDTO struct {
        ID          string  `json:"id"`
        UserID      string  `json:"user_id"`
        AccountID   string  `json:"account_id"`
        Amount      float64 `json:"amount"`
        Balance     float64 `json:"balance"`
        CreatedAt   string  `json:"created_at"`
        Currency    string  `json:"currency"`
        MoneySource string  `json:"money_source"`
}

// ConversionInfoDTO holds conversion details for API responses.
type ConversionInfoDTO struct {
        OriginalAmount    float64 `json:"original_amount"`
        OriginalCurrency  string  `json:"original_currency"`
        ConvertedAmount   float64 `json:"converted_amount"`
        ConvertedCurrency string  `json:"converted_currency"`
        ConversionRate    float64 `json:"conversion_rate"`
}

// TransferResponseDTO is the API response for a transfer operation, containing both transactions and a single conversion_info field (like deposit/withdraw).
type TransferResponseDTO struct {
        Outgoing       *TransactionDTO    `json:"outgoing_transaction"`
        Incoming       *TransactionDTO    `json:"incoming_transaction"`
        ConversionInfo *ConversionInfoDTO `json:"conversion_info"`
}

// ToTransactionDTO maps a dto.TransactionRead to a TransactionDTO.
func ToTransactionDTO(tx *dto.TransactionRead) *TransactionDTO <span class="cov0" title="0">{
        if tx == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">dto := &amp;TransactionDTO{
                ID:        tx.ID.String(),
                UserID:    tx.UserID.String(),
                AccountID: tx.AccountID.String(),
                Amount:    tx.Amount,
                Currency:  tx.Currency,
                Balance:   tx.Balance,
                CreatedAt: tx.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }

        return dto</span>
}

// ToConversionInfoDTO maps provider.ExchangeRate to ConversionInfoDTO.
func ToConversionInfoDTO(convInfo *provider.ExchangeInfo) *ConversionInfoDTO <span class="cov0" title="0">{
        if convInfo == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;ConversionInfoDTO{
                OriginalAmount:    convInfo.OriginalAmount,
                OriginalCurrency:  convInfo.OriginalCurrency,
                ConvertedAmount:   convInfo.ConvertedAmount,
                ConvertedCurrency: convInfo.ConvertedCurrency,
                ConversionRate:    convInfo.ConversionRate,
        }</span>
}

// ToTransferResponseDTO maps domain transactions and conversion info to a TransferResponseDTO with a single conversion_info field.
func ToTransferResponseDTO(txOut, txIn *dto.TransactionRead, convInfo *provider.ExchangeInfo) *TransferResponseDTO <span class="cov0" title="0">{
        return &amp;TransferResponseDTO{
                Outgoing:       ToTransactionDTO(txOut),
                Incoming:       ToTransactionDTO(txIn),
                ConversionInfo: ToConversionInfoDTO(convInfo),
        }
}</span>

//revive:enable
</pre>

		<pre class="file" id="file92" style="display: none">package auth

import (
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/gofiber/fiber/v2"
)

// Routes registers HTTP routes for authentication operations.
// Sets up endpoints for user login and authentication.
func Routes(app *fiber.App, authSvc *authsvc.Service) <span class="cov8" title="1">{
        app.Post("/auth/login", Login(authSvc))
}</span>

// Login handles user authentication and returns a JWT token.
// @Summary User login
// @Description Authenticate user with identity (username or email) and password
// @Tags auth
// @Accept json
// @Produce json
// @Param request body LoginInput true "Login credentials"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /auth/login [post]
func Login(authSvc *authsvc.Service) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                input, err := common.BindAndValidate[LoginInput](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // Error already written by BindAndValidate
                }</span>
                <span class="cov8" title="1">user, err := authSvc.Login(c.Context(), input.Identity, input.Password)
                if err != nil </span><span class="cov8" title="1">{
                        // Check if it's an unauthorized error
                        if err.Error() == "user unauthorized" </span><span class="cov8" title="1">{
                                return common.ProblemDetailsJSON(
                                        c,
                                        "Invalid identity or password",
                                        nil,
                                        "Identity or password is incorrect",
                                        fiber.StatusUnauthorized,
                                )
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(
                                c,
                                "Internal Server Error",
                                err,
                        )</span>
                }
                <span class="cov8" title="1">if user == nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid identity or password",
                                nil,
                                "Identity or password is incorrect",
                                fiber.StatusUnauthorized,
                        )
                }</span>
                <span class="cov8" title="1">token, err := authSvc.GenerateToken(c.Context(), user)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Internal Server Error",
                                err,
                        )
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Success login",
                        fiber.Map{"token": token},
                )</span>
        }
}
</pre>

		<pre class="file" id="file93" style="display: none">package checkout

import (
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/middleware"
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        "github.com/amirasaad/fintech/pkg/service/checkout"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "github.com/golang-jwt/jwt/v5"
)

// Routes registers HTTP routes for checkout-related operations.
func Routes(
        app *fiber.App,
        checkoutSvc *checkout.Service,
        authSvc *authsvc.Service,
        cfg *config.App,
) <span class="cov8" title="1">{
        app.Get(
                "/checkout/sessions/pending",
                middleware.JwtProtected(cfg.Auth.Jwt),
                GetPendingSessions(checkoutSvc, authSvc),
        )
}</span>

// GetPendingSessions returns a Fiber handler for retrieving pending checkout sessions.
// for the current user.
// @Summary Get pending checkout sessions
// @Description Retrieves a list of pending checkout sessions for the authenticated user.
// @Tags checkout
// @Accept json
// @Produce json
// @Success 200 {object} common.Response "Pending sessions fetched"
// @Failure 401 {object} common.ProblemDetails "Unauthorized"
// @Failure 500 {object} common.ProblemDetails "Internal server error"
// @Router /checkout/sessions/pending [get]
// @Security Bearer
func GetPendingSessions(checkoutSvc *checkout.Service, authSvc *authsvc.Service) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil, "missing user context")
                }</span>

                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Invalid user ID", err)
                }</span>

                <span class="cov8" title="1">sessions, err := checkoutSvc.GetSessionsByUserID(c.Context(), userID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to get pending sessions: %v", err)
                        return common.ProblemDetailsJSON(c, "Failed to get pending sessions", err)
                }</span>

                <span class="cov8" title="1">dtos := make([]*SessionDTO, 0, len(sessions))
                for _, s := range sessions </span><span class="cov0" title="0">{
                        if s.Status == "created" </span><span class="cov0" title="0">{
                                dtos = append(dtos, &amp;SessionDTO{
                                        ID:            s.ID,
                                        TransactionID: s.TransactionID.String(),
                                        UserID:        s.UserID.String(),
                                        AccountID:     s.AccountID.String(),
                                        Amount:        s.Amount,
                                        Currency:      s.Currency,
                                        Status:        s.Status,
                                        CheckoutURL:   s.CheckoutURL,
                                        CreatedAt:     s.CreatedAt,
                                        ExpiresAt:     s.ExpiresAt,
                                })
                        }</span>
                }

                <span class="cov8" title="1">return common.SuccessResponseJSON(c, fiber.StatusOK, "Pending sessions fetched", dtos)</span>
        }
}
</pre>

		<pre class="file" id="file94" style="display: none">package common

import (
        "errors"

        "github.com/amirasaad/fintech/pkg/domain/account"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
)

// Response defines the standard API response structure for success cases.
type Response struct {
        Status  int    `json:"status"`         // HTTP status code
        Message string `json:"message"`        // Human-readable explanation
        Data    any    `json:"data,omitempty"` // Response data
}

// ProblemDetails follows RFC 9457 Problem Details for HTTP APIs.
type ProblemDetails struct {
        Type     string `json:"type,omitempty"`     // A URI reference that identifies the problem type
        Title    string `json:"title"`              // Short, human-readable summary
        Status   int    `json:"status"`             // HTTP status code
        Detail   string `json:"detail,omitempty"`   // Human-readable explanation
        Instance string `json:"instance,omitempty"` // URI reference
        Errors   any    `json:"errors,omitempty"`   // Optional: additional error details
}

// ProblemDetailsJSON writes a problem+json error response with a status
// code inferred from the error (if present).
// The title is set to the error message (if error),
// and detail can be a string, error, or structured object.
// Optionally, a status code can be provided as the last argument (int)
// to override the fallback status.
func ProblemDetailsJSON(
        c *fiber.Ctx,
        title string,
        err error,
        detailOrStatus ...any,
) error <span class="cov0" title="0">{
        status := fiber.StatusBadRequest
        pdDetail := ""
        var pdErrors any
        var customStatus *int

        if err != nil </span><span class="cov0" title="0">{
                status = errorToStatusCode(err)
                pdDetail = err.Error()
        }</span>
        // Check for custom detail or status code in variadic args
        <span class="cov0" title="0">for _, arg := range detailOrStatus </span><span class="cov0" title="0">{
                switch v := arg.(type) </span>{
                case int:<span class="cov0" title="0">
                        customStatus = &amp;v</span>
                case string:<span class="cov0" title="0">
                        pdDetail = v</span>
                case error:<span class="cov0" title="0">
                        pdDetail = v.Error()</span>
                default:<span class="cov0" title="0">
                        pdErrors = v</span>
                }
        }
        // Use custom status if provided
        <span class="cov0" title="0">if customStatus != nil </span><span class="cov0" title="0">{
                status = *customStatus
        }</span>
        <span class="cov0" title="0">pd := ProblemDetails{
                Type:     "about:blank",
                Status:   status,
                Title:    title,
                Detail:   pdDetail,
                Errors:   pdErrors,
                Instance: c.Path(),
        }
        c.Set(fiber.HeaderContentType, "application/problem+json")
        if err := c.Status(status).JSON(pd); err != nil </span><span class="cov0" title="0">{
                log.Errorf("ProblemDetailsJSON failed: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// BindAndValidate parses the request body and validates it using go-playground/validator.
// Returns a pointer to the struct (populated), or writes an error response and returns nil.
func BindAndValidate[T any](c *fiber.Ctx) (*T, error) <span class="cov0" title="0">{
        var input T
        if err := c.BodyParser(&amp;input); err != nil </span><span class="cov0" title="0">{
                return nil, ProblemDetailsJSON(
                        c,
                        "Invalid request body",
                        err,
                        "Request body could not be parsed or has invalid types",
                        fiber.StatusBadRequest,
                ) //nolint:errcheck
        }</span>

        <span class="cov0" title="0">validate := validator.New()
        if err := validate.Struct(input); err != nil </span><span class="cov0" title="0">{
                if ve, ok := err.(validator.ValidationErrors); ok </span><span class="cov0" title="0">{
                        details := make(map[string]string)
                        for _, fe := range ve </span><span class="cov0" title="0">{
                                field := fe.Field()
                                msg := fe.Tag()
                                details[field] = msg
                        }</span>
                        //revive:disable
                        <span class="cov0" title="0">return nil, ProblemDetailsJSON( //nolint:errcheck
                                c,
                                "Validation failed",
                                nil,
                                "Request validation failed",
                                details,
                                fiber.StatusBadRequest,
                        )</span>
                        //revive:enable
                }
                //revive:disable
                <span class="cov0" title="0">ProblemDetailsJSON( //nolint:errcheck
                        c,
                        "Validation failed",
                        err,
                        "Request validation failed",
                        fiber.StatusBadRequest)
                //revive:enable
                return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;input, nil</span>
}

// SuccessResponseJSON writes a JSON response with the given status, message, and data
// using the standard Response struct.
// Use for successful API responses (e.g., 200, 201, 202).
func SuccessResponseJSON(c *fiber.Ctx, status int, message string, data any) error <span class="cov0" title="0">{
        return c.Status(status).JSON(Response{
                Status:  status,
                Message: message,
                Data:    data,
        })
}</span>

// errorToStatusCode maps domain errors to appropriate HTTP status codes.
func errorToStatusCode(err error) int <span class="cov0" title="0">{
        switch </span>{
        // Account errors
        case errors.Is(err, account.ErrAccountNotFound):<span class="cov0" title="0">
                return fiber.StatusNotFound</span>
        case errors.Is(err, account.ErrDepositAmountExceedsMaxSafeInt):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, account.ErrTransactionAmountMustBePositive):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, account.ErrInsufficientFunds):<span class="cov0" title="0">
                return fiber.StatusUnprocessableEntity</span>
        // Common errors
        case errors.Is(err, money.ErrInvalidCurrency):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, money.ErrAmountExceedsMaxSafeInt):<span class="cov0" title="0">
                return fiber.StatusBadRequest</span>
        case errors.Is(err, provider.ErrUnsupportedCurrencyPair):<span class="cov0" title="0">
                return fiber.StatusUnprocessableEntity</span>
        // Money/currency conversion errors
        case errors.Is(err, provider.ErrExchangeRateUnavailable):<span class="cov0" title="0">
                return fiber.StatusServiceUnavailable</span>
        case errors.Is(err, provider.ErrExchangeRateExpired):<span class="cov0" title="0">
                return fiber.StatusServiceUnavailable</span>
        case errors.Is(err, provider.ErrExchangeRateInvalid):<span class="cov0" title="0">
                return fiber.StatusUnprocessableEntity</span>
        // User errors
        case errors.Is(err, user.ErrUserNotFound):<span class="cov0" title="0">
                return fiber.StatusNotFound</span>
        case errors.Is(err, user.ErrUserUnauthorized):<span class="cov0" title="0">
                return fiber.StatusUnauthorized</span>
        default:<span class="cov0" title="0">
                return fiber.StatusInternalServerError</span>
        }
}
</pre>

		<pre class="file" id="file95" style="display: none">package currency

import (
        "fmt"
        "strings"

        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/middleware"
        "github.com/amirasaad/fintech/pkg/money"
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        currencysvc "github.com/amirasaad/fintech/pkg/service/currency"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/gofiber/fiber/v2"
)

// Routes sets up the currency routes
func Routes(
        r fiber.Router,
        currencySvc *currencysvc.Service,
        authSvc *authsvc.Service,
        cfg *config.App,
) <span class="cov0" title="0">{
        currencyGroup := r.Group("/api/currencies")

        // Public endpoints
        currencyGroup.Get(
                "/",
                ListCurrencies(currencySvc),
        )
        currencyGroup.Get(
                "/supported",
                ListSupportedCurrencies(currencySvc),
        )
        currencyGroup.Get(
                "/:code",
                GetCurrency(currencySvc),
        )
        currencyGroup.Get(
                "/:code/supported",
                CheckCurrencySupported(currencySvc),
        )
        currencyGroup.Get(
                "/search",
                SearchCurrencies(currencySvc),
        )
        currencyGroup.Get(
                "/region/:region",
                SearchCurrenciesByRegion(currencySvc),
        )
        currencyGroup.Get(
                "/statistics",
                GetCurrencyStatistics(currencySvc),
        )
        currencyGroup.Get(
                "/default",
                GetDefaultCurrency(currencySvc),
        )

        // Admin endpoints (require authentication)
        adminGroup := currencyGroup.Group("/admin")
        adminGroup.Post(
                "/",
                middleware.JwtProtected(cfg.Auth.Jwt),
                RegisterCurrency(currencySvc),
        )
        adminGroup.Delete(
                "/:code",
                middleware.JwtProtected(cfg.Auth.Jwt),
                UnregisterCurrency(currencySvc),
        )
        adminGroup.Put(
                "/:code/activate",
                middleware.JwtProtected(cfg.Auth.Jwt),
                ActivateCurrency(currencySvc),
        )
        adminGroup.Put(
                "/:code/deactivate",
                middleware.JwtProtected(cfg.Auth.Jwt),
                DeactivateCurrency(currencySvc),
        )
}</span>

// ListCurrencies returns a Fiber handler for listing all available currencies.
// @Summary List all currencies
// @Description Get a list of all available currencies in the system
// @Tags currencies
// @Accept json
// @Produce json
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /currency [get]
// @Security Bearer
func ListCurrencies(
        currencySvc *currencysvc.Service,
) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                currencies, err := currencySvc.ListAll(c.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Failed to list currencies",
                                err,
                        )
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Currencies fetched successfully",
                        currencies,
                )</span>
        }
}

// ListSupportedCurrencies returns all supported currency codes
// @Summary List supported currencies
// @Description Get all supported currency codes
// @Tags currencies
// @Accept json
// @Produce json
// @Success 200 {array} string
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/supported [get]
func ListSupportedCurrencies(
        currencySvc *currencysvc.Service,
) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                currencies, err := currencySvc.ListSupported(c.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Failed to list supported currencies",
                                err,
                        )
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Supported currencies fetched successfully",
                        currencies,
                )</span>
        }
}

// GetCurrency returns currency information by code
// @Summary Get currency by code
// @Description Get currency information by ISO 4217 code
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code (e.g., USD, EUR)"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/{code} [get]
func GetCurrency(
        currencySvc *currencysvc.Service,
) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Currency code is required",
                                nil,
                                "Missing currency code",
                                fiber.StatusBadRequest,
                        )
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid currency code",
                                err,
                                "Currency code must be a valid ISO 4217 code",
                                fiber.StatusBadRequest,
                        )
                }</span>

                <span class="cov0" title="0">currency, err := currencySvc.Get(c.Context(), code)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Currency not found",
                                err,
                        )
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Currency fetched successfully",
                        currency,
                )</span>
        }
}

// CheckCurrencySupported checks if a currency is supported
// @Summary Check if currency is supported
// @Description Check if a currency code is supported
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code (e.g., USD, EUR)"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Router /api/currencies/{code}/supported [get]
func CheckCurrencySupported(
        currencySvc *currencysvc.Service,
) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Currency code is required",
                                nil,
                                "Missing currency code",
                                fiber.StatusBadRequest,
                        )
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid currency code",
                                err,
                                "Currency code must be a valid ISO 4217 code",
                                fiber.StatusBadRequest,
                        )
                }</span>

                <span class="cov0" title="0">supported := currencySvc.IsSupported(c.Context(), code)
                return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Currency support checked successfully",
                        fiber.Map{"code": code, "supported": supported},
                )</span>
        }
}

// SearchCurrencies searches for currencies by name
// @Summary Search currencies
// @Description Search for currencies by name
// @Tags currencies
// @Accept json
// @Produce json
// @Param q query string true "Search query"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/search [get]
func SearchCurrencies(
        currencySvc *currencysvc.Service,
) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                query := c.Query("q")
                if query == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Search query is required",
                                nil,
                                "Missing search query",
                                fiber.StatusBadRequest,
                        )
                }</span>

                <span class="cov0" title="0">currencies, err := currencySvc.Search(c.Context(), query)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Failed to search currencies",
                                err,
                        )
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Currencies searched successfully",
                        currencies,
                )</span>
        }
}

// SearchCurrenciesByRegion searches for currencies by region
// @Summary Search currencies by region
// @Description Search for currencies by region
// @Tags currencies
// @Accept json
// @Produce json
// @Param region path string true "Region name"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/region/{region} [get]
func SearchCurrenciesByRegion(
        currencySvc *currencysvc.Service,
) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                region := c.Params("region")
                if region == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Region is required",
                                nil,
                                "Missing region",
                                fiber.StatusBadRequest,
                        )
                }</span>

                <span class="cov0" title="0">currencies, err := currencySvc.SearchByRegion(c.Context(), region)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Failed to search currencies by region",
                                err,
                        )
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Currencies by region fetched successfully",
                        currencies,
                )</span>
        }
}

// GetCurrencyStatistics returns currency statistics
// @Summary Get currency statistics
// @Description Get currency registry statistics
// @Tags currencies
// @Accept json
// @Produce json
// @Success 200 {object} common.Response
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/statistics [get]
func GetCurrencyStatistics(
        currencySvc *currencysvc.Service,
) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                stats, err := currencySvc.GetStatistics(c.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Failed to get currency statistics",
                                err,
                        )
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Currency statistics fetched successfully",
                        stats,
                )</span>
        }
}

// GetDefaultCurrency returns the default currency information
// @Summary Get default currency
// @Description Get the default currency information
// @Tags currencies
// @Accept json
// @Produce json
// @Success 200 {object} common.Response
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/default [get]
func GetDefaultCurrency(
        currencySvc *currencysvc.Service,
) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                defaultCurrency, err := currencySvc.GetDefault(c.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Failed to get default currency",
                                err,
                        )
                }</span>
                <span class="cov0" title="0">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Default currency fetched successfully",
                        defaultCurrency,
                )</span>
        }
}

// RegisterCurrency registers a new currency (admin only)
// @Summary Register currency
// @Description Register a new currency (admin only)
// @Tags currencies
// @Accept json
// @Produce json
// @Param currency body RegisterRequest true "Currency information"
// @Success 201 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 409 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/admin [post]
func RegisterCurrency(
        currencySvc *currencysvc.Service,
) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                input, err := common.BindAndValidate[RegisterRequest](c)
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Error already written by BindAndValidate
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err = currencySvc.ValidateCode(c.Context(), input.Code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid currency code",
                                err,
                                fiber.StatusBadRequest,
                        )
                }</span>

                // Check if currency already exists
                <span class="cov0" title="0">if _, err := currencySvc.Get(c.Context(), input.Code); err == nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Currency already exists",
                                fmt.Errorf("currency with code %s already exists", input.Code),
                                fiber.StatusConflict,
                        )
                }</span>

                // Register the currency
                <span class="cov0" title="0">currEntity := currencysvc.Entity{
                        Code:     money.Code(input.Code),
                        Name:     input.Name,
                        Symbol:   input.Symbol,
                        Decimals: input.Decimals,
                        Country:  input.Country,
                        Region:   input.Region,
                        Active:   input.Active,
                }
                if err = currencySvc.Register(c.Context(), currEntity); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Failed to register currency",
                                err,
                                fiber.StatusInternalServerError,
                        )
                }</span>

                // Convert to response DTO
                <span class="cov0" title="0">resp := ToResponse(&amp;currEntity)

                return common.SuccessResponseJSON(
                        c,
                        fiber.StatusCreated,
                        "Currency registered successfully",
                        resp,
                )</span>
        }
}

// UnregisterCurrency removes a currency from the registry (admin only)
// @Summary Unregister currency
// @Description Remove a currency from the registry (admin only)
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/admin/{code} [delete]
func UnregisterCurrency(
        currencySvc *currencysvc.Service,
) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Currency code is required",
                                nil,
                        )
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid currency code",
                                err,
                        )
                }</span>

                <span class="cov0" title="0">if err := currencySvc.Unregister(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                                return common.ProblemDetailsJSON(
                                        c,
                                        "Failed to unregister currency: currency not found",
                                        err,
                                )
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(
                                c,
                                "Failed to unregister currency",
                                err,
                        )</span>
                }
                <span class="cov0" title="0">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Currency unregistered successfully",
                        fiber.Map{"code": code},
                )</span>
        }
}

// ActivateCurrency activates a currency (admin only)
// @Summary Activate currency
// @Description Activate a currency (admin only)
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/admin/{code}/activate [put]
func ActivateCurrency(
        currencySvc *currencysvc.Service,
) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Currency code is required",
                                nil,
                        )
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid currency code",
                                err,
                        )
                }</span>

                <span class="cov0" title="0">if err := currencySvc.Activate(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                                return common.ProblemDetailsJSON(
                                        c,
                                        "Failed to activate currency: currency not found",
                                        err,
                                )
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(
                                c,
                                "Failed to activate currency",
                                err,
                        )</span>
                }
                <span class="cov0" title="0">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Currency activated successfully",
                        fiber.Map{"code": code},
                )</span>
        }
}

// DeactivateCurrency deactivates a currency (admin only)
// @Summary Deactivate currency
// @Description Deactivate a currency (admin only)
// @Tags currencies
// @Accept json
// @Produce json
// @Param code path string true "Currency code"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /api/currencies/admin/{code}/deactivate [put]
func DeactivateCurrency(
        currencySvc *currencysvc.Service,
) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                code := c.Params("code")
                if code == "" </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Currency code is required",
                                nil,
                        )
                }</span>

                // Validate currency code format
                <span class="cov0" title="0">if err := currencySvc.ValidateCode(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid currency code",
                                err,
                        )
                }</span>

                <span class="cov0" title="0">if err := currencySvc.Deactivate(c.Context(), code); err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                                return common.ProblemDetailsJSON(
                                        c,
                                        "Failed to deactivate currency: currency not found",
                                        err,
                                )
                        }</span>
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(
                                c,
                                "Failed to deactivate currency",
                                err,
                        )</span>
                }
                <span class="cov0" title="0">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "Currency deactivated successfully",
                        fiber.Map{"code": code},
                )</span>
        }
}
</pre>

		<pre class="file" id="file96" style="display: none">package currency

import (
        "time"

        "github.com/amirasaad/fintech/pkg/money"
        "github.com/amirasaad/fintech/pkg/registry"
        currencysvc "github.com/amirasaad/fintech/pkg/service/currency"
)

// RegisterRequest represents the request body for registering a currency.
type RegisterRequest struct {
        Code     string            `json:"code" validate:"required,len=3,uppercase"`
        Name     string            `json:"name" validate:"required"`
        Symbol   string            `json:"symbol" validate:"required"`
        Decimals int               `json:"decimals" validate:"required,min=0,max=8"`
        Country  string            `json:"country,omitempty"`
        Region   string            `json:"region,omitempty"`
        Active   bool              `json:"active"`
        Metadata map[string]string `json:"metadata,omitempty"`
}

// CurrencyResponse represents the response structure for currency data
type CurrencyResponse struct {
        Code      string            `json:"code"`
        Name      string            `json:"name"`
        Symbol    string            `json:"symbol"`
        Decimals  int               `json:"decimals"`
        Country   string            `json:"country,omitempty"`
        Region    string            `json:"region,omitempty"`
        Active    bool              `json:"active"`
        Metadata  map[string]string `json:"metadata,omitempty"`
        CreatedAt time.Time         `json:"created_at"`
        UpdatedAt *time.Time        `json:"updated_at,omitempty"`
}

// ToResponse converts a currency entity to a response DTO
func ToResponse(entity *currencysvc.Entity) *CurrencyResponse <span class="cov0" title="0">{
        if entity == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">updatedAt := entity.UpdatedAt()

        return &amp;CurrencyResponse{
                Code:      entity.Code.String(),
                Name:      entity.Name,
                Symbol:    entity.Symbol,
                Decimals:  entity.Decimals,
                Country:   entity.Country,
                Region:    entity.Region,
                Active:    entity.Active,
                Metadata:  entity.Metadata(),
                CreatedAt: entity.CreatedAt(),
                UpdatedAt: &amp;updatedAt,
        }</span>
}

// ToServiceEntity converts a RegisterRequest to a service layer entity
func (r *RegisterRequest) ToServiceEntity() *currencysvc.Entity <span class="cov0" title="0">{
        return &amp;currencysvc.Entity{
                Entity:   registry.NewBaseEntity(r.Code, r.Name),
                Code:     money.Code(r.Code),
                Name:     r.Name,
                Symbol:   r.Symbol,
                Decimals: r.Decimals,
                Country:  r.Country,
                Region:   r.Region,
                Active:   r.Active,
        }
}</span>
</pre>

		<pre class="file" id="file97" style="display: none">package payment

import (
        "fmt"

        "github.com/amirasaad/fintech/pkg/provider"
        "github.com/gofiber/fiber/v2"
)

// StripeWebhookHandler handles incoming Stripe webhook events
func StripeWebhookHandler(
        paymentProvider provider.Payment,
) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Get the signature from the request headers
                signature := c.Get("Stripe-Signature")
                if signature == "" </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error": "Missing Stripe-Signature header",
                        })
                }</span>

                // Get the raw request body
                <span class="cov0" title="0">payload := c.Body()
                if len(payload) == 0 </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error": "Empty request body",
                        })
                }</span>

                // Process the webhook event
                <span class="cov0" title="0">_, err := paymentProvider.HandleWebhook(c.Context(), payload, signature)
                if err != nil </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error": fmt.Sprintf("Error processing webhook: %v", err),
                        })
                }</span>

                // Return a 200 response to acknowledge receipt of the event
                <span class="cov0" title="0">return c.SendStatus(fiber.StatusOK)</span>
        }
}

// StripeWebhookRoutes sets up the Stripe webhook routes
func StripeWebhookRoutes(
        app *fiber.App,
        paymentProvider provider.Payment,
) <span class="cov0" title="0">{
        // Webhook endpoint for Stripe events
        app.Post("/api/v1/webhooks/stripe", StripeWebhookHandler(paymentProvider))
}</span>
</pre>

		<pre class="file" id="file98" style="display: none">package testutils

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "net/http/httptest"
        "path/filepath"
        "runtime"
        "time"

        "github.com/amirasaad/fintech/pkg/app"
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/registry"

        "github.com/amirasaad/fintech/infra/eventbus"
        "github.com/amirasaad/fintech/infra/provider"
        infrarepo "github.com/amirasaad/fintech/infra/repository"
        fixturescurrency "github.com/amirasaad/fintech/internal/fixtures/currency"
        "github.com/amirasaad/fintech/pkg/domain"
        "github.com/amirasaad/fintech/pkg/domain/user"
        "github.com/amirasaad/fintech/webapi"
        "github.com/amirasaad/fintech/webapi/common"

        "github.com/gofiber/fiber/v2"
        "github.com/golang-migrate/migrate/v4"
        migratepostgres "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file" // required for file-based migrations
        "github.com/google/uuid"
        "github.com/stretchr/testify/suite"
        "github.com/testcontainers/testcontainers-go"
        tcpostgres "github.com/testcontainers/testcontainers-go/modules/postgres"
        "github.com/testcontainers/testcontainers-go/wait"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

// E2ETestSuite provides a test suite with a real Postgres database using Testcontainers
type E2ETestSuite struct {
        suite.Suite
        pgContainer *tcpostgres.PostgresContainer
        db          *gorm.DB
        app         *fiber.App
        cfg         *config.App
}

// BeforeEachTest runs before each test in the E2ETestSuite. It enables parallel test execution.
func (s *E2ETestSuite) BeforeEachTest() <span class="cov0" title="0">{
        s.T().Parallel()
}</span>

// SetupSuite initializes the test suite with a real Postgres database
func (s *E2ETestSuite) SetupSuite() <span class="cov0" title="0">{
        ctx := context.Background()

        // Start Postgres container
        pg, err := tcpostgres.Run(
                ctx,
                "postgres:15-alpine",
                tcpostgres.WithDatabase("testdb"),
                tcpostgres.WithUsername("test"),
                tcpostgres.WithPassword("test"),
                testcontainers.WithWaitStrategy(
                        wait.ForLog("database system is ready to accept connections").
                                WithOccurrence(2).WithStartupTimeout(30*time.Second),
                ),
        )
        s.Require().NoError(err)
        s.pgContainer = pg

        // Get connection string and connect to database
        dsn, err := pg.ConnectionString(ctx, "sslmode=disable")
        s.Require().NoError(err)

        s.db, err = gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        s.Require().NoError(err)

        // Run migrations
        sqlDB, err := s.db.DB()
        s.Require().NoError(err)

        driver, err := migratepostgres.WithInstance(sqlDB, &amp;migratepostgres.Config{})
        s.Require().NoError(err)

        _, filename, _, _ := runtime.Caller(0)
        migrationsPath := filepath.Join(filepath.Dir(filename), "../../internal/migrations")

        m, err := migrate.NewWithDatabaseInstance("file://"+migrationsPath, "postgres", driver)
        s.Require().NoError(err)

        err = m.Up()
        if err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                s.Require().NoError(err)
        }</span>

        // Load config
        <span class="cov0" title="0">envTest, err := config.FindEnvTest(".env.test")
        s.Require().NoError(err)
        s.cfg, err = config.Load(envTest)
        s.Require().NoError(err)
        s.cfg.DB.Url = dsn

        // Setup services and app
        s.setupApp()</span>
        // log.SetOutput(io.Discard)
}

// TearDownSuite cleans up the test suite resources
func (s *E2ETestSuite) TearDownSuite() <span class="cov0" title="0">{
        ctx := context.Background()
        if s.pgContainer != nil </span><span class="cov0" title="0">{
                _ = s.pgContainer.Terminate(ctx)
        }</span>
}

// setupApp creates all services and the test app,
// using Redis as the event bus via testcontainers-go.
func (s *E2ETestSuite) setupApp() <span class="cov0" title="0">{
        s.T().Helper()
        // Create deps with debug logging
        uow := infrarepo.NewUoW(s.db)
        // Enable debug logging
        logger := slog.New(slog.NewTextHandler(io.Discard, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        }))

        // Setup currency service
        ctx := context.Background()
        currencyRegistry, err := registry.NewBuilder().
                WithName("test_currency").
                WithRedis("").
                WithCache(100, time.Minute).
                BuildRegistry()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to create test currency registry provider: %w", err))</span>
        }

        // Load currency fixtures
        <span class="cov0" title="0">_, filename, _, _ := runtime.Caller(0)
        fixturePath := filepath.Join(
                filepath.Dir(filename),
                "../../internal/fixtures/currency/meta.csv",
        )
        metas, err := fixturescurrency.LoadCurrencyMetaCSV(fixturePath)
        s.Require().NoError(err)

        for _, meta := range metas </span><span class="cov0" title="0">{
                s.Require().NoError(currencyRegistry.Register(ctx, meta))
        }</span>

        // Start Redis container
        <span class="cov0" title="0">redisContainer, err := testcontainers.GenericContainer(
                ctx,
                testcontainers.GenericContainerRequest{
                        ContainerRequest: testcontainers.ContainerRequest{
                                Image:        "redis:7-alpine",
                                ExposedPorts: []string{"6379/tcp"},
                                WaitingFor: wait.ForListeningPort(
                                        "6379/tcp",
                                ).WithStartupTimeout(10 * time.Second),
                        },
                        Started: true,
                },
        )
        s.Require().NoError(err)

        endpoint, err := redisContainer.Endpoint(ctx, "")
        s.Require().NoError(err)

        // Setup Redis EventBus
        eventBus, err := eventbus.NewWithRedis("redis://"+endpoint, logger)
        s.Require().NoError(err)

        // Store Redis container for cleanup at the end of this test
        s.T().Cleanup(func() </span><span class="cov0" title="0">{
                _ = redisContainer.Terminate(ctx)
        }</span>)

        // Create registry providers for each service with in-memory storage
        <span class="cov0" title="0">mainReg, err := registry.NewBuilder().
                WithName("test").
                WithRedis(""). // Empty URL for in-memory
                WithCache(100, time.Minute).
                BuildRegistry()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to create test main registry provider: %w", err))</span>
        }
        <span class="cov0" title="0">mainRegistry, ok := mainReg.(*registry.Enhanced)
        if !ok </span><span class="cov0" title="0">{
                panic("main registry is not of type *registry.Enhanced")</span>
        }

        // Create currency registry
        <span class="cov0" title="0">currencyReg, err := registry.NewBuilder().
                WithName("test_currency").
                WithRedis("").
                WithCache(100, time.Minute).
                BuildRegistry()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to create test currency registry provider: %w", err))</span>
        }
        <span class="cov0" title="0">currencyRegistry, ok = currencyReg.(*registry.Enhanced)
        if !ok </span><span class="cov0" title="0">{
                panic("currency registry is not of type *registry.Enhanced")</span>
        }

        // Create checkout registry
        <span class="cov0" title="0">checkoutReg, err := registry.NewBuilder().
                WithName("test_checkout").
                WithRedis("").
                WithCache(100, time.Minute).
                BuildRegistry()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to create test checkout registry provider: %w", err))</span>
        }
        <span class="cov0" title="0">checkoutRegistry, ok := checkoutReg.(*registry.Enhanced)
        if !ok </span><span class="cov0" title="0">{
                panic("checkout registry is not of type *registry.Enhanced")</span>
        }

        // Create exchange rate registry
        <span class="cov0" title="0">exchangeRateReg, err := registry.NewBuilder().
                WithName("test_exchange_rate").
                WithRedis("").
                WithCache(100, time.Minute).
                BuildRegistry()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to create test exchange rate registry provider: %w", err))</span>
        }
        <span class="cov0" title="0">exchangeRateRegistry, ok := exchangeRateReg.(*registry.Enhanced)
        if !ok </span><span class="cov0" title="0">{
                panic("exchange rate registry is not of type *registry.Enhanced")</span>
        }
        <span class="cov0" title="0">exchangeRateProvider := provider.NewMockExchangeRate()
        mockPaymentProvider := provider.NewMockPaymentProvider()

        deps := &amp;app.Deps{
                RegistryProvider:     mainRegistry,
                CurrencyRegistry:     currencyRegistry,
                CheckoutRegistry:     checkoutRegistry,
                ExchangeRateRegistry: exchangeRateRegistry,
                ExchangeRateProvider: exchangeRateProvider,
                PaymentProvider:      mockPaymentProvider,
                Uow:                  uow,
                EventBus:             eventBus,
                Logger:               logger,
        }

        // Create test app
        s.app = webapi.SetupApp(app.New(
                deps,
                s.cfg,
        ))</span>
}

// MakeRequest is a helper for making HTTP requests in tests
func (s *E2ETestSuite) MakeRequest(
        method, path, body, token string,
) *http.Response <span class="cov0" title="0">{
        var req *http.Request
        if body != "" </span><span class="cov0" title="0">{
                req = httptest.NewRequest(method, path, bytes.NewBufferString(body))
                req.Header.Set("Content-Type", "application/json")
        }</span> else<span class="cov0" title="0"> {
                req = httptest.NewRequest(method, path, nil)
        }</span>
        <span class="cov0" title="0">if token != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+token)
        }</span>
        <span class="cov0" title="0">resp, err := s.app.Test(req, 1000000)
        if err != nil </span><span class="cov0" title="0">{
                s.T().Fatal(err)
        }</span>
        <span class="cov0" title="0">return resp</span>
}

// CreateTestUser creates a unique test user via the POST /user/ endpoint
func (s *E2ETestSuite) CreateTestUser() *domain.User <span class="cov0" title="0">{
        randomID := uuid.New().String()[:8]
        username := fmt.Sprintf("testuser_%s", randomID)
        email := fmt.Sprintf("test_%s@example.com", randomID)

        // Create user via HTTP POST request
        createUserBody := fmt.Sprintf(
                `{"username":"%s","email":"%s","password":"password123"}`,
                username,
                email,
        )
        resp := s.MakeRequest("POST", "/user", createUserBody, "")

        if resp.StatusCode != 201 </span><span class="cov0" title="0">{
                // Read the response body for more details
                body, _ := io.ReadAll(resp.Body)
                s.T().Logf("User creation failed with status %d.", resp.StatusCode)
                s.T().Logf("Response body: %s", string(body))
                s.T().Fatalf("Expected 201 Created for user creation, got %d", resp.StatusCode)
        }</span>

        // Parse response to get the created user
        <span class="cov0" title="0">var response common.Response
        err := json.NewDecoder(resp.Body).Decode(&amp;response)
        if err != nil </span><span class="cov0" title="0">{
                s.T().Fatal(err)
        }</span>

        // Extract user data from response
        <span class="cov0" title="0">if userData, ok := response.Data.(map[string]any); ok </span><span class="cov0" title="0">{
                userIDStr, ok := userData["id"].(string)
                if !ok </span><span class="cov0" title="0">{
                        s.T().Fatalf("User ID should be present in response")
                }</span>

                <span class="cov0" title="0">userID, parseErr := uuid.Parse(userIDStr)
                if parseErr != nil </span><span class="cov0" title="0">{
                        s.T().Fatalf("User ID should be a valid UUID")
                }</span>

                <span class="cov0" title="0">return &amp;domain.User{
                        ID:       userID,
                        Username: username,
                        Email:    email,
                        Password: "password123",
                }</span>
        }

        // Fallback: create user directly
        <span class="cov0" title="0">testUser, err := user.New(username, email, "password123")
        if err != nil </span><span class="cov0" title="0">{
                s.T().Fatalf("Failed to create user: %v", err)
        }</span>
        <span class="cov0" title="0">return testUser</span>
}

// LoginUser makes an actual HTTP request to login and returns the JWT token
func (s *E2ETestSuite) LoginUser(testUser *domain.User) string <span class="cov0" title="0">{
        loginBody := fmt.Sprintf(`{"identity":"%s","password":"%s"}`, testUser.Email, testUser.Password)
        resp := s.MakeRequest("POST", "/auth/login", loginBody, "")

        var response common.Response
        err := json.NewDecoder(resp.Body).Decode(&amp;response)
        if err != nil </span><span class="cov0" title="0">{
                s.T().Fatal(err)
        }</span>

        // Extract token from response
        <span class="cov0" title="0">var token string
        if dataMap, ok := response.Data.(map[string]any); ok </span><span class="cov0" title="0">{
                if tokenInterface, exists := dataMap["token"]; exists </span><span class="cov0" title="0">{
                        token = tokenInterface.(string)
                }</span>
        } else<span class="cov0" title="0"> if dataMap, ok := response.Data.(map[string]string); ok </span><span class="cov0" title="0">{
                token = dataMap["token"]
        }</span> else<span class="cov0" title="0"> if tokenString, ok := response.Data.(string); ok </span><span class="cov0" title="0">{
                token = tokenString
        }</span>

        <span class="cov0" title="0">s.T().Logf("Extracted token: %s", token)
        if token == "" </span><span class="cov0" title="0">{
                s.T().Fatalf("No token found in response")
        }</span>
        <span class="cov0" title="0">return token</span>
}
</pre>

		<pre class="file" id="file99" style="display: none">package user

import (
        "github.com/amirasaad/fintech/pkg/config"
        "github.com/amirasaad/fintech/pkg/dto"
        "github.com/amirasaad/fintech/pkg/middleware"
        authsvc "github.com/amirasaad/fintech/pkg/service/auth"
        usersvc "github.com/amirasaad/fintech/pkg/service/user"
        "github.com/amirasaad/fintech/webapi/common"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

// Routes registers HTTP routes for user-related operations.
// Sets up endpoints for user creation, retrieval, update, and deletion.
func Routes(
        app *fiber.App,
        userSvc *usersvc.Service,
        authSvc *authsvc.Service,
        cfg *config.App,
) <span class="cov8" title="1">{
        app.Get("/user/:id", middleware.JwtProtected(cfg.Auth.Jwt), GetUser(userSvc))
        app.Post("/user", CreateUser(userSvc))
        app.Put("/user/:id",
                middleware.JwtProtected(cfg.Auth.Jwt),
                UpdateUser(userSvc, authSvc))
        app.Delete("/user/:id",
                middleware.JwtProtected(cfg.Auth.Jwt),
                DeleteUser(userSvc, authSvc))
}</span>

// GetUser returns a Fiber handler for retrieving a user by ID.
// @Summary Get user by ID
// @Description Retrieve a user by their ID
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 404 {object} common.ProblemDetails
// @Router /user/{id} [get]
// @Security Bearer
func GetUser(userSvc *usersvc.Service) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid user ID: %v", err)
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid user ID",
                                err,
                                "User ID must be a valid UUID",
                                fiber.StatusBadRequest,
                        )
                }</span>
                <span class="cov8" title="1">user, err := userSvc.GetUser(
                        c.Context(),
                        id.String(),
                )
                if err != nil || user == nil </span><span class="cov8" title="1">{
                        // Generic error for not found to prevent user enumeration
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid credentials",
                                nil,
                                fiber.StatusUnauthorized,
                        )
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "User found",
                        user,
                )</span>
        }
}

// CreateUser creates a new user account.
// @Summary Create a new user
// @Description Create a new user account with username, email, and password
// @Tags users
// @Accept json
// @Produce json
// @Param request body NewUser true "User creation data"
// @Success 201 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /user [post]
func CreateUser(userSvc *usersvc.Service) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                input, err := common.BindAndValidate[NewUser](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">if len(input.Password) &gt; 72 </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c,
                                "Invalid request body",
                                nil,
                                "Password too long",
                                fiber.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">user, err := userSvc.CreateUser(
                        c.Context(),
                        input.Username,
                        input.Email,
                        input.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Couldn't create user",
                                err, fiber.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusCreated,
                        "Created user",
                        user)</span>
        }
}

// UpdateUser updates user information.
// @Summary Update user
// @Description Update user information by ID
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Param request body UpdateUserInput true "User update data"
// @Success 200 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /user/{id} [put]
// @Security Bearer
func UpdateUser(
        userSvc *usersvc.Service,
        authSvc *authsvc.Service,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                input, err := common.BindAndValidate[UpdateUserInput](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid user ID: %v", err)
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid user ID",
                                err,
                                "User ID must be a valid UUID",
                                fiber.StatusBadRequest,
                        )
                }</span>
                <span class="cov8" title="1">token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Unauthorized", nil,
                                fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(c, "Unauthorized", nil,
                                fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">if id != userID </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Forbidden", nil,
                                fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">err = userSvc.UpdateUser(c.Context(), id.String(), &amp;dto.UserUpdate{
                        Names: &amp;input.Names,
                })
                if err != nil </span><span class="cov0" title="0">{
                        // Generic error for update failure
                        return common.ProblemDetailsJSON(
                                c,
                                "Unauthorized",
                                nil,
                                "missing user context", fiber.StatusUnauthorized)
                }</span>
                // Get the updated user to return in response
                <span class="cov8" title="1">updatedUser, err := userSvc.GetUser(c.Context(), id.String())
                if err != nil || updatedUser == nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Unauthorized",
                                nil,
                                fiber.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusOK,
                        "User updated successfully",
                        updatedUser)</span>
        }
}

// DeleteUser deletes a user account.
// @Summary Delete user
// @Description Delete a user account by ID with password confirmation
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Param request body PasswordInput true "Password confirmation"
// @Success 204 {object} common.Response
// @Failure 400 {object} common.ProblemDetails
// @Failure 401 {object} common.ProblemDetails
// @Failure 429 {object} common.ProblemDetails
// @Failure 500 {object} common.ProblemDetails
// @Router /user/{id} [delete]
// @Security Bearer
func DeleteUser(
        userSvc *usersvc.Service,
        authSvc *authsvc.Service,
) fiber.Handler <span class="cov8" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                input, err := common.BindAndValidate[PasswordInput](c)
                if input == nil </span><span class="cov8" title="1">{
                        return err // error response already written
                }</span>
                <span class="cov8" title="1">id, err := uuid.Parse(c.Params("id"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Invalid user ID: %v", err)
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid user ID",
                                err,
                                "User ID must be a valid UUID",
                                fiber.StatusBadRequest,
                        )
                }</span>
                <span class="cov8" title="1">token, ok := c.Locals("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Unauthorized",
                                nil,
                                "missing user context",
                                fiber.StatusUnauthorized,
                        )
                }</span>
                <span class="cov8" title="1">userID, err := authSvc.GetCurrentUserId(token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to parse user ID from token: %v", err)
                        return common.ProblemDetailsJSON(
                                c,
                                "Unauthorized",
                                nil,
                                "missing user context",
                                fiber.StatusUnauthorized,
                        )
                }</span>
                <span class="cov8" title="1">if id != userID </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Forbidden",
                                nil,
                                "You are not allowed to delete this user",
                                fiber.StatusUnauthorized,
                        )
                }</span>
                // Retrieve user to get email for password validation
                <span class="cov8" title="1">user, err := userSvc.GetUser(c.Context(), id.String())
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Error getting user for password validation: %v", err)
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid credentials",
                                err,
                                "Internal server error during user validation",
                                fiber.StatusInternalServerError,
                        )
                }</span>
                <span class="cov8" title="1">if user == nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Invalid credentials",
                                nil,
                                "User not found",
                                fiber.StatusUnauthorized,
                        )
                }</span>

                <span class="cov8" title="1">if isValid, validErr := userSvc.ValidUser(
                        c.Context(),
                        user.Email,
                        input.Password,
                ); validErr != nil || !isValid </span><span class="cov8" title="1">{
                        // If this is a DB/internal error, return 500
                        if !isValid </span><span class="cov8" title="1">{
                                return common.ProblemDetailsJSON(
                                        c,
                                        "Invalid credentials",
                                        nil,
                                        "Invalid username or password",
                                        fiber.StatusUnauthorized,
                                )
                        }</span>
                        // If err is not nil, it's an internal server error during validation
                        <span class="cov0" title="0">return common.ProblemDetailsJSON(
                                c,
                                "Failed to validate user",
                                err,
                                fiber.StatusInternalServerError,
                        )</span>
                }
                <span class="cov8" title="1">err = userSvc.DeleteUser(c.Context(), id.String())
                if err != nil </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Couldn't delete user",
                                err,
                                "Internal server error during user deletion",
                                fiber.StatusInternalServerError,
                        )
                }</span>
                <span class="cov8" title="1">return common.SuccessResponseJSON(
                        c,
                        fiber.StatusNoContent,
                        "User successfully deleted",
                        nil,
                )</span>
        }
}
</pre>

		<pre class="file" id="file100" style="display: none">// Package webapi provides HTTP handlers and API endpoints for the fintech application.
// It is organized into sub-packages for different domains:
// - account: Account and transaction endpoints
// - auth: Authentication endpoints
// - user: User management endpoints
// - currency: Currency and exchange rate endpoints
package webapi

import (
        "errors"
        "strings"

        "github.com/amirasaad/fintech/pkg/app"
        accountweb "github.com/amirasaad/fintech/webapi/account"
        authweb "github.com/amirasaad/fintech/webapi/auth"
        checkoutweb "github.com/amirasaad/fintech/webapi/checkout"
        "github.com/amirasaad/fintech/webapi/common"
        currencyweb "github.com/amirasaad/fintech/webapi/currency"
        "github.com/amirasaad/fintech/webapi/payment"
        userweb "github.com/amirasaad/fintech/webapi/user"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/limiter"
        "github.com/gofiber/fiber/v2/middleware/logger"
        "github.com/gofiber/fiber/v2/middleware/recover"

        "github.com/gofiber/swagger"
)

// SetupApp Initialize Fiber with custom configuration
func SetupApp(app *app.App) *fiber.App <span class="cov8" title="1">{
        accountSvc := app.AccountService
        userSvc := app.UserService
        authSvc := app.AuthService
        currencySvc := app.CurrencyService
        checkoutSvc := app.CheckoutService

        fiberApp := fiber.New(fiber.Config{
                ErrorHandler: func(c *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(c, "Internal Server Error", err)
                }</span>,
        })
        <span class="cov8" title="1">fiberApp.Get("/swagger/*", swagger.New(swagger.Config{
                TryItOutEnabled:      true,
                WithCredentials:      true,
                PersistAuthorization: true,
                OAuth2RedirectUrl:    "/auth/login",
        }))

        // Configure rate limiting middleware
        // Uses X-Forwarded-For header when behind a proxy
        // Falls back to X-Real-IP or direct IP if needed
        fiberApp.Use(limiter.New(limiter.Config{
                Max:        app.Config.RateLimit.MaxRequests,
                Expiration: app.Config.RateLimit.Window,
                KeyGenerator: func(c *fiber.Ctx) string </span><span class="cov8" title="1">{
                        // Use X-Forwarded-For header if available (for load balancers/proxies)
                        // Fall back to X-Real-IP, then to direct IP
                        if forwardedFor := c.Get("X-Forwarded-For"); forwardedFor != "" </span><span class="cov0" title="0">{
                                // Take the first IP in the chain
                                if commaIndex := strings.Index(forwardedFor, ","); commaIndex != -1 </span><span class="cov0" title="0">{
                                        return strings.TrimSpace(forwardedFor[:commaIndex])
                                }</span>
                                <span class="cov0" title="0">return strings.TrimSpace(forwardedFor)</span>
                        }
                        <span class="cov8" title="1">if realIP := c.Get("X-Real-IP"); realIP != "" </span><span class="cov0" title="0">{
                                return realIP
                        }</span>
                        <span class="cov8" title="1">return c.IP()</span>
                },
                LimitReached: func(c *fiber.Ctx) error <span class="cov0" title="0">{
                        return common.ProblemDetailsJSON(
                                c,
                                "Too Many Requests",
                                errors.New("rate limit exceeded"),
                                fiber.StatusTooManyRequests,
                        )
                }</span>,
        }))
        <span class="cov8" title="1">fiberApp.Use(recover.New())
        fiberApp.Use(logger.New())

        // Health check endpoint
        fiberApp.Get(
                "/",
                func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                        return c.SendString("FinTech API is running! 🚀")
                }</span>,
        )

        // Payment event processor for Stripe webhooks
        <span class="cov8" title="1">fiberApp.Post(
                "/api/v1/webhooks/stripe",
                payment.StripeWebhookHandler(app.Deps.PaymentProvider),
        )

        accountweb.Routes(fiberApp, accountSvc, authSvc, app.Config)
        userweb.Routes(fiberApp, userSvc, authSvc, app.Config)
        authweb.Routes(fiberApp, authSvc)
        currencyweb.Routes(fiberApp, currencySvc, authSvc, app.Config)
        checkoutweb.Routes(fiberApp, checkoutSvc, authSvc, app.Config)
        return fiberApp</span>
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
